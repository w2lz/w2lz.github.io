[{"categories":["AlgoCasts","LeetCode"],"content":"桶排序是一种稳定的排序算法。它的工作原理是将序列中的元素分布到一定数量的桶内，然后分别对每个桶内的元素进行排序，最后再将各个桶内的有序子序列放回原始序列中。对于单个桶内的元素排序，我们可以使用别的排序算法，也可以递归使用桶排序。一般来说，对于单个桶内的元素，使用插入排序算法对它们进行排序。","date":"2025-05-05","objectID":"/posts/s10.%E6%A1%B6%E6%8E%92%E5%BA%8F/","tags":["AlgoCasts","LeetCode"],"title":"S10. 桶排序","uri":"/posts/s10.%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 桶排序是一种稳定的排序算法。它的工作原理是将序列中的元素分布到一定数量的桶内，然后分别对每个桶内的元素进行排序，最后再将各个桶内的有序子序列放回原始序列中。对于单个桶内的元素排序，我们可以使用别的排序算法，也可以递归使用桶排序。一般来说，对于单个桶内的元素，使用插入排序算法对它们进行排序。 桶排序适用于数据是均匀分布的情况，这样可以让分布到各个桶内的元素数量相当。而不是被集中分配到其中一个桶或几个桶。 2 难度 中等 3 题解 ","date":"2025-05-05","objectID":"/posts/s10.%E6%A1%B6%E6%8E%92%E5%BA%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"S10. 桶排序","uri":"/posts/s10.%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"基数排序是一种稳定的排序算法。它不是基于比较的算法，因此可以突破 O(n*log(n)) 的下界。基数排序的工作原理是，根据选取的基数，把整数键值分割成几个部分。依次以这几个部分所对应的整数作为键值，对原始序列进行多次计数排序或桶排序。","date":"2025-05-05","objectID":"/posts/s11.%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/","tags":["AlgoCasts","LeetCode"],"title":"S11. 基数排序","uri":"/posts/s11.%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 基数排序是一种稳定的排序算法。它不是基于比较的算法，因此可以突破 O(n*log(n)) 的下界。基数排序的工作原理是，根据选取的基数，把整数键值分割成几个部分。依次以这几个部分所对应的整数作为键值，对原始序列进行多次计数排序或桶排序。 基数排序不仅可以用来排序整数键值，对于较短的字符串键值排序，基数排序也是一种非常好的选择。比如车牌号排序。 2 难度 困难 3 题解 ","date":"2025-05-05","objectID":"/posts/s11.%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"S11. 基数排序","uri":"/posts/s11.%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"计数排序是一种稳定的排序算法。它不是基于比较的排序算法，因此可以突破 O(n*log(n)) 的下界，在线性时间内完成排序。","date":"2025-05-05","objectID":"/posts/s9.%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/","tags":["AlgoCasts","LeetCode"],"title":"S9. 计数排序","uri":"/posts/s9.%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 计数排序是一种稳定的排序算法。它不是基于比较的排序算法，因此可以突破 O(n*log(n)) 的下界，在线性时间内完成排序。 计数排序适用于序列的键值是较小范围的整数，或是可以映射到较小范围整数的情况。它的算法思想是统计相同键值的元素个数，然后以键值为下标，把统计结果存储到一个较小的数组中。根据元素的出现个数，再计算出每个元素在排序数组中所在下标，根据这些下标，把元素放到正确的位置上即可。 2 难度 中等 3 题解 ","date":"2025-05-05","objectID":"/posts/s9.%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"S9. 计数排序","uri":"/posts/s9.%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"快速排序是由东尼·霍尔提出的一种高效的排序算法，简称快排。它的算法思想并不复杂，可以用 3 个步骤 6 个字来概括：选基、分割、递归。扩充成一句话就是：首先挑选基准值；然后分割数组，把小于基准值的元素放到基准值前面，大于基准值的元素放到基准值后面；最后递归地对小于基准值的子序列和大于基准值的子序列进行排序。","date":"2025-05-05","objectID":"/posts/s6.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","tags":["AlgoCasts","LeetCode"],"title":"S6. 快速排序","uri":"/posts/s6.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 快速排序是由东尼·霍尔提出的一种高效的排序算法，简称快排。它的算法思想并不复杂，可以用 3 个步骤 6 个字来概括：选基、分割、递归。扩充成一句话就是：首先挑选基准值；然后分割数组，把小于基准值的元素放到基准值前面，大于基准值的元素放到基准值后面；最后递归地对小于基准值的子序列和大于基准值的子序列进行排序。 2 难度 中等 3 题解 ","date":"2025-05-05","objectID":"/posts/s6.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"S6. 快速排序","uri":"/posts/s6.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"归并排序是由冯·诺伊曼提出的一种基于分治思想的高效排序算法。它的算法思想是，把当前序列平分成两个子序列，然后递归地对子序列进行排序，最后把排序好的子序列再合并成一个有序的序列。","date":"2025-05-05","objectID":"/posts/s7.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","tags":["AlgoCasts","LeetCode"],"title":"S7. 归并排序","uri":"/posts/s7.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 归并排序是由冯·诺伊曼提出的一种基于分治思想的高效排序算法。它的算法思想是，把当前序列平分成两个子序列，然后递归地对子序列进行排序，最后把排序好的子序列再合并成一个有序的序列。 2 难度 中等 3 题解 ","date":"2025-05-05","objectID":"/posts/s7.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"S7. 归并排序","uri":"/posts/s7.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"堆排序是一种基于比较的排序算法。它的算法思想和选择排序相似，都是把数组分为有序区和无序区，每次都从无序区中取最大值或最小值，放入有序区，直到整个数组有序。和选择排序的区别是，堆排序使用了一个二叉堆来组织无序区中的数据，以此减少从无序区中查找最值的时间。","date":"2025-05-05","objectID":"/posts/s8.%E5%A0%86%E6%8E%92%E5%BA%8F/","tags":["AlgoCasts","LeetCode"],"title":"S8. 堆排序","uri":"/posts/s8.%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 堆排序是一种基于比较的排序算法。它的算法思想和选择排序相似，都是把数组分为有序区和无序区，每次都从无序区中取最大值或最小值，放入有序区，直到整个数组有序。和选择排序的区别是，堆排序使用了一个二叉堆来组织无序区中的数据，以此减少从无序区中查找最值的时间。 二叉堆逻辑上是一棵完全二叉树，但实际上存储在一维数组中即可。根据堆是最大堆还是最小堆的不同，具有不同的性质。在最大堆中，树上任意节点的值都大于等于它的子节点。而在最小堆中，树上任意节点的值都小于等于它的子节点。 2 难度 中等 3 题解 ","date":"2025-05-05","objectID":"/posts/s8.%E5%A0%86%E6%8E%92%E5%BA%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"S8. 堆排序","uri":"/posts/s8.%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"插入排序是一种简单直观的排序算法。这个算法把数组分为有序区和无序区，每次都从无序区中拿出一个元素，插入到有序区正确的位置上，使有序区保持有序。不断重复这个操作，直到整个数组都有序。","date":"2025-05-05","objectID":"/posts/s4.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","tags":["AlgoCasts","LeetCode"],"title":"S4. 插入排序","uri":"/posts/s4.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 插入排序是一种简单直观的排序算法。这个算法把数组分为有序区和无序区，每次都从无序区中拿出一个元素，插入到有序区正确的位置上，使有序区保持有序。不断重复这个操作，直到整个数组都有序。 2 难度 简单 3 题解 ","date":"2025-05-05","objectID":"/posts/s4.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"S4. 插入排序","uri":"/posts/s4.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"希尔排序是由希尔提出的一种排序算法，它是插入排序的改进版本。希尔排序通过引入步长 gap，将数组分成多个子序列分别进行插入排序，这样可以让一个元素朝最终位置跳跃一大步。步长在每一轮排序后递减，最后减至 1，变成简单插入排序。这个时候，数组已经基本有序，只需要再做少量的对比和移动即可完成最后的排序。","date":"2025-05-05","objectID":"/posts/s5.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/","tags":["AlgoCasts","LeetCode"],"title":"S5. 希尔排序","uri":"/posts/s5.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 希尔排序是由希尔提出的一种排序算法，它是插入排序的改进版本。希尔排序通过引入步长 gap，将数组分成多个子序列分别进行插入排序，这样可以让一个元素朝最终位置跳跃一大步。步长在每一轮排序后递减，最后减至 1，变成简单插入排序。这个时候，数组已经基本有序，只需要再做少量的对比和移动即可完成最后的排序。 2 难度 简单 3 题解 ","date":"2025-05-05","objectID":"/posts/s5.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"S5. 希尔排序","uri":"/posts/s5.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"冒泡排序的原理是，每一次遍历数组，都去不断地比较相邻的两个元素，如果它们的顺序不对，就交换这两个元素，比如把较大的换到后面。第一次遍历可以把最大的元素确定下来，放在最后的位置。第二次遍历可以确定第二大的元素，依次类推。这样遍历 N 次后，整个数组就变成递增有序。","date":"2025-05-05","objectID":"/posts/s1.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","tags":["AlgoCasts","LeetCode"],"title":"S1. 冒泡排序","uri":"/posts/s1.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 冒泡排序的原理是，每一次遍历数组，都去不断地比较相邻的两个元素，如果它们的顺序不对，就交换这两个元素，比如把较大的换到后面。第一次遍历可以把最大的元素确定下来，放在最后的位置。第二次遍历可以确定第二大的元素，依次类推。这样遍历 N 次后，整个数组就变成递增有序。 2 难度 简单 3 题解 ","date":"2025-05-05","objectID":"/posts/s1.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"S1. 冒泡排序","uri":"/posts/s1.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"鸡尾酒排序是冒泡排序的一种变体，又叫做双向冒泡排序。顾名思义，它从两个方向对数组或序列进行冒泡排序。每一次从左向右进行冒泡排序后，紧接着一次从右向左的冒泡排序。这样从左向右，然后从右向左，来回反复地进行冒泡排序，就像在摇晃调制一杯鸡尾酒，因此得名鸡尾酒排序。","date":"2025-05-05","objectID":"/posts/s2.%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F/","tags":["AlgoCasts","LeetCode"],"title":"S2. 鸡尾酒排序","uri":"/posts/s2.%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 鸡尾酒排序是冒泡排序的一种变体，又叫做双向冒泡排序。顾名思义，它从两个方向对数组或序列进行冒泡排序。每一次从左向右进行冒泡排序后，紧接着一次从右向左的冒泡排序。这样从左向右，然后从右向左，来回反复地进行冒泡排序，就像在摇晃调制一杯鸡尾酒，因此得名鸡尾酒排序。 2 难度 简单 3 题解 ","date":"2025-05-05","objectID":"/posts/s2.%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"S2. 鸡尾酒排序","uri":"/posts/s2.%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"选择排序是一种简单直观的排序算法。这个算法把数组分为有序区和无序区，每次都选择无序区中的最大值或最小值，放入有序区中，直到整个数组都有序。","date":"2025-05-05","objectID":"/posts/s3.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","tags":["AlgoCasts","LeetCode"],"title":"S3. 选择排序","uri":"/posts/s3.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 选择排序是一种简单直观的排序算法。这个算法把数组分为有序区和无序区，每次都选择无序区中的最大值或最小值，放入有序区中，直到整个数组都有序。 2 难度 简单 3 题解 ","date":"2025-05-05","objectID":"/posts/s3.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"S3. 选择排序","uri":"/posts/s3.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你 0 到 n-1 共 n 个城市，城市之间有的相互连接，有的则不相连。如果城市 0 与城市 1 直接相连，城市 1 与城市 2 直接相连，那么城市 0 与城市 2 称为间接相连。直接相连或间接相连的一组城市定义为一个省份。现在给你一个 n x n 的矩阵 a 表示城市之间的连接情况。a(i, j) 等于 1 表示第 i 个城市和第 j 个城市直接相连，a(i, j) 等于 0 则表示这两个城市不直接相连。你要计算出，这 n 个城市一共构成了多少个省份。","date":"2025-05-05","objectID":"/posts/p243.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/","tags":["AlgoCasts","LeetCode"],"title":"P243. 省份数量","uri":"/posts/p243.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你 0 到 n-1 共 n 个城市，城市之间有的相互连接，有的则不相连。如果城市 0 与城市 1 直接相连，城市 1 与城市 2 直接相连，那么城市 0 与城市 2 称为间接相连。 直接相连或间接相连的一组城市定义为一个省份。现在给你一个 n x n 的矩阵 a 表示城市之间的连接情况。a(i, j) 等于 1 表示第 i 个城市和第 j 个城市直接相连，a(i, j) 等于 0 则表示这两个城市不直接相连。你要计算出，这 n 个城市一共构成了多少个省份。 比如说，给你 3 个城市： 0, 1, 2 它们对应的连接矩阵 a 是： 1, 0, 0 0, 1, 1 0, 1, 1 根据这个矩阵，我们可以知道城市 0 不与城市 1 或城市 2 相连，它自成一个省份。城市 1 与城市 2 相互连接，构成一个省份。 因此，这 3 个城市构成了 2 个省份。 2 LeetCode 547. 省份数量 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p243.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P243. 省份数量","uri":"/posts/p243.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个不为空的整数数组，数组中的元素表示每天的温度。你要计算出，对于每一天来说，温度升高需要等待的天数。如果对于某一天，未来不存在比它更高的温度，就把它对应的等待天数设置为 0。","date":"2025-05-05","objectID":"/posts/p241.%E6%B8%A9%E5%BA%A6%E5%8D%87%E9%AB%98%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85%E7%9A%84%E5%A4%A9%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P241. 温度升高需要等待的天数","uri":"/posts/p241.%E6%B8%A9%E5%BA%A6%E5%8D%87%E9%AB%98%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85%E7%9A%84%E5%A4%A9%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个不为空的整数数组，数组中的元素表示每天的温度。你要计算出，对于每一天来说，温度升高需要等待的天数。如果对于某一天，未来不存在比它更高的温度，就把它对应的等待天数设置为 0。 比如说，给你的温度数组是： 1, 3, 1, 3, 2, 6 对于每一天来说，温度升高需要等待的天数是： 1, 4, 1, 2, 1, 0 2 LeetCode 739. 每日温度 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p241.%E6%B8%A9%E5%BA%A6%E5%8D%87%E9%AB%98%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85%E7%9A%84%E5%A4%A9%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P241. 温度升高需要等待的天数","uri":"/posts/p241.%E6%B8%A9%E5%BA%A6%E5%8D%87%E9%AB%98%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85%E7%9A%84%E5%A4%A9%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你要实现一个并查集，其中包含 find 和 union 两个方法。find(x) 用于查找元素 x 属于哪个集合，你需要返回集合内的一个代表元素。union(x, y) 用于合并元素 x 和元素 y 所在的两个集合。注意：为了方便起见，集合中的元素使用非负整数来表示。","date":"2025-05-05","objectID":"/posts/p242.%E5%AE%9E%E7%8E%B0%E5%B9%B6%E6%9F%A5%E9%9B%86/","tags":["AlgoCasts","LeetCode"],"title":"P242. 实现并查集","uri":"/posts/p242.%E5%AE%9E%E7%8E%B0%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你要实现一个并查集，其中包含 find 和 union 两个方法。find(x) 用于查找元素 x 属于哪个集合，你需要返回集合内的一个代表元素。union(x, y) 用于合并元素 x 和元素 y 所在的两个集合。注意：为了方便起见，集合中的元素使用非负整数来表示。 2 LeetCode 无 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p242.%E5%AE%9E%E7%8E%B0%E5%B9%B6%E6%9F%A5%E9%9B%86/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P242. 实现并查集","uri":"/posts/p242.%E5%AE%9E%E7%8E%B0%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一系列的会议时间区间，每个时间区间由开始时间和结束时间构成。你要判断出同一个人是否可以参加所有会议。","date":"2025-05-05","objectID":"/posts/p238.%E8%83%BD%E5%90%A6%E5%8F%82%E5%8A%A0%E6%89%80%E6%9C%89%E4%BC%9A%E8%AE%AE/","tags":["AlgoCasts","LeetCode"],"title":"P238. 能否参加所有会议","uri":"/posts/p238.%E8%83%BD%E5%90%A6%E5%8F%82%E5%8A%A0%E6%89%80%E6%9C%89%E4%BC%9A%E8%AE%AE/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一系列的会议时间区间，每个时间区间由开始时间和结束时间构成。你要判断出同一个人是否可以参加所有会议。 比如说，给你两个时间区间： [2, 4] [4, 6] 这两个时间区间没有重叠，因此所有会议都能参加，返回 true。 如果再增加一个会议，得到三个时间区间： [2, 4] [4, 6] [1, 3] 由于 [1, 3] 和 [2, 4] 在时间上有重叠，因此同一个人不可能参加所有会议，返回 false。 2 LeetCode 252. 会议室 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p238.%E8%83%BD%E5%90%A6%E5%8F%82%E5%8A%A0%E6%89%80%E6%9C%89%E4%BC%9A%E8%AE%AE/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P238. 能否参加所有会议","uri":"/posts/p238.%E8%83%BD%E5%90%A6%E5%8F%82%E5%8A%A0%E6%89%80%E6%9C%89%E4%BC%9A%E8%AE%AE/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一系列的会议时间区间，每个时间区间由开始时间和结束时间构成。你要计算出开完这些会所需要的最少会议室数量。","date":"2025-05-05","objectID":"/posts/p239.%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E4%BC%9A%E8%AE%AE%E5%AE%A4%E6%95%B0%E9%87%8F/","tags":["AlgoCasts","LeetCode"],"title":"P239. 需要的最少会议室数量","uri":"/posts/p239.%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E4%BC%9A%E8%AE%AE%E5%AE%A4%E6%95%B0%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一系列的会议时间区间，每个时间区间由开始时间和结束时间构成。你要计算出开完这些会所需要的最少会议室数量。 比如说，给你两个时间区间： [2, 4] [4, 6] 这两个时间区间没有重叠，只需要使用一个会议室，因此返回 1。 如果再增加一个会议，得到三个时间区间： [2, 4] [4, 6] [1, 3] 对于这 3 个会议，至少需要两个会议室。一种会议安排方式为： 会议室 1：[1, 3], [4, 6] 会议室 2：[2, 4] 因此，需要的最少会议室数量是 2。 2 LeetCode 253. 会议室 II 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p239.%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E4%BC%9A%E8%AE%AE%E5%AE%A4%E6%95%B0%E9%87%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P239. 需要的最少会议室数量","uri":"/posts/p239.%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E4%BC%9A%E8%AE%AE%E5%AE%A4%E6%95%B0%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉搜索树，你要为它实现一个迭代器。迭代器中包含两个公有方法，next() 方法返回二叉搜索树中下一个最小的数字，hasNext() 方法返回是否还存在下一个数字。","date":"2025-05-05","objectID":"/posts/p240.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/","tags":["AlgoCasts","LeetCode"],"title":"P240. 二叉搜索树迭代器","uri":"/posts/p240.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉搜索树，你要为它实现一个迭代器。迭代器中包含两个公有方法，next() 方法返回二叉搜索树中下一个最小的数字，hasNext() 方法返回是否还存在下一个数字。 注意，next() 方法和 hasNext() 方法都要求平均时间复杂度是 O(1)，并且额外只能使用 O(h) 的辅助空间。其中，h 是二叉搜索树的高度。另外，你可以假设对 next() 方法的调用总是有效的，即不需要考虑在 next() 方法中处理不存在下一个数字的情况。 比如说，给你的二叉搜索树 t 是： t: 1 / \\ 0 4 / \\ 2 8 用 t 初始化迭代器，然后就可以调用 next() 和 hasNext()： BSTIterator it = new BSTIterator(t); it.next(); // 0 it.next(); // 1 it.next(); // 2 it.hasNext(); // true it.next(); // 4 it.next(); // 8 it.hasNext(); // false 2 LeetCode 173. 二叉搜索树迭代器 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p240.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P240. 二叉搜索树迭代器","uri":"/posts/p240.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个只包含小写字母的字符串 S，你要判断是否可以通过重新组织字符串中的字符，使得任意两个相邻的字符都不相同。如果可以，则返回其中一种可能的重组结果；如果不可以，则返回空字符串。","date":"2025-05-05","objectID":"/posts/p236.%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8D%E7%BB%84/","tags":["AlgoCasts","LeetCode"],"title":"P236. 字符串重组","uri":"/posts/p236.%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8D%E7%BB%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个只包含小写字母的字符串 S，你要判断是否可以通过重新组织字符串中的字符，使得任意两个相邻的字符都不相同。如果可以，则返回其中一种可能的重组结果；如果不可以，则返回空字符串。 比如说，给你的字符串是： S = \"aab\" 你可以将它重新组织成 aba，这样相邻的字符就都不相同，因此返回 aba 即可。 再比如说，给你的字符串是： S = \"aaab\" 对于这个字符串，无论你怎么重新排列，都无法使得所有相邻的字符不相同。因此你要返回空字符串。 2 LeetCode 767. 重构字符串 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p236.%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8D%E7%BB%84/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P236. 字符串重组","uri":"/posts/p236.%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8D%E7%BB%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数 n，你要计算出 n 皇后问题解的数量。","date":"2025-05-05","objectID":"/posts/p237.n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E8%A7%A3%E7%9A%84%E6%95%B0%E9%87%8F/","tags":["AlgoCasts","LeetCode"],"title":"P237. N 皇后问题解的数量","uri":"/posts/p237.n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E8%A7%A3%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数 n，你要计算出 n 皇后问题解的数量。 n 皇后问题的定义是，你要把 n 个皇后放到一个 n x n 的棋盘上，使得任意两个皇后之间都不能互相攻击，也就是说任意两个皇后不能位于同一行、同一列以及同一斜线。 比如说，给你的 n 等于 4。 4 皇后问题有两个解，因此你要返回 2。 2 LeetCode 52. N 皇后 II 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p237.n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E8%A7%A3%E7%9A%84%E6%95%B0%E9%87%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P237. N 皇后问题解的数量","uri":"/posts/p237.n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E8%A7%A3%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数 n，你要返回 n 皇后问题的所有解。其中，每个解是一个棋盘布局，用字符 'Q' 表示一个皇后，用字符 '.' 表示一个空位置。","date":"2025-05-05","objectID":"/posts/p233.n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/","tags":["AlgoCasts","LeetCode"],"title":"P233. N 皇后问题","uri":"/posts/p233.n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数 n，你要返回 n 皇后问题的所有解。其中，每个解是一个棋盘布局，用字符 ‘Q’ 表示一个皇后，用字符 ‘.’ 表示一个空位置。 n 皇后问题的定义是，你要把 n 个皇后放到一个 n x n 的棋盘上，使得任意两个皇后之间都不能互相攻击，也就是说任意两个皇后不能位于同一行、同一列以及同一斜线。 比如说，给你的 n 等于 4。 4 皇后问题有以下两个解： [ [ \".Q..\", \"...Q\", \"Q...\", \"..Q.\" ], [ \"..Q.\", \"Q...\", \"...Q\", \".Q..\" ] ] 2 LeetCode 51. N 皇后 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p233.n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P233. N 皇后问题","uri":"/posts/p233.n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树，你要返回所有从根到叶子节点的路径。","date":"2025-05-05","objectID":"/posts/p234.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/","tags":["AlgoCasts","LeetCode"],"title":"P234. 二叉树中的所有路径","uri":"/posts/p234.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树，你要返回所有从根到叶子节点的路径。 比如说，给你的二叉树是： 1 / \\ 2 4 \\ 8 在这棵二叉树中，从根到叶子节点有两条路径： [ \"1-\u003e2-\u003e8\", \"1-\u003e4\" ] 2 LeetCode 257. 二叉树的所有路径 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p234.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P234. 二叉树中的所有路径","uri":"/posts/p234.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个字符数组和一个非负整数 n。字符数组表示等待 CPU 处理的任务，每个任务用 A 到 Z 中的一个字符表示，并且每个任务都可以在一个时间单位内完成；n 表示冷却时间，即相同任务之间需要间隔至少 n 个时间单位才能再次执行，冷却时间内的每个时间单位，可以选择执行不同的任务或是让 CPU 处于闲置状态。现在你要重新组织任务的执行顺序，并计算出最少需要多少个时间单位才能完成所有任务。","date":"2025-05-05","objectID":"/posts/p235.%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/","tags":["AlgoCasts","LeetCode"],"title":"P235. 任务调度","uri":"/posts/p235.%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个字符数组和一个非负整数 n。字符数组表示等待 CPU 处理的任务，每个任务用 A 到 Z 中的一个字符表示，并且每个任务都可以在一个时间单位内完成；n 表示冷却时间，即相同任务之间需要间隔至少 n 个时间单位才能再次执行，冷却时间内的每个时间单位，可以选择执行不同的任务或是让 CPU 处于闲置状态。 现在你要重新组织任务的执行顺序，并计算出最少需要多少个时间单位才能完成所有任务。 比如说，给你的任务数组是： A, A, A, B, B, B, D 给你的冷却时间是： n = 2 完成所有任务最少需要 8 个时间单位，一种执行序列是： A, B, D, A, B, _, A, B 序列中的 '_' 表示 CPU 处于闲置状态。 因此，对于这个例子，你要返回 8。 2 LeetCode 621. 任务调度器 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p235.%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P235. 任务调度","uri":"/posts/p235.%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，对于一个整数序列，如果从左到右序列中元素值的相对大小交替变化，则把这个序列叫做摆动序列。如果一个序列不是摆动序列，那么总是可以通过删掉部分元素，来得到一个摆动子序列。现在给你一个整数序列，你要计算出最长摆动子序列的长度。","date":"2025-05-05","objectID":"/posts/p231.%E6%9C%80%E9%95%BF%E6%91%86%E5%8A%A8%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/","tags":["AlgoCasts","LeetCode"],"title":"P231. 最长摆动子序列的长度","uri":"/posts/p231.%E6%9C%80%E9%95%BF%E6%91%86%E5%8A%A8%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，对于一个整数序列，如果从左到右序列中元素值的相对大小交替变化，则把这个序列叫做摆动序列。如果一个序列不是摆动序列，那么总是可以通过删掉部分元素，来得到一个摆动子序列。现在给你一个整数序列，你要计算出最长摆动子序列的长度。 注意，单个元素的序列也是摆动序列。 比如说，给你的整数序列是： 1, 4, 2, 8, 0, 2 这个序列是一个摆动序列，直接返回它的长度 6 即可。 如果给你的序列变成： 1, 4, 6, 8, 0, 2 这个序列不是摆动序列，但是删掉 4 和 6 后，可以得到一个最长摆动子序列： 1, 8, 0, 2 因此你要返回的长度就为 4。 2 LeetCode 376. 摆动序列 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p231.%E6%9C%80%E9%95%BF%E6%91%86%E5%8A%A8%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P231. 最长摆动子序列的长度","uri":"/posts/p231.%E6%9C%80%E9%95%BF%E6%91%86%E5%8A%A8%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组，在最多允许修改数组中一个元素的情况下，你要判断是否可以将这个数组变成非减数组。","date":"2025-05-05","objectID":"/posts/p232.%E9%9D%9E%E5%87%8F%E6%95%B0%E7%BB%84/","tags":["AlgoCasts","LeetCode"],"title":"P232. 非减数组","uri":"/posts/p232.%E9%9D%9E%E5%87%8F%E6%95%B0%E7%BB%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组，在最多允许修改数组中一个元素的情况下，你要判断是否可以将这个数组变成非减数组。 非减数组的特征是，对于数组中任意相邻的两个元素，左边的元素一定小于等于右边的元素。 比如说，给你的数组为： 4, 3, 4 你只需要把第一个 4 修改成小于等于 3 的数字，就可以把这个数组变成非减数组，因此返回 true。 再比如说，给你的数组为： 4, 3, 4, 1, 6 对于这个数组，你至少需要修改两个元素，才能将它变成非减数组，因此返回 false。 2 LeetCode 665. 非递减数列 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p232.%E9%9D%9E%E5%87%8F%E6%95%B0%E7%BB%84/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P232. 非减数组","uri":"/posts/p232.%E9%9D%9E%E5%87%8F%E6%95%B0%E7%BB%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组和一个整数 k，你要计算出求和等于 k 的子数组数量。注意，子数组要求是连续的。","date":"2025-05-05","objectID":"/posts/p228.%E6%B1%82%E5%92%8C%E7%AD%89%E4%BA%8Ek%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E9%87%8F/","tags":["AlgoCasts","LeetCode"],"title":"P228. 求和等于 K 的子数组数量","uri":"/posts/p228.%E6%B1%82%E5%92%8C%E7%AD%89%E4%BA%8Ek%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组和一个整数 k，你要计算出求和等于 k 的子数组数量。注意，子数组要求是连续的。 比如说，给你的数组和 k 分别是： [1, 2, 1, -1] k = 3 在给出的数组中，求和等于 3 的子数组有 3 个，分别是： [1, 2] [2, 1] [1, 2, 1, -1] 因此，你要返回满足条件的子数组数量就是 3。 2 LeetCode 560. 和为 K 的子数组 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p228.%E6%B1%82%E5%92%8C%E7%AD%89%E4%BA%8Ek%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E9%87%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P228. 求和等于 K 的子数组数量","uri":"/posts/p228.%E6%B1%82%E5%92%8C%E7%AD%89%E4%BA%8Ek%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树，并且你站在这棵树的右边，你要返回从上到下看到的节点值。","date":"2025-05-05","objectID":"/posts/p229.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/","tags":["AlgoCasts","LeetCode"],"title":"P229. 二叉树的右视图","uri":"/posts/p229.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树，并且你站在这棵树的右边，你要返回从上到下看到的节点值。 比如说，给你的二叉树是： 1 / \\ 2 4 / \\ 6 8 站在这棵二叉树的右边看过来，从上到下看到的数字依次是： [1, 4, 8] 2 LeetCode 199. 二叉树的右视图 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p229.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P229. 二叉树的右视图","uri":"/posts/p229.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组，你要找到这个数组的平衡点并返回它的下标。","date":"2025-05-05","objectID":"/posts/p230.%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E8%A1%A1%E7%82%B9/","tags":["AlgoCasts","LeetCode"],"title":"P230. 寻找数组的平衡点","uri":"/posts/p230.%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E8%A1%A1%E7%82%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组，你要找到这个数组的平衡点并返回它的下标。 数组的平衡点定义为这样一个元素，它左边子数组的元素之和等于它右边子数组的元素之和。如果数组中存在多个平衡点，则返回最左侧平衡点的下标；而如果数组中不存在平衡点，则返回 -1。 比如说，给你的数组是： 1, 4, 2, 8, 1, 6 这个数组的平衡点是数字 8，它左边的元素之和与右边的元素之和都等于 7。因此，你要返回数字 8 对应的下标，也就是 3。 再比如说，给你的数组是： 1, -3, 3 这个数组的平衡点是数字 1。1 左边没有元素，因此把求和结果看作 0。1 右边的两个元素相加也等于 0。因此，你要返回数字 1 对应的下标，也就是 0。 2 LeetCode 724. 寻找数组的中心下标 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p230.%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E8%A1%A1%E7%82%B9/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P230. 寻找数组的平衡点","uri":"/posts/p230.%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E8%A1%A1%E7%82%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉搜索树，以及左右边界 L 和 R，你要将二叉树节点中，大于等于左边界且小于等于右边界的所有节点值都加起来，然后返回这个求和结果。","date":"2025-05-05","objectID":"/posts/p225.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%8C%BA%E9%97%B4%E5%92%8C/","tags":["AlgoCasts","LeetCode"],"title":"P225. 二叉搜索树的区间和","uri":"/posts/p225.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%8C%BA%E9%97%B4%E5%92%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉搜索树，以及左右边界 L 和 R，你要将二叉树节点中，大于等于左边界且小于等于右边界的所有节点值都加起来，然后返回这个求和结果。 注意，可以保证二叉搜索树上不存在重复的节点值。 比如说，给你的二叉搜索树是： 5 / \\ 2 6 / \\ \\ 1 4 8 给你的左右边界 L 和 R 分别是： L = 3 R = 6 在这棵二叉搜索树上，位于 3 和 6 之间的节点值有：4，5，6。它们相加等于 15，因此你要返回 15。 2 LeetCode 938. 二叉搜索树的范围和 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p225.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%8C%BA%E9%97%B4%E5%92%8C/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P225. 二叉搜索树的区间和","uri":"/posts/p225.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%8C%BA%E9%97%B4%E5%92%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个非负整数数组和一个整数 k，你要判断这个数组中是否存在一个长度至少为 2 的子数组，它的元素之和是 k 的整数倍。","date":"2025-05-05","objectID":"/posts/p226.%E5%AD%90%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C%E6%98%AF%E5%90%A6%E4%B8%BAk%E7%9A%84%E6%95%B4%E6%95%B0%E5%80%8D/","tags":["AlgoCasts","LeetCode"],"title":"P226. 子数组求和是否为 K 的整数倍","uri":"/posts/p226.%E5%AD%90%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C%E6%98%AF%E5%90%A6%E4%B8%BAk%E7%9A%84%E6%95%B4%E6%95%B0%E5%80%8D/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个非负整数数组和一个整数 k，你要判断这个数组中是否存在一个长度至少为 2 的子数组，它的元素之和是 k 的整数倍。 注意，子数组要求是连续的。 比如说，给你的数组是： 1, 3, 4, 8, 1 给你的整数 k 是： k = 6 在给出的数组中，存在子数组 [4,8]，它的元素之和等于 12，是 6 的倍数。因此你要返回 true。 2 LeetCode 523. 连续的子数组和 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p226.%E5%AD%90%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C%E6%98%AF%E5%90%A6%E4%B8%BAk%E7%9A%84%E6%95%B4%E6%95%B0%E5%80%8D/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P226. 子数组求和是否为 K 的整数倍","uri":"/posts/p226.%E5%AD%90%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C%E6%98%AF%E5%90%A6%E4%B8%BAk%E7%9A%84%E6%95%B4%E6%95%B0%E5%80%8D/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数 n，1 ~ n 表示一个产品的 n 个版本。其中，从某个版本开始，产品发生了错误。导致从那个版本开始，后面所有版本的产品都有问题。现在给你一个函数 isBadVersion，输入一个版本号，它会告诉你这个版本的产品是否有问题。你要利用这个函数，找到第一个出错的版本。","date":"2025-05-05","objectID":"/posts/p227.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%87%BA%E9%94%99%E7%9A%84%E7%89%88%E6%9C%AC/","tags":["AlgoCasts","LeetCode"],"title":"P227. 第一个出错的版本","uri":"/posts/p227.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%87%BA%E9%94%99%E7%9A%84%E7%89%88%E6%9C%AC/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数 n，1 ~ n 表示一个产品的 n 个版本。其中，从某个版本开始，产品发生了错误。导致从那个版本开始，后面所有版本的产品都有问题。 现在给你一个函数 isBadVersion，输入一个版本号，它会告诉你这个版本的产品是否有问题。你要利用这个函数，找到第一个出错的版本。 比如说，给你的 n 等于 6，也就是说你要在 1 ~ 6 这 6 个版本中，找到第一个出错的版本。 假设第一个出错的版本为 4，那么调用 isBadVersion 会得到： isBadVersion(1) =\u003e false isBadVersion(2) =\u003e false isBadVersion(3) =\u003e false isBadVersion(4) =\u003e true isBadVersion(5) =\u003e true isBadVersion(6) =\u003e true 因此，对于这个例子，你要返回的第一个出错版本就是版本 4。 2 LeetCode 278. 第一个错误的版本 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p227.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%87%BA%E9%94%99%E7%9A%84%E7%89%88%E6%9C%AC/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P227. 第一个出错的版本","uri":"/posts/p227.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%87%BA%E9%94%99%E7%9A%84%E7%89%88%E6%9C%AC/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你要设计一个支持 add 操作和 find 操作的类。其中，add 操作添加一个整数到这个类的内部数据结构；而 find 操作则是检查内部数据结构中是否存在求和等于给定值的两个数。","date":"2025-05-05","objectID":"/posts/p223.%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B1%82%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P223. 设计一个类求和为给定值的两个数","uri":"/posts/p223.%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B1%82%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你要设计一个支持 add 操作和 find 操作的类。其中，add 操作添加一个整数到这个类的内部数据结构；而 find 操作则是检查内部数据结构中是否存在求和等于给定值的两个数。 比如说，一开始添加 3 个数字： add(1) add(2) add(3) 你可以用 find 检查内部数据结构中是否存在两个数字相加等于 4 或 6： find(4) =\u003e true find(6) =\u003e false 2 LeetCode 170. 两数之和 III - 数据结构设计 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p223.%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B1%82%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P223. 设计一个类求和为给定值的两个数","uri":"/posts/p223.%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B1%82%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数，你要从数轴上的位置 0 移动到那个数字。在第 n 次移动中，你可以选择向左走 n 步，或者向右走 n 步。其中，n 从 1 开始。你要计算出，到达终点所需要的最少移动次数。","date":"2025-05-05","objectID":"/posts/p224.%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P224. 到达终点需要的最少移动次数","uri":"/posts/p224.%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数，你要从数轴上的位置 0 移动到那个数字。在第 n 次移动中，你可以选择向左走 n 步，或者向右走 n 步。其中，n 从 1 开始。你要计算出，到达终点所需要的最少移动次数。 比如说，给你的数字是 3，你从位置 0 开始： 1. 第一次向右走 1 步（到达 1） 2. 第二次向右走 2 步（到达 3） 因此，最少的移动次数是 2。 再比如说，给你的数字为 4，你从位置 0 开始： 1. 第一次向左走 1 步（到达 -1） 2. 第二次向右走 2 步（到达 1） 3. 第三次向右走 3 步（到达 4） 因此，最少的移动次数是 3。 2 LeetCode 754. 到达终点数字 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p224.%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P224. 到达终点需要的最少移动次数","uri":"/posts/p224.%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个字符串 s，你要计算出将 s 分割成回文子串所需要的最少分割次数。","date":"2025-05-05","objectID":"/posts/p220.%E5%9B%9E%E6%96%87%E5%88%86%E5%89%B2%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%86%E5%89%B2%E6%AC%A1%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P220. 回文分割需要的最少分割次数","uri":"/posts/p220.%E5%9B%9E%E6%96%87%E5%88%86%E5%89%B2%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%86%E5%89%B2%E6%AC%A1%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个字符串 s，你要计算出将 s 分割成回文子串所需要的最少分割次数。 比如说，给你的字符串是： \"abc\" 那你至少要分割两次，得到回文子串： [\"a\", \"b\", \"c\"] 因此你要返回的最少分割次数是 2。 再比如说，给你的字符串是： \"aab\" 那你只需要分割一次，得到回文子串： [\"aa\", \"b\"] 因此你要返回的最少分割次数是 1。 2 LeetCode 132. 分割回文串 II 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p220.%E5%9B%9E%E6%96%87%E5%88%86%E5%89%B2%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%86%E5%89%B2%E6%AC%A1%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P220. 回文分割需要的最少分割次数","uri":"/posts/p220.%E5%9B%9E%E6%96%87%E5%88%86%E5%89%B2%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%86%E5%89%B2%E6%AC%A1%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两个字符串 A 和 B，你要判断字符串 A 是否可以通过将左边的若干字符旋转到右边，来得到字符串 B。如果可以就返回 true，否则返回 false。","date":"2025-05-05","objectID":"/posts/p221.%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","tags":["AlgoCasts","LeetCode"],"title":"P221. 旋转字符串","uri":"/posts/p221.%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两个字符串 A 和 B，你要判断字符串 A 是否可以通过将左边的若干字符旋转到右边，来得到字符串 B。如果可以就返回 true，否则返回 false。 比如说，给你的两个字符串是： A = \"abcde\" B = \"cdeab\" 你可以先将 \"abcde\" 最左边的 a 旋转到右边，然后再把 b 旋转到右边，就可以把字符串 A 变成字符串 B。因此返回 true。 再比如说，给你的两个字符串是： A = \"abcde\" B = \"abced\" 那么 A 就无法通过将左边的若干字符旋转到右边，来得到字符串 B。因此你要返回 false。 2 LeetCode 796. 旋转字符串 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p221.%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P221. 旋转字符串","uri":"/posts/p221.%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个不为空的整数数组，这个数组中有一个整数只出现了一次，其它的整数都出现了三次，你要找出这个只出现一次的整数。","date":"2025-05-05","objectID":"/posts/p222.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/","tags":["AlgoCasts","LeetCode"],"title":"P222. 只出现一次的数字","uri":"/posts/p222.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个不为空的整数数组，这个数组中有一个整数只出现了一次，其它的整数都出现了三次，你要找出这个只出现一次的整数。 注意，这个题目要求你的解法是线性时间复杂度以及常量空间复杂度。 比如说，给你的整数数组是： 3, 3, 2, 3, 2, 6, 2 在这个数组中，3 和 2 都出现了三次，而 6 只出现一次，因此你要返回 6。 2 LeetCode 137. 只出现一次的数字 II 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p222.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P222. 只出现一次的数字","uri":"/posts/p222.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个编码后的字符串 s，s 中只包含数字、字母以及方括号。其中，数字只能出现在方括号前面，表示方括号内字符串的重复次数。你要将 s 解码，并返回解码后的字符串。","date":"2025-05-05","objectID":"/posts/p218.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/","tags":["AlgoCasts","LeetCode"],"title":"P218. 字符串解码","uri":"/posts/p218.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个编码后的字符串 s，s 中只包含数字、字母以及方括号。其中，数字只能出现在方括号前面，表示方括号内字符串的重复次数。你要将 s 解码，并返回解码后的字符串。 注意，给你的字符串 s 一定可以进行有效解码，并且解码后的字符串只包含字母，不包含数字和方括号。 比如说，编码后的字符串 s 是： s = \"d2[a2[b]]e\" 其中，数字和方括号的作用是对子串进行重复。s 解码后的字符串是： \"dabbabbe\" 2 LeetCode 394. 字符串解码 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p218.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P218. 字符串解码","uri":"/posts/p218.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个非负整数 k，你要返回帕斯卡三角形的第 k 行。其中，k 从 0 开始算起。","date":"2025-05-05","objectID":"/posts/p219.%E5%B8%95%E6%96%AF%E5%8D%A1%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E7%AC%ACk%E8%A1%8C/","tags":["AlgoCasts","LeetCode"],"title":"P219. 帕斯卡三角形的第 K 行","uri":"/posts/p219.%E5%B8%95%E6%96%AF%E5%8D%A1%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E7%AC%ACk%E8%A1%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个非负整数 k，你要返回帕斯卡三角形的第 k 行。其中，k 从 0 开始算起。 帕斯卡三角形又称为杨辉三角形，它的特点是左右两条边上的数字都为 1，其它位置的数字等于左上方与右上方的两个数字之和。 以下是帕斯卡三角形的前 5 行： [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ... 比如说 k = 0，你要返回： [1] 再比如说 k = 3，你要返回： [1, 3, 3, 1] 2 LeetCode 119. 杨辉三角 II 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p219.%E5%B8%95%E6%96%AF%E5%8D%A1%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E7%AC%ACk%E8%A1%8C/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P219. 帕斯卡三角形的第 K 行","uri":"/posts/p219.%E5%B8%95%E6%96%AF%E5%8D%A1%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E7%AC%ACk%E8%A1%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个二维整数矩阵，你要设计一个类，可以高效地查询任意子矩阵内的数字和。其中，子矩阵由它左上角坐标 (row1, col1) 和右下角坐标 (row2, col2) 所确定。","date":"2025-05-05","objectID":"/posts/p215.%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9F%A9%E9%98%B5%E7%9A%84%E9%83%A8%E5%88%86%E5%92%8C%E6%9F%A5%E8%AF%A2/","tags":["AlgoCasts","LeetCode"],"title":"P215. 不可变矩阵的部分和查询","uri":"/posts/p215.%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9F%A9%E9%98%B5%E7%9A%84%E9%83%A8%E5%88%86%E5%92%8C%E6%9F%A5%E8%AF%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个二维整数矩阵，你要设计一个类，可以高效地查询任意子矩阵内的数字和。其中，子矩阵由它左上角坐标 (row1, col1) 和右下角坐标 (row2, col2) 所确定。 注意，你可以假设矩阵一旦给你，就不会发生改变。并且给你的左上角坐标和右下角坐标一定是合法的。另外，求子矩阵内数字和的函数会被频繁调用。 比如说，给你的矩阵 a 是： 1, 0, 2, 4 4, 2, 3, 7 3, 1, 4, 2 0, 4, 1, 4 假设子矩阵求和函数是 f，那么 f(1, 1, 2, 2) 表示的就是左上角坐标为 (1, 1)，右下角坐标为 (2, 2) 所形成的子矩阵元素和。 这个子矩阵包含的数字是：2, 3, 1, 4，因此有： f(1, 1, 2, 2) = 2+3+1+4 = 10 2 LeetCode 304. 二维区域和检索 - 矩阵不可变 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p215.%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9F%A9%E9%98%B5%E7%9A%84%E9%83%A8%E5%88%86%E5%92%8C%E6%9F%A5%E8%AF%A2/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P215. 不可变矩阵的部分和查询","uri":"/posts/p215.%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9F%A9%E9%98%B5%E7%9A%84%E9%83%A8%E5%88%86%E5%92%8C%E6%9F%A5%E8%AF%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两个正整数 n 和 k，你要从 1 ~ n 中取 k 个数字，并返回所有可能的数字组合。","date":"2025-05-05","objectID":"/posts/p216.%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88/","tags":["AlgoCasts","LeetCode"],"title":"P216. 数字组合","uri":"/posts/p216.%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两个正整数 n 和 k，你要从 1 ~ n 中取 k 个数字，并返回所有可能的数字组合。 比如说，给你的 n 和 k 分别是： n = 4 k = 2 你要从 1 ~ 4 中取 2 个数字，一共有 6 种可能的组合： [1, 2] [1, 3] [1, 4] [2, 3] [2, 4] [3, 4] 2 LeetCode 77. 组合 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p216.%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P216. 数字组合","uri":"/posts/p216.%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组和一个数字，你要就地（in place）移除数组中等于给定数字的所有元素。然后返回移除指定数字后的子数组长度。","date":"2025-05-05","objectID":"/posts/p217.%E7%A7%BB%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8C%87%E5%AE%9A%E6%95%B0%E5%AD%97/","tags":["AlgoCasts","LeetCode"],"title":"P217. 移除数组中指定数字","uri":"/posts/p217.%E7%A7%BB%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8C%87%E5%AE%9A%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组和一个数字，你要就地（in place）移除数组中等于给定数字的所有元素。然后返回移除指定数字后的子数组长度。 比如说，给你的整数数组是： [1, 4, 2, 0, 2, 8] 你要移除的数字是 2。 在这个数组中就地移除数字 2 后，得到： [1, 4, 0, 8, _, _] 因此，你要返回这个子数组的长度 4。 原数组的长度是 6，所以子数组 1, 4, 0, 8 后面实际上还有两个位置。但这两个位置上放什么数字都无所谓。因为根据返回的长度 4，就可以确定目标子数组的边界。 2 LeetCode 27. 移除元素 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p217.%E7%A7%BB%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8C%87%E5%AE%9A%E6%95%B0%E5%AD%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P217. 移除数组中指定数字","uri":"/posts/p217.%E7%A7%BB%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8C%87%E5%AE%9A%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两个用字符串表示的二进制数字，你要返回它们的和，并且和的形式同样为二进制字符串。","date":"2025-05-05","objectID":"/posts/p213.%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%82%E5%92%8C/","tags":["AlgoCasts","LeetCode"],"title":"P213. 二进制字符串求和","uri":"/posts/p213.%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%82%E5%92%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两个用字符串表示的二进制数字，你要返回它们的和，并且和的形式同样为二进制字符串。 其中，给你的两个字符串都不为空，并且只包含 0/1 字符。 比如说，给你的两个字符串是： \"1101\" \"111\" 它们求和后的二进制字符串是 \"10100\"。 2 LeetCode 67. 二进制求和 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p213.%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%82%E5%92%8C/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P213. 二进制字符串求和","uri":"/posts/p213.%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%82%E5%92%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个不为空的整数数组，你要设计一个类，可以高效地查询数组中下标从 i 到 j 的区间和。","date":"2025-05-05","objectID":"/posts/p214.%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E9%97%B4%E5%92%8C%E6%9F%A5%E8%AF%A2/","tags":["AlgoCasts","LeetCode"],"title":"P214. 不可变数组的区间和查询","uri":"/posts/p214.%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E9%97%B4%E5%92%8C%E6%9F%A5%E8%AF%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个不为空的整数数组，你要设计一个类，可以高效地查询数组中下标从 i 到 j 的区间和。 注意，你可以假设数组一旦给你，就不会发生改变。并且给你的 i 和 j 一定是合法的下标，总是可以求出有效的区间和。另外，求区间和的函数会被频繁调用。 比如说，给你的数组 a 是： -1, 0, 4, -2, 8 假设计算区间和的函数是 f，那么有： f(0, 1) = -1 + 0 = -1 f(1, 3) = 0 + 4 + (-2) = 2 2 LeetCode 303. 区域和检索 - 数组不可变 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p214.%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E9%97%B4%E5%92%8C%E6%9F%A5%E8%AF%A2/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P214. 不可变数组的区间和查询","uri":"/posts/p214.%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E9%97%B4%E5%92%8C%E6%9F%A5%E8%AF%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个单链表，你要以每两个相邻的节点为一组，交换两个节点的位置，然后返回处理后的链表。","date":"2025-05-05","objectID":"/posts/p210.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","tags":["AlgoCasts","LeetCode"],"title":"P210. 两两交换链表中的节点","uri":"/posts/p210.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个单链表，你要以每两个相邻的节点为一组，交换两个节点的位置，然后返回处理后的链表。 注意，不允许修改节点中的数值，只能通过修改节点的 next 指针来改变链表结构。 比如说，给你的链表是： 1 -\u003e 2 -\u003e 3 -\u003e 4 两两交换相邻的节点后，得到： 2 -\u003e 1 -\u003e 4 -\u003e 3 再比如说，给你的链表是： 1 -\u003e 2 -\u003e 3 -\u003e 4 -\u003e 5 两两交换相邻的节点后，得到： 2 -\u003e 1 -\u003e 4 -\u003e 3 -\u003e 5 2 LeetCode 24. 两两交换链表中的节点 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p210.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P210. 两两交换链表中的节点","uri":"/posts/p210.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你要用红/蓝/绿三种不同的颜色去粉刷 n 个房子，一个房子只能刷成一种颜色，并且相邻的房子不能粉刷相同的颜色。现在给你一个 nx3 的费用矩阵，表示每个房子刷成红/蓝/绿 3 种颜色对应的费用。你要计算出，粉刷这 n 个房子的最小费用。注意，矩阵中的费用都为正整数。","date":"2025-05-05","objectID":"/posts/p211.%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/","tags":["AlgoCasts","LeetCode"],"title":"P211. 粉刷房子","uri":"/posts/p211.%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你要用红/蓝/绿三种不同的颜色去粉刷 n 个房子，一个房子只能刷成一种颜色，并且相邻的房子不能粉刷相同的颜色。 现在给你一个 nx3 的费用矩阵，表示每个房子刷成红/蓝/绿 3 种颜色对应的费用。你要计算出，粉刷这 n 个房子的最小费用。注意，矩阵中的费用都为正整数。 比如说，给你的费用矩阵 a 是： 8 2 4 5 7 3 9 1 6 4 1 9 对于这个例子，你要将 0 号房子刷成蓝色，将 1 号房子刷成绿色，将 2 号房子刷成蓝色，将 3 号房子刷成红色。 最后得到的最小费用是 2 + 3 + 1 + 4 = 10。 2 LeetCode 256. 粉刷房子 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p211.%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P211. 粉刷房子","uri":"/posts/p211.%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你要用 k 种不同的颜色去粉刷 n 个房子，一个房子只能刷成一种颜色，并且相邻的房子不能粉刷相同的颜色。现在给你一个 nxk 的费用矩阵，表示每个房子刷成 k 种颜色对应的费用。你要计算出，粉刷这 n 个房子的最小费用。注意，矩阵中的费用都为正整数。","date":"2025-05-05","objectID":"/posts/p212.k%E7%A7%8D%E9%A2%9C%E8%89%B2%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/","tags":["AlgoCasts","LeetCode"],"title":"P212. K 种颜色粉刷房子","uri":"/posts/p212.k%E7%A7%8D%E9%A2%9C%E8%89%B2%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你要用 k 种不同的颜色去粉刷 n 个房子，一个房子只能刷成一种颜色，并且相邻的房子不能粉刷相同的颜色。 现在给你一个 nxk 的费用矩阵，表示每个房子刷成 k 种颜色对应的费用。你要计算出，粉刷这 n 个房子的最小费用。注意，矩阵中的费用都为正整数。 比如说，给你的费用矩阵 a 是： 8 2 4 5 7 3 9 1 6 4 1 9 对于这个例子，你要将 0 号房子刷成 1 号颜色，将 1 号房子刷成 2 号颜色，将 2 号房子刷成 1 号颜色，将 3 号房子刷成 0 号颜色。 最后得到的最小费用是 2 + 3 + 1 + 4 = 10。 2 LeetCode 265. 粉刷房子 II 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p212.k%E7%A7%8D%E9%A2%9C%E8%89%B2%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P212. K 种颜色粉刷房子","uri":"/posts/p212.k%E7%A7%8D%E9%A2%9C%E8%89%B2%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组，你要判断数组中是否包含重复元素。如果数组中包含重复元素就返回 true，否则返回 false。","date":"2025-05-05","objectID":"/posts/p207.%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/","tags":["AlgoCasts","LeetCode"],"title":"P207. 数组中是否包含重复元素","uri":"/posts/p207.%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组，你要判断数组中是否包含重复元素。如果数组中包含重复元素就返回 true，否则返回 false。 比如说，给你的数组是： 1, 2, 4, 2 这个数组中有两个 2，包含重复元素，返回 true。 再比如说，给你的数组是： 4, 1, 2 在这个数组中，每个数字都只出现了一次，不存在重复元素，因此返回 false。 2 LeetCode 217. 存在重复元素 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p207.%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P207. 数组中是否包含重复元素","uri":"/posts/p207.%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个数字三角形，你要找到从上到下路径和最小的一条路径，然后返回这个最小的路径和。","date":"2025-05-05","objectID":"/posts/p208.%E4%B8%89%E8%A7%92%E5%BD%A2%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","tags":["AlgoCasts","LeetCode"],"title":"P208. 三角形中的最小路径和","uri":"/posts/p208.%E4%B8%89%E8%A7%92%E5%BD%A2%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个数字三角形，你要找到从上到下路径和最小的一条路径，然后返回这个最小的路径和。 注意，每一次你只能移动到下一行相邻的两个数字上。 比如说，给你的数字三角形 a 是： [ [1], [2,3], [4,5,1], [6,1,1,8] ] 在这个三角形中，路径和最小的路径是 [1,3,1,1]。它的和等于 6。因此，你要返回的最小路径和就是 6。 2 LeetCode 120. 三角形最小路径和 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p208.%E4%B8%89%E8%A7%92%E5%BD%A2%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P208. 三角形中的最小路径和","uri":"/posts/p208.%E4%B8%89%E8%A7%92%E5%BD%A2%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两个字符串 s 和 t，你要写函数判断 t 是否为 s 的一个变位词。","date":"2025-05-05","objectID":"/posts/p209.%E5%8F%98%E4%BD%8D%E8%AF%8D%E6%A0%A1%E9%AA%8C/","tags":["AlgoCasts","LeetCode"],"title":"P209. 变位词校验","uri":"/posts/p209.%E5%8F%98%E4%BD%8D%E8%AF%8D%E6%A0%A1%E9%AA%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两个字符串 s 和 t，你要写函数判断 t 是否为 s 的一个变位词。 其中，字符串只由小写字母组成。变位词指的是使用相同字母以不同顺序构成的单词。 比如说，给你的字符串 s 和 t 是： s = \"eat\" t = \"tea\" 这两个字符串都是由 a/e/t 这三个字母构成，因此 t 是 s 的一个变位词。 如果 s 和 t 改成： s = \"eat\" t = \"ten\" \"ten\" 中的字符 n 不存在于字符串 s 中。因此，它不是 s 的一个变位词。 2 LeetCode 242. 有效的字母异位词 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p209.%E5%8F%98%E4%BD%8D%E8%AF%8D%E6%A0%A1%E9%AA%8C/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P209. 变位词校验","uri":"/posts/p209.%E5%8F%98%E4%BD%8D%E8%AF%8D%E6%A0%A1%E9%AA%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数 n，你要用 1 到 n 这 n 个数字去生成所有可能的二叉搜索树，然后将它们返回。","date":"2025-05-05","objectID":"/posts/p205.%E7%94%A81~n%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","tags":["AlgoCasts","LeetCode"],"title":"P205. 用 1~n 生成二叉搜索树","uri":"/posts/p205.%E7%94%A81~n%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数 n，你要用 1 到 n 这 n 个数字去生成所有可能的二叉搜索树，然后将它们返回。 比如说，给你的 n 是 3，1/2/3 这 3 个数字总共可以构成 5 棵不同的二叉搜索树。如下所示： 1 1 2 3 3 \\ \\ / \\ / / 2 3 1 3 1 2 \\ / \\ / 3 2 2 1 因此，你要返回这 5 棵二叉搜索树。 2 LeetCode 95. 不同的二叉搜索树 II 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p205.%E7%94%A81~n%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P205. 用 1~n 生成二叉搜索树","uri":"/posts/p205.%E7%94%A81~n%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你 3 个字符串 s1, s2 和 s3，你要判断 s1 和 s2 是否可以交错合并形成 s3。","date":"2025-05-05","objectID":"/posts/p206.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BA%A4%E9%94%99%E5%90%88%E5%B9%B6/","tags":["AlgoCasts","LeetCode"],"title":"P206. 字符串的交错合并","uri":"/posts/p206.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BA%A4%E9%94%99%E5%90%88%E5%B9%B6/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你 3 个字符串 s1, s2 和 s3，你要判断 s1 和 s2 是否可以交错合并形成 s3。 比如说，给你的 s1, s2, s3 分别是： s1 = abd s2 = bcca s3 = abcbcad s3 整个字符串，是由 s1 和 s2 上的所有字符，按从左到右的顺序交错合并而成。因此，对于这个例子我们要返回 true。 如果把 s3 首尾两个字符对调一下： s3 = dbcbcaa 那么 s3 就无法由 s1 和 s2 交错合并形成，返回 false。 2 LeetCode 97. 交错字符串 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p206.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BA%A4%E9%94%99%E5%90%88%E5%B9%B6/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P206. 字符串的交错合并","uri":"/posts/p206.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BA%A4%E9%94%99%E5%90%88%E5%B9%B6/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个正整数，你要将它转换成 Excel 表格中的列标题。","date":"2025-05-05","objectID":"/posts/p202.excel%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%88%97%E6%A0%87%E9%A2%98/","tags":["AlgoCasts","LeetCode"],"title":"P202. Excel 表格的列标题","uri":"/posts/p202.excel%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%88%97%E6%A0%87%E9%A2%98/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个正整数，你要将它转换成 Excel 表格中的列标题。 // Excel 表格中，列编号与列标题的对应关系 1 -\u003e A 2 -\u003e B ... 26 -\u003e Z 27 -\u003e AA 28 -\u003e AB ... 比如说，给你的正整数是 1，你要返回的列标题是字符串 A： 1 -\u003e A 再比如说，给你的正整数是 28，你要返回的列标题是字符串 AB： 28 -\u003e AB 2 LeetCode 168. Excel 表列名称 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p202.excel%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%88%97%E6%A0%87%E9%A2%98/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P202. Excel 表格的列标题","uri":"/posts/p202.excel%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%88%97%E6%A0%87%E9%A2%98/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个数组，数组中的元素都是非负整数。你要重新排列这些整数，使得它们拼接后的数字最大，并返回这个数字。由于拼接后的数字可能非常大，因此结果以字符串的形式返回。","date":"2025-05-05","objectID":"/posts/p203.%E6%8B%BC%E6%8E%A5%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/","tags":["AlgoCasts","LeetCode"],"title":"P203. 拼接的最大数字","uri":"/posts/p203.%E6%8B%BC%E6%8E%A5%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个数组，数组中的元素都是非负整数。你要重新排列这些整数，使得它们拼接后的数字最大，并返回这个数字。由于拼接后的数字可能非常大，因此结果以字符串的形式返回。 比如说，给你的非负整数数组是： 12, 8 数组中有两个元素，可以拼接成 \"128\" 或是 \"812\"。因此，拼接成的最大数字就是 \"812\"。注意，结果是一个字符串。 再比如说，给你的数组是： 3, 31, 36, 4, 8 这个数组可以拼接成的最大数字是 \"8436331\"。 2 LeetCode 179. 最大数 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p203.%E6%8B%BC%E6%8E%A5%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P203. 拼接的最大数字","uri":"/posts/p203.%E6%8B%BC%E6%8E%A5%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个 32 位整数，你要翻转它的二进制位，然后将翻转二进制位后的整数返回。","date":"2025-05-05","objectID":"/posts/p204.%E7%BF%BB%E8%BD%AC%E6%95%B4%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/","tags":["AlgoCasts","LeetCode"],"title":"P204. 翻转整数的二进制位","uri":"/posts/p204.%E7%BF%BB%E8%BD%AC%E6%95%B4%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个 32 位整数，你要翻转它的二进制位，然后将翻转二进制位后的整数返回。 比如说，给你的整数是 32，它的二进制如下： 00000000000000000000000000100000 将 32 的二进制表示左右翻转，得到： 00000100000000000000000000000000 这个二进制表示的数字是 67108864，因此你要返回这个整数。 2 LeetCode 190. 颠倒二进制位 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p204.%E7%BF%BB%E8%BD%AC%E6%95%B4%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P204. 翻转整数的二进制位","uri":"/posts/p204.%E7%BF%BB%E8%BD%AC%E6%95%B4%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个没有重叠的区间序列，每个区间用一个开始下标和一个结束下标来表示，并且给你的区间序列已经按开始下标从小到大排序。现在给你一个新区间，你要把它插入到这个区间序列，使得区间序列保持有序并且不重叠，必要时可以进行区间合并。","date":"2025-05-05","objectID":"/posts/p200.%E5%8C%BA%E9%97%B4%E6%8F%92%E5%85%A5/","tags":["AlgoCasts","LeetCode"],"title":"P200. 区间插入","uri":"/posts/p200.%E5%8C%BA%E9%97%B4%E6%8F%92%E5%85%A5/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个没有重叠的区间序列，每个区间用一个开始下标和一个结束下标来表示，并且给你的区间序列已经按开始下标从小到大排序。现在给你一个新区间，你要把它插入到这个区间序列，使得区间序列保持有序并且不重叠，必要时可以进行区间合并。 比如说，给你的区间序列是： [1,2], [3,4], [5,7], [8,9] 要插入的区间为： [4,6] 区间 [4,6] 和区间 [3,4]、[5,7] 有重叠。这三个重叠的区间合并后，得到区间： [3,7] 因此，插入新区间后，得到的区间序列是： [1,2], [3,7], [8,9] 2 LeetCode 57. 插入区间 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p200.%E5%8C%BA%E9%97%B4%E6%8F%92%E5%85%A5/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P200. 区间插入","uri":"/posts/p200.%E5%8C%BA%E9%97%B4%E6%8F%92%E5%85%A5/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，n 个小孩站成一条直线，每个小孩都有一个对应的评分。你要根据小孩的评分给他们发糖果，要求每个小孩至少要有一个糖果，并且评分较高的小孩要比相邻的小孩分到更多糖果。你要计算出，至少需要准备多少颗糖果，才能按要求完成分配。","date":"2025-05-05","objectID":"/posts/p201.%E5%88%86%E7%B3%96%E6%9E%9C/","tags":["AlgoCasts","LeetCode"],"title":"P201. 分糖果","uri":"/posts/p201.%E5%88%86%E7%B3%96%E6%9E%9C/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，n 个小孩站成一条直线，每个小孩都有一个对应的评分。你要根据小孩的评分给他们发糖果，要求每个小孩至少要有一个糖果，并且评分较高的小孩要比相邻的小孩分到更多糖果。你要计算出，至少需要准备多少颗糖果，才能按要求完成分配。 比如说，给你的小孩评分数组是： [3, 3, 1, 6, 4, 3] 你最少要给这 6 个小孩分配的糖果数量是： [1, 2, 1, 3, 2, 1] 按照这种分配方法，就可以达到题目要求。因此最少要准备的糖果数量就是这个数组的和，也就是 10。 2 LeetCode 135. 分发糖果 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p201.%E5%88%86%E7%B3%96%E6%9E%9C/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P201. 分糖果","uri":"/posts/p201.%E5%88%86%E7%B3%96%E6%9E%9C/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个 m x n 的矩阵，矩阵中的每一行都从左向右递增，每一列都从上到下递增。你要找出矩阵中第 K 小的元素。","date":"2025-05-05","objectID":"/posts/p197.%E8%A1%8C%E5%88%97%E9%80%92%E5%A2%9E%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/","tags":["AlgoCasts","LeetCode"],"title":"P197. 行列递增矩阵中第 K 小的元素","uri":"/posts/p197.%E8%A1%8C%E5%88%97%E9%80%92%E5%A2%9E%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个 m x n 的矩阵，矩阵中的每一行都从左向右递增，每一列都从上到下递增。你要找出矩阵中第 K 小的元素。 注意，题目给你的 K 总是有效的。 比如说，给你的矩阵是： [ [1, 5, 7], [2, 5, 8] ] 给你的 K 等于 4： K = 4 在这个矩阵中，第 4 小的数字是 5，因此返回 5。 2 LeetCode 378. 有序矩阵中第 K 小的元素 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p197.%E8%A1%8C%E5%88%97%E9%80%92%E5%A2%9E%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P197. 行列递增矩阵中第 K 小的元素","uri":"/posts/p197.%E8%A1%8C%E5%88%97%E9%80%92%E5%A2%9E%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个 Excel 表格的列标题，你要返回它对应的列编号。","date":"2025-05-05","objectID":"/posts/p198.excel%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%88%97%E7%BC%96%E5%8F%B7/","tags":["AlgoCasts","LeetCode"],"title":"P198. Excel 表格的列编号","uri":"/posts/p198.excel%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%88%97%E7%BC%96%E5%8F%B7/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个 Excel 表格的列标题，你要返回它对应的列编号。 注意，题目给出的列标题总是有效的。 // Excel 表格中，列标题与列编号的对应关系 A -\u003e 1 B -\u003e 2 ... Z -\u003e 26 AA -\u003e 27 AB -\u003e 28 ... 比如说，给你的列标题是 A，你要返回的对应编号是 1： A -\u003e 1 再比如说，给你的列标题是 AB，你要返回的编号是 28： AB -\u003e 28 2 LeetCode 171. Excel 表列序号 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p198.excel%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%88%97%E7%BC%96%E5%8F%B7/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P198. Excel 表格的列编号","uri":"/posts/p198.excel%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%88%97%E7%BC%96%E5%8F%B7/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两个递增的整数数组 nums1 和 nums2，以及一个整数 K。分别从 nums1 和 nums2 各取一个数字，可以构成一个数字对。你要找出 nums1 和 nums2 可以构成的所有数字对中，和最小的 K 对数字。","date":"2025-05-05","objectID":"/posts/p199.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97/","tags":["AlgoCasts","LeetCode"],"title":"P199. 查找和最小的 K 对数字","uri":"/posts/p199.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两个递增的整数数组 nums1 和 nums2，以及一个整数 K。分别从 nums1 和 nums2 各取一个数字，可以构成一个数字对。你要找出 nums1 和 nums2 可以构成的所有数字对中，和最小的 K 对数字。 比如说，给你的两个数组和 K 分别是： nums1 = [1, 5, 9] nums2 = [2, 5, 8] K = 4 这两个递增数组构成的所有数字对中，和最小的 4 对数字是： [1, 2] [1, 5] [5, 2] [1, 8] 2 LeetCode 373. 查找和最小的 K 对数字 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p199.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P199. 查找和最小的 K 对数字","uri":"/posts/p199.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个不为空的数组，它表示一个非负整数。数组中的每个数字都位于 0~9 之间，代表整个非负整数上的一位。你要将这个由数组表示的非负整数加 1，然后返回。","date":"2025-05-05","objectID":"/posts/p194.%E6%95%B0%E7%BB%84%E5%8A%A0%E4%B8%80/","tags":["AlgoCasts","LeetCode"],"title":"P194. 数组加一","uri":"/posts/p194.%E6%95%B0%E7%BB%84%E5%8A%A0%E4%B8%80/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个不为空的数组，它表示一个非负整数。数组中的每个数字都位于 0~9 之间，代表整个非负整数上的一位。你要将这个由数组表示的非负整数加 1，然后返回。 比如说，给你的数组是： 1, 2, 4 它表示整数 124，加 1 等于 125，于是你要返回数组： 1, 2, 5 2 LeetCode 66. 加一 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p194.%E6%95%B0%E7%BB%84%E5%8A%A0%E4%B8%80/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P194. 数组加一","uri":"/posts/p194.%E6%95%B0%E7%BB%84%E5%8A%A0%E4%B8%80/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个不为空的单链表，它表示一个非负整数。链表中的每个节点值都位于 0~9 之间，代表整个非负整数中的一位。你要将这个非负整数加 1，然后返回结果链表。","date":"2025-05-05","objectID":"/posts/p195.%E9%93%BE%E8%A1%A8%E5%8A%A0%E4%B8%80/","tags":["AlgoCasts","LeetCode"],"title":"P195. 链表加一","uri":"/posts/p195.%E9%93%BE%E8%A1%A8%E5%8A%A0%E4%B8%80/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个不为空的单链表，它表示一个非负整数。链表中的每个节点值都位于 0~9 之间，代表整个非负整数中的一位。你要将这个非负整数加 1，然后返回结果链表。 比如说，给你的链表是： 1 -\u003e 2 -\u003e 4 它表示整数 124，加 1 等于 125，于是你要返回链表： 1 -\u003e 2 -\u003e 5 2 LeetCode 369. 给单链表加一 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p195.%E9%93%BE%E8%A1%A8%E5%8A%A0%E4%B8%80/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P195. 链表加一","uri":"/posts/p195.%E9%93%BE%E8%A1%A8%E5%8A%A0%E4%B8%80/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，在一条环形公路上有 n 个加油站，编号是 0 ~ n-1。第 i 个加油站提供的油量是 gas[i]，从第 i 个加油站开到第 i+1 个加油站需要的油量是 cost[i]。给你一辆油箱容量无限大的汽车，并且一开始油箱为空。你要计算出，是否可以从某个加油站开始，顺时针绕环形公路一周。如果可以，返回出发加油站的编号；否则，返回 -1。","date":"2025-05-05","objectID":"/posts/p196.%E5%8A%A0%E6%B2%B9%E7%AB%99/","tags":["AlgoCasts","LeetCode"],"title":"P196. 加油站","uri":"/posts/p196.%E5%8A%A0%E6%B2%B9%E7%AB%99/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，在一条环形公路上有 n 个加油站，编号是 0 ~ n-1。第 i 个加油站提供的油量是 gas[i]，从第 i 个加油站开到第 i+1 个加油站需要的油量是 cost[i]。 给你一辆油箱容量无限大的汽车，并且一开始油箱为空。你要计算出，是否可以从某个加油站开始，顺时针绕环形公路一周。如果可以，返回出发加油站的编号；否则，返回 -1。 注意，给你的 gas 数组和 cost 数组都不为空，并且长度相同。另外，这个题目保证，要么不存在绕行公路一周的方案，要么就只有唯一一个出发点，可以绕行公路一周。 比如说，给你的 gas 数组和 cost 数组是： gas: [1, 2, 4, 8] cost: [4, 8, 1, 2] 只要从编号为 2 的加油站开始，就可以顺利绕行公路一周： // 到达 3 号加油站时的油量 0 + 4 - 1 = 3 // 到达 0 号加油站时的油量 3 + 8 - 2 = 9 // 到达 1 号加油站时的油量 9 + 1 - 4 = 6 // 回到 2 号加油站时的油量 6 + 2 - 8 = 0 这样就从 2 号加油站出发，顺利绕行一周，回到 2 号加油站。因此你要返回的出发加油站编号就是 2。 2 LeetCode 134. 加油站 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p196.%E5%8A%A0%E6%B2%B9%E7%AB%99/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P196. 加油站","uri":"/posts/p196.%E5%8A%A0%E6%B2%B9%E7%AB%99/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你要设计一个增加版的集合（Collection），它要支持以下操作：插入元素（insert）、删除元素（remove）以及随机获取元素（getRandom）。","date":"2025-05-05","objectID":"/posts/p192.%E6%94%AF%E6%8C%81%E9%9A%8F%E6%9C%BA%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E9%9B%86%E5%90%88%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D/","tags":["AlgoCasts","LeetCode"],"title":"P192. 支持随机获取元素的集合（允许重复）","uri":"/posts/p192.%E6%94%AF%E6%8C%81%E9%9A%8F%E6%9C%BA%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E9%9B%86%E5%90%88%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你要设计一个增加版的集合（Collection），它要支持以下操作：插入元素（insert）、删除元素（remove）以及随机获取元素（getRandom）。 注意，这 3 个操作的平均时间复杂度都要求是 O(1)。另外，这个集合中允许存储重复元素，一个元素被随机返回的概率与它在集合中的数量正相关。 以下是这个集合的使用示例： // 初始化一个空集合 RandomizedCollection c = new RandomizedCollection(); // 成功插入数字 3，返回 true。c: [3] c.insert(3); // 3 已经在集合中，返回 false。c: [3, 3] c.insert(3); // 成功插入数字 6，返回 true。c: [3, 3, 6] c.insert(6); // 2/3 的概率返回 3，1/3 的概率返回 6。 // c: [3, 3, 6] c.getRandom(); // 成功删除数字 3，返回 true。c: [3, 6] c.remove(3); // 8 不在集合中，返回 false。c: [3, 6] c.remove(8); // 以 1/2 的概率返回 3 或 6。c: [3, 6] c.getRandom(); 2 LeetCode 381. O(1) 时间插入、删除和获取随机元素 - 允许重复 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p192.%E6%94%AF%E6%8C%81%E9%9A%8F%E6%9C%BA%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E9%9B%86%E5%90%88%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P192. 支持随机获取元素的集合（允许重复）","uri":"/posts/p192.%E6%94%AF%E6%8C%81%E9%9A%8F%E6%9C%BA%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E9%9B%86%E5%90%88%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树，要求你从根节点到叶子节点一层一层地进行 Z 字形遍历，也就是先从左向右访问一层节点，然后从右向左访问下一层节点。以这样的方式交替去访问二叉树上每一层节点，并且将访问的结果以二维数组的形式返回。","date":"2025-05-05","objectID":"/posts/p193.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84z%E5%AD%97%E5%BD%A2%E9%81%8D%E5%8E%86/","tags":["AlgoCasts","LeetCode"],"title":"P193. 二叉树的 Z 字形遍历","uri":"/posts/p193.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84z%E5%AD%97%E5%BD%A2%E9%81%8D%E5%8E%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树，要求你从根节点到叶子节点一层一层地进行 Z 字形遍历，也就是先从左向右访问一层节点，然后从右向左访问下一层节点。以这样的方式交替去访问二叉树上每一层节点，并且将访问的结果以二维数组的形式返回。 比如说，给你的二叉树是： 1 / \\ 2 4 / \\ 8 16 它的 Z 字形遍历结果是： [ [1], [4, 2], [8, 16] ] 2 LeetCode 103. 二叉树的锯齿形层序遍历 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p193.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84z%E5%AD%97%E5%BD%A2%E9%81%8D%E5%8E%86/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P193. 二叉树的 Z 字形遍历","uri":"/posts/p193.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84z%E5%AD%97%E5%BD%A2%E9%81%8D%E5%8E%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数 n，你要写一个函数来判断它是否为 3 的幂。","date":"2025-05-05","objectID":"/posts/p189.3%E7%9A%84%E5%B9%82/","tags":["AlgoCasts","LeetCode"],"title":"P189. 3 的幂","uri":"/posts/p189.3%E7%9A%84%E5%B9%82/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数 n，你要写一个函数来判断它是否为 3 的幂。 比如说，给你的 n 等于 9，则返回 true： n = 9 = 3^2 =\u003e true 再比如说，给你的 n 等于 8，则返回 false： n = 8 =\u003e false 2 LeetCode 326. 3 的幂 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p189.3%E7%9A%84%E5%B9%82/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P189. 3 的幂","uri":"/posts/p189.3%E7%9A%84%E5%B9%82/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一系列形如 A / B = K 的等式，其中 A 和 B 是字符串，K 是浮点数。你要根据这些等式，为一系列的除法表达式求值。如果求值结果不存在，就返回 -1.0。","date":"2025-05-05","objectID":"/posts/p190.%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/","tags":["AlgoCasts","LeetCode"],"title":"P190. 除法求值","uri":"/posts/p190.%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一系列形如 A / B = K 的等式，其中 A 和 B 是字符串，K 是浮点数。你要根据这些等式，为一系列的除法表达式求值。如果求值结果不存在，就返回 -1.0。 注意，假设给你的输入总是有效的。也就是说你不需要考虑除 0 或者输入中存在其他问题的情况。 比如说，给你 3 个等式： a / b = 2.0 b / c = 4.0 c / d = 5.0 这三个等式，以两个序列的形式提供给你： [[\"a\", \"b\"], [\"b\", \"c\"], [\"c\", \"d\"]] [2.0, 4.0, 5.0] 另外，题目还提供了一个查询序列，表示一系列除法： [[\"a\",\"d\"], [\"b\",\"a\"], [\"a\",\"c\"], [\"a\",\"e\"], [\"a\",\"a\"], [\"e\",\"e\"]] 根据前面提供的 3 个等式，计算出查询序列的结果并返回： [40, 0.5, 8, -1, 1, -1] 2 LeetCode 399. 除法求值 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p190.%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P190. 除法求值","uri":"/posts/p190.%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个非负整数 n，你要计算出小于 n 的质数（素数）一共有多少个。","date":"2025-05-05","objectID":"/posts/p191.%E8%B4%A8%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P191. 质数的个数","uri":"/posts/p191.%E8%B4%A8%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个非负整数 n，你要计算出小于 n 的质数（素数）一共有多少个。 比如说，给你的 n 等于 8： n = 8 小于 8 的质数一共有 4 个，分别是： 2, 3, 5, 7 因此你要返回 4。 2 LeetCode 204. 计数质数 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p191.%E8%B4%A8%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P191. 质数的个数","uri":"/posts/p191.%E8%B4%A8%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个单链表，你要重新排列这个链表，把奇数节点全都放到链表前面，偶数节点全都放到链表后面，并且奇数节点内和偶数节点内的节点相对顺序保持不变。","date":"2025-05-05","objectID":"/posts/p187.%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/","tags":["AlgoCasts","LeetCode"],"title":"P187. 奇偶链表","uri":"/posts/p187.%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个单链表，你要重新排列这个链表，把奇数节点全都放到链表前面，偶数节点全都放到链表后面，并且奇数节点内和偶数节点内的节点相对顺序保持不变。 注意，这里说的奇数和偶数，指的是节点的位置，而不是节点值。并且把头节点看作第一个节点，也就是说头节点是奇数节点。这个题目的时间复杂度要求是 O(n)，空间复杂度要求是 O(1)。 比如说，给你的链表是： 0 -\u003e 1 -\u003e 2 -\u003e 4 -\u003e 8 奇数位置上的节点是： [0, 2, 8] 偶数位置上的节点是： [1, 4] 因此重新排列后的链表就是： 0 -\u003e 2 -\u003e 8 -\u003e 1 -\u003e 4 2 LeetCode 328. 奇偶链表 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p187.%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P187. 奇偶链表","uri":"/posts/p187.%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你要设计一个增加版的集合（Set），它除了支持插入元素（insert）和删除元素（remove）的操作，还能等概率地随机获取当前集合中的元素（getRandom）。并且这 3 个操作的平均时间复杂度都要求是 O(1)。","date":"2025-05-05","objectID":"/posts/p188.%E6%94%AF%E6%8C%81%E9%9A%8F%E6%9C%BA%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E9%9B%86%E5%90%88/","tags":["AlgoCasts","LeetCode"],"title":"P188. 支持随机获取元素的集合","uri":"/posts/p188.%E6%94%AF%E6%8C%81%E9%9A%8F%E6%9C%BA%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E9%9B%86%E5%90%88/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你要设计一个增加版的集合（Set），它除了支持插入元素（insert）和删除元素（remove）的操作，还能等概率地随机获取当前集合中的元素（getRandom）。并且这 3 个操作的平均时间复杂度都要求是 O(1)。 以下是这个集合的使用示例： // 初始化一个空集合 RandomizedSet set = new RandomizedSet(); // 成功插入数字 3，返回 true。set: [3] set.insert(3); // 3 已经存在于集合中，返回 false。set: [3] set.insert(3); // 成功插入数字 6，返回 true。set: [3, 6] set.insert(6); // 成功插入数字 9，返回 true。set: [3, 6, 9] set.insert(9); // 以 1/ 3 的概率返回 3，6 或 9。set: [3, 6, 9] set.getRandom(); // 成功删除数字 3，返回 true。set: [6, 9] set.remove(3); // 8 不存在于集合中，返回 false。set: [6, 9] set.remove(8); // 以 1/2 的概率返回 6 或 9。set: [6, 9] set.getRandom(); 2 LeetCode 380. O(1) 时间插入、删除和获取随机元素 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p188.%E6%94%AF%E6%8C%81%E9%9A%8F%E6%9C%BA%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E9%9B%86%E5%90%88/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P188. 支持随机获取元素的集合","uri":"/posts/p188.%E6%94%AF%E6%8C%81%E9%9A%8F%E6%9C%BA%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E9%9B%86%E5%90%88/"},{"categories":["AlgoCasts","LeetCode"],"content":"定义一种数据变换方式，将连续相同的一段数字，用它的数量和这个数字组合起来表示。比如对于字符串 \"111221\"，它是由 3 个连续的 1，2 个连续的 2，以及 1 个 1 组成，因此它变换出来的下一个字符串就是 \"312211\"。从字符串 \"1\" 开始，使用这种方式不断向后变换，就可以得到一个字符串序列：\"1\", \"11\", \"21\", \"1211\", \"111221\", ...","date":"2025-05-05","objectID":"/posts/p184.%E6%8A%A5%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P184. 报数","uri":"/posts/p184.%E6%8A%A5%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 定义一种数据变换方式，将连续相同的一段数字，用它的数量和这个数字组合起来表示。比如对于字符串 “111221”，它是由 3 个连续的 1，2 个连续的 2，以及 1 个 1 组成，因此它变换出来的下一个字符串就是 “312211”。从字符串 “1” 开始，使用这种方式不断向后变换，就可以得到一个字符串序列： \"1\", \"11\", \"21\", \"1211\", \"111221\", ... 现在给你一个整数 n，你要返回这个序列中的第 n 项。 注意，n 从 1 开始算起，也就是说在这个序列中，第 1 项是字符串 “1”。 2 LeetCode 38. 外观数列 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p184.%E6%8A%A5%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P184. 报数","uri":"/posts/p184.%E6%8A%A5%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你二维平面上 n 个点，你要计算出最多有多少个点可以位于同一条直线上。","date":"2025-05-05","objectID":"/posts/p185.%E4%BD%8D%E4%BA%8E%E5%90%8C%E4%B8%80%E7%9B%B4%E7%BA%BF%E7%9A%84%E6%9C%80%E5%A4%9A%E7%82%B9%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P185. 位于同一直线的最多点数","uri":"/posts/p185.%E4%BD%8D%E4%BA%8E%E5%90%8C%E4%B8%80%E7%9B%B4%E7%BA%BF%E7%9A%84%E6%9C%80%E5%A4%9A%E7%82%B9%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你二维平面上 n 个点，你要计算出最多有多少个点可以位于同一条直线上。 注意，给你的 n 个点中，可能包含相同的点。 比如说，给你的点是： [[0,0], [0,0], [0,1], [1,1], [2,2]] 两个 [0,0] 和 [1,1]、[2,2] 这 4 个点都位于 y = x 这条直线上。并且不存在其他直线，可以包含更多的点。因此位于同一直线上最多的点数就为 4。 2 LeetCode 149. 直线上最多的点数 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p185.%E4%BD%8D%E4%BA%8E%E5%90%8C%E4%B8%80%E7%9B%B4%E7%BA%BF%E7%9A%84%E6%9C%80%E5%A4%9A%E7%82%B9%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P185. 位于同一直线的最多点数","uri":"/posts/p185.%E4%BD%8D%E4%BA%8E%E5%90%8C%E4%B8%80%E7%9B%B4%E7%BA%BF%E7%9A%84%E6%9C%80%E5%A4%9A%E7%82%B9%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数 n，你要写一个函数来判断它是否为 2 的幂。","date":"2025-05-05","objectID":"/posts/p186.2%E7%9A%84%E5%B9%82/","tags":["AlgoCasts","LeetCode"],"title":"P186. 2 的幂","uri":"/posts/p186.2%E7%9A%84%E5%B9%82/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数 n，你要写一个函数来判断它是否为 2 的幂。 比如说，给你的 n 等于 8，则返回 true： n = 8 = 2^3 =\u003e true 再比如说，给你的 n 等于 9，则返回 false： n = 9 =\u003e false 2 LeetCode 231. 2 的幂 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p186.2%E7%9A%84%E5%B9%82/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P186. 2 的幂","uri":"/posts/p186.2%E7%9A%84%E5%B9%82/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵满二叉树，每个树节点额外增加一个 next 指针，指向它右边的节点。一开始所有节点的 next 指针都为空，你要写一个函数处理这棵二叉树，使得所有节点的 next 指针都指向正确的节点。","date":"2025-05-05","objectID":"/posts/p181.%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84next%E6%8C%87%E9%92%88/","tags":["AlgoCasts","LeetCode"],"title":"P181. 树节点的 next 指针","uri":"/posts/p181.%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84next%E6%8C%87%E9%92%88/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵满二叉树，每个树节点额外增加一个 next 指针，指向它右边的节点。一开始所有节点的 next 指针都为空，你要写一个函数处理这棵二叉树，使得所有节点的 next 指针都指向正确的节点。 注意，满二叉树中，所有叶子节点都在最后一层。并且除了叶子节点，所有其他节点都有两个子节点。 // 包含 next 指针的树节点定义 public class Node { public int val; public Node left, right, next; } 比如说，给你的满二叉树是： 0 / \\ 2 4 / \\ / \\ 6 8 10 12 一开始每个节点的 next 指针都为空。你要做的就是，让每个节点的 next 指针指向它右边的节点。对于每一层中最后一个节点，由于它右边没有节点，因此它的 next 指针仍然指向空即可。 0 -\u003e null / \\ 2 -\u003e 4 -\u003e null / \\ / \\ 6-\u003e 8-\u003e10-\u003e 12 -\u003e null 2 LeetCode 116. 填充每个节点的下一个右侧节点指针 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p181.%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84next%E6%8C%87%E9%92%88/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P181. 树节点的 next 指针","uri":"/posts/p181.%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84next%E6%8C%87%E9%92%88/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个单链表，你要使用插入排序算法对它进行排序。","date":"2025-05-05","objectID":"/posts/p182.%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","tags":["AlgoCasts","LeetCode"],"title":"P182. 单链表插入排序","uri":"/posts/p182.%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个单链表，你要使用插入排序算法对它进行排序。 比如说，给你的链表是： 2 -\u003e 0 -\u003e 4 -\u003e 1 -\u003e 8 对这个链表进行排序，得到的链表是： 0 -\u003e 1 -\u003e 2 -\u003e 4 -\u003e 8 2 LeetCode 147. 对链表进行插入排序 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p182.%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P182. 单链表插入排序","uri":"/posts/p182.%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一组由出发机场与到达机场 [from, to] 表示的机票，你要按顺序把途经的机场排列出来。每个机场都由 3 个大写字母表示，并且一开始从 JFK 机场出发。","date":"2025-05-05","objectID":"/posts/p183.%E8%A1%8C%E7%A8%8B%E5%AE%89%E6%8E%92/","tags":["AlgoCasts","LeetCode"],"title":"P183. 行程安排","uri":"/posts/p183.%E8%A1%8C%E7%A8%8B%E5%AE%89%E6%8E%92/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一组由出发机场与到达机场 [from, to] 表示的机票，你要按顺序把途经的机场排列出来。每个机场都由 3 个大写字母表示，并且一开始从 JFK 机场出发。 注意，所有的机票都要用上，并且它们至少可以组成一个有效的行程。如果存在多个有效行程，则返回字典序最小的那个行程。 为了方便演示，我们假设用单个大写字母来表示机场，并且一开始由 A 机场出发。 比如说，给你的机票是： [B, D] [A, B] [C, E] [D, C] 这 4 张机票只能构成一个有效行程： [A, B, D, C, E] 再比如说，给你的机票是： [A, C] [A, B] [C, B] [B, A] 这 4 张机票可以组成两个有效的行程： [A, B, A, C, B] [A, C, B, A, B] 在这两个有效行程中，出发机场都是 A，然后第一个行程来到机场 B，而第二个行程来到机场 C。B 在字典序上是小于 C 的，因此我们要返回第一个有效行程： [A, B, A, C, B] 2 LeetCode 332. 重新安排行程 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p183.%E8%A1%8C%E7%A8%8B%E5%AE%89%E6%8E%92/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P183. 行程安排","uri":"/posts/p183.%E8%A1%8C%E7%A8%8B%E5%AE%89%E6%8E%92/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数 n，你要计算 n! 的结果末尾有多少个 0。","date":"2025-05-05","objectID":"/posts/p179.%E9%98%B6%E4%B9%98%E6%9C%AB%E5%B0%BE0%E7%9A%84%E4%B8%AA%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P179. 阶乘末尾 0 的个数","uri":"/posts/p179.%E9%98%B6%E4%B9%98%E6%9C%AB%E5%B0%BE0%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数 n，你要计算 n! 的结果末尾有多少个 0。 注意，题目要求算法的时间复杂度是 O(log(n))。 比如说，给你的 n 等于 4： n = 4 4! = 1 x 2 x 3 x 4 = 24 4! 等于 24，末尾没有 0，因此返回 0。 再比如说，给你的 n 等于 5： n = 5 5! = 1 x 2 x 3 x 4 x 5 = 120 5! 等于 120，末尾有 1 个 0，因此返回 1。 2 LeetCode 172. 阶乘后的零 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p179.%E9%98%B6%E4%B9%98%E6%9C%AB%E5%B0%BE0%E7%9A%84%E4%B8%AA%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P179. 阶乘末尾 0 的个数","uri":"/posts/p179.%E9%98%B6%E4%B9%98%E6%9C%AB%E5%B0%BE0%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数 n，你要实现一个算法来判断它是否为快乐数。","date":"2025-05-05","objectID":"/posts/p180.%E5%BF%AB%E4%B9%90%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P180. 快乐数","uri":"/posts/p180.%E5%BF%AB%E4%B9%90%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数 n，你要实现一个算法来判断它是否为快乐数。 快乐数的定义是：从任意正整数开始，将它变换为十进制位上各个数字的平方和。不断重复这个变换过程，如果最后数字可以变换成 1，那么这个数字就是快乐数；否则它会在一系列不包含 1 的数字之间循环变换，这样的数字不是快乐数。 比如说，给你的整数 n 等于 28： n = 28 接着将数字变换为十进制位上各个数字的平方和： 2^2 + 8^2 = 4 + 64 = 68 6^2 + 8^2 = 36 + 64 = 100 1^2 + 0^2 + 0^2 = 1 至此，整数 28 变换成 1。因此 28 是一个快乐数，返回 true。 2 LeetCode 202. 快乐数 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p180.%E5%BF%AB%E4%B9%90%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P180. 快乐数","uri":"/posts/p180.%E5%BF%AB%E4%B9%90%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两个非空数组，你要实现一个函数，来计算它们的交集。","date":"2025-05-05","objectID":"/posts/p176.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/","tags":["AlgoCasts","LeetCode"],"title":"P176. 两个数组的交集","uri":"/posts/p176.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两个非空数组，你要实现一个函数，来计算它们的交集。 注意，交集中元素的顺序不重要，以什么顺序返回都可以。 比如说，给你的第一个数组是： 1, 4, 4, 2 第二个数组为： 4, 8, 4, 4 这两个数组都包含两个 4，因此它们的交集为： 4, 4 2 LeetCode 350. 两个数组的交集 II 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p176.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P176. 两个数组的交集","uri":"/posts/p176.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个字符串表达式，你要实现一个简易计算器，对它进行求值。","date":"2025-05-05","objectID":"/posts/p177.%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/","tags":["AlgoCasts","LeetCode"],"title":"P177. 简易计算器","uri":"/posts/p177.%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个字符串表达式，你要实现一个简易计算器，对它进行求值。 表达式中只包含非负整数， +、-、*、/ 运算符以及空格。表达式中的除法使用整数除法，即两数相除只取整数部分。 注意，给出的表达式总是有效的，并且不允许使用内置的字符串求值函数。 比如说，给你的表达式为： \"1+3 + 2*6 / 3 - 2\" 这个表达式求值结果等于 6，因此你要返回 6。 2 LeetCode 227. 基本计算器 II 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p177.%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P177. 简易计算器","uri":"/posts/p177.%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个字符串表达式，你要实现一个简易计算器，对它进行求值。","date":"2025-05-05","objectID":"/posts/p178.%E6%94%AF%E6%8C%81%E6%8B%AC%E5%8F%B7%E4%B8%8E%E5%8A%A0%E5%87%8F%E6%B3%95%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8/","tags":["AlgoCasts","LeetCode"],"title":"P178. 支持括号与加减法的计算器","uri":"/posts/p178.%E6%94%AF%E6%8C%81%E6%8B%AC%E5%8F%B7%E4%B8%8E%E5%8A%A0%E5%87%8F%E6%B3%95%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个字符串表达式，你要实现一个简易计算器，对它进行求值。 表达式中只包含非负整数、(、)、+、- 运算符以及空格。 注意，给出的表达式总是有效的，并且不允许使用内置的字符串求值函数。 比如说，给你的表达式为： \"2-(1 -(2 + 1)) \" 这个表达式求值结果等于 4，因此你要返回 4。 2 LeetCode 224. 基本计算器 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p178.%E6%94%AF%E6%8C%81%E6%8B%AC%E5%8F%B7%E4%B8%8E%E5%8A%A0%E5%87%8F%E6%B3%95%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P178. 支持括号与加减法的计算器","uri":"/posts/p178.%E6%94%AF%E6%8C%81%E6%8B%AC%E5%8F%B7%E4%B8%8E%E5%8A%A0%E5%87%8F%E6%B3%95%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个字符串 s，和一个模式串 p。你要实现一个能支持 ? 和 \\* 的通配符匹配。其中，? 可以匹配任意单个非空字符，\\* 可以匹配 0 个字符或任意多个字符。","date":"2025-05-05","objectID":"/posts/p173.%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/","tags":["AlgoCasts","LeetCode"],"title":"P173. 通配符匹配","uri":"/posts/p173.%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个字符串 s，和一个模式串 p。你要实现一个能支持 ? 和 * 的通配符匹配。其中，? 可以匹配任意单个非空字符，* 可以匹配 0 个字符或任意多个字符。 s 可以是空字符串，也可以是只包含小写字母的非空字符串；p 可以是空字符串，也可以是只包含小写字母、? 或 * 的非空字符串。 注意，p 一定是合法的模式串，并且只有 p 匹配 s 的整个字符串时，才返回 true。 比如说， s: aa p: a 模式串 p 不包含通配符，且 s 和 p 不相同，于是这一组 p 和 s 不匹配。 再比如说， s: ac p: * * 可以匹配任意多个字符，因此这一组 p 和 s 匹配，返回 true。 如果这一组的 s 不变，仍然为 ac，但是把 p 改成 *d： s: ac p: *d 由于 p 中的字符 d 无法在 s 中找到匹配字符，因此这一组 p 和 s 不匹配，返回 false。 最后再举个例子： s: abcde p: *a*d? 我们只需要让第一个 * 匹配空字符，第二个 * 匹配 bc，最后的 ? 匹配字符 e，就可以把模式串变成 abcde。于是对于这一组字符串，p 可以匹配 s。 2 LeetCode 44. 通配符匹配 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p173.%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P173. 通配符匹配","uri":"/posts/p173.%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个正整数 num，你要实现一个函数，来判断它是否为完全平方数。","date":"2025-05-05","objectID":"/posts/p174.%E9%AA%8C%E8%AF%81%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P174. 验证完全平方数","uri":"/posts/p174.%E9%AA%8C%E8%AF%81%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个正整数 num，你要实现一个函数，来判断它是否为完全平方数。 注意，不能使用内置的平方根函数（sqrt）。 比如说，给你的正整数是 9， num = 9 9 是 3 的平方，因此 9 是一个完全平方数，返回 true。 再比如说，给你的正整数是 8， num = 8 8 不是一个完全平方数，返回 false。 2 LeetCode 367. 有效的完全平方数 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p174.%E9%AA%8C%E8%AF%81%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P174. 验证完全平方数","uri":"/posts/p174.%E9%AA%8C%E8%AF%81%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组，数组中相邻的元素不相等，你要找到这个数组的波峰元素，然后返回它的下标。波峰元素指的是比左右相邻元素都要大的元素。","date":"2025-05-05","objectID":"/posts/p175.%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E6%B3%A2%E5%B3%B0/","tags":["AlgoCasts","LeetCode"],"title":"P175. 查找数组的波峰","uri":"/posts/p175.%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E6%B3%A2%E5%B3%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组，数组中相邻的元素不相等，你要找到这个数组的波峰元素，然后返回它的下标。波峰元素指的是比左右相邻元素都要大的元素。 如果数组中包含多个波峰元素，则返回任意一个波峰元素的下标即可。你可以把数组左右边界之外的元素都看成负无穷大。 比如说，给你的数组是： 1, 2, 4, 1 这个数组中只有一个波峰元素 4，它大于左边的 2 和右边的 1。因此返回元素 4 的下标 2 即可。 再比如说，给你的数组是： 1, 2, 1, 2, 4 这个数组中有两个波峰元素，一个是 2，另一个为 4。波峰元素 2 大于它左右两边的 1，而波峰元素 4 大于左边的 2 和右边假想的负无穷大。因此返回这两个波峰元素任意的一个下标即可，也就是返回下标 1 或下标 4 都可以。 2 LeetCode 162. 寻找峰值 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p175.%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E6%B3%A2%E5%B3%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P175. 查找数组的波峰","uri":"/posts/p175.%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E6%B3%A2%E5%B3%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个非负整数 c，你要判断它是否可以分解成两个完全平方数的和。","date":"2025-05-05","objectID":"/posts/p171.%E4%B8%A4%E4%B8%AA%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%E7%9A%84%E5%92%8C/","tags":["AlgoCasts","LeetCode"],"title":"P171. 两个完全平方数的和","uri":"/posts/p171.%E4%B8%A4%E4%B8%AA%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%E7%9A%84%E5%92%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个非负整数 c，你要判断它是否可以分解成两个完全平方数的和。 比如说，给你的数字 c 等于 8： c = 8 8 可以分解成 2 的平方加上 2 的平方，因此要返回 true。 c = 8 = 2^2 + 2^2 再比如说给你的数字 c 等于 7： c = 7 7 不能分解成两个完全平方数的和，于是返回 false。 2 LeetCode 633. 平方数之和 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p171.%E4%B8%A4%E4%B8%AA%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%E7%9A%84%E5%92%8C/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P171. 两个完全平方数的和","uri":"/posts/p171.%E4%B8%A4%E4%B8%AA%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%E7%9A%84%E5%92%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树，你要返回一个序列，表示二叉树后序遍历的结果。","date":"2025-05-05","objectID":"/posts/p172.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","tags":["AlgoCasts","LeetCode"],"title":"P172. 二叉树后序遍历","uri":"/posts/p172.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树，你要返回一个序列，表示二叉树后序遍历的结果。 比如说，给你的二叉树是： 1 / \\ 2 3 \\ 4 你要返回的后序遍历序列是： [4, 2, 3, 1] 2 LeetCode 145. 二叉树的后序遍历 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p172.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P172. 二叉树后序遍历","uri":"/posts/p172.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个有序数组，你要就地（in place）移除数组中的重复元素。然后返回不包含重复元素的子数组长度。","date":"2025-05-05","objectID":"/posts/p168.%E7%A7%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/","tags":["AlgoCasts","LeetCode"],"title":"P168. 移除有序数组中的重复元素","uri":"/posts/p168.%E7%A7%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个有序数组，你要就地（in place）移除数组中的重复元素。然后返回不包含重复元素的子数组长度。 比如说，给你的有序数组是： [1, 1, 2, 3, 4, 4] 在这个数组中就地移除重复元素后，得到： [1, 2, 3, 4, _, _] 因此，我们要返回这个子数组的长度 4。 原数组的长度是 6，所以子数组 1,2,3,4 后面实际上还有两个位置。但这两个位置上放什么数字都无所谓。因为根据返回的长度 4，我们就可以确定不包含重复元素的子数组边界。 2 LeetCode 26. 删除有序数组中的重复项 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p168.%E7%A7%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P168. 移除有序数组中的重复元素","uri":"/posts/p168.%E7%A7%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个 9 x 9 的填充了一部分数字的数独，你要判断它是否有效。","date":"2025-05-05","objectID":"/posts/p169.%E5%88%A4%E6%96%AD%E6%95%B0%E7%8B%AC%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7/","tags":["AlgoCasts","LeetCode"],"title":"P169. 判断数独的有效性","uri":"/posts/p169.%E5%88%A4%E6%96%AD%E6%95%B0%E7%8B%AC%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个 9 x 9 的填充了一部分数字的数独，你要判断它是否有效。 注意，有效的数独不一定有解。你只需要判断已经填充的数字满足以下 3 条规则即可： 每一行只能包含数字 1-9，并且不能重复。 每一列只能包含数字 1-9，并且不能重复。 每个 3 x 3 的小正方形只能包含数字 1-9，并且不能重复。 其中，第三条中说的小正方形，指的是将 9 x 9 的大正方形平均分成 9 个 3 x 3 的小正方形。而不是指任意 3 x 3 的小正方形。代码中使用一个 9 x 9 的二维字符数组来表示数独，数组中只包含字符 1 到 9 和字符点号，点号表示这个位置没有填充数字。 2 LeetCode 36. 有效的数独 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p169.%E5%88%A4%E6%96%AD%E6%95%B0%E7%8B%AC%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P169. 判断数独的有效性","uri":"/posts/p169.%E5%88%A4%E6%96%AD%E6%95%B0%E7%8B%AC%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组，数组中可能包含重复元素，你要返回这个数组所有不同的排列。","date":"2025-05-05","objectID":"/posts/p170.%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%88%97/","tags":["AlgoCasts","LeetCode"],"title":"P170. 包含重复元素的数组排列","uri":"/posts/p170.%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%88%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组，数组中可能包含重复元素，你要返回这个数组所有不同的排列。 比如说，给你的数组是： [0, 1, 0] 由 [0, 1, 0] 构成的不同排列只有 3 种，分别是： [0, 0, 1] [0, 1, 0] [1, 0, 0] 2 LeetCode 47. 全排列 II 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p170.%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%88%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P170. 包含重复元素的数组排列","uri":"/posts/p170.%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%88%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组，你要找到数组中没有出现的最小正整数。","date":"2025-05-05","objectID":"/posts/p166.%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P166. 第一个缺失的正整数","uri":"/posts/p166.%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组，你要找到数组中没有出现的最小正整数。 这个题目要求算法只能使用 O(n) 的时间，以及 O(1) 的辅助空间。 比如说，给你的数组是： [2, -1, 4, 1, 8] 我们可以从最小的正整数 1 开始，检查第一个没出现在这个数组的正整数。1 和 2 都出现了，而 3 不在这个数组中，因此第一个缺失的正整数是 3。 2 LeetCode 41. 缺失的第一个正数 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p166.%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P166. 第一个缺失的正整数","uri":"/posts/p166.%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个罗马数字，你要将它转成阿拉伯数字。其中，给出的罗马数字表示范围在 1 到 3999 之间。","date":"2025-05-05","objectID":"/posts/p167.%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97/","tags":["AlgoCasts","LeetCode"],"title":"P167. 罗马数字转阿拉伯数字","uri":"/posts/p167.%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个罗马数字，你要将它转成阿拉伯数字。其中，给出的罗马数字表示范围在 1 到 3999 之间。 比如说，给你的罗马数字是 III，你要将它转成数字 3；再比如说，给你的罗马数字是 IV，你要将它转成数字 4。 2 LeetCode 13. 罗马数字转整数 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p167.%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P167. 罗马数字转阿拉伯数字","uri":"/posts/p167.%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个字符串数组，你要找到这些字符串的最长公共前缀。如果它们没有公共前缀，则返回空字符串。","date":"2025-05-05","objectID":"/posts/p163.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","tags":["AlgoCasts","LeetCode"],"title":"P163. 字符串的最长公共前缀","uri":"/posts/p163.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个字符串数组，你要找到这些字符串的最长公共前缀。如果它们没有公共前缀，则返回空字符串。 比如说，给你的字符串数组是： [\"car\", \"cat\", \"care\"] 这三个字符串的最长公共前缀是 ca，可以看到所有的字符串都包含 ca 前缀，因此我们要返回 ca。 再比如说给你的字符串数组是： [\"car\", \"bus\"] 它们不包含相同的前缀，因此返回空字符串 \"\"。 2 LeetCode 14. 最长公共前缀 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p163.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P163. 字符串的最长公共前缀","uri":"/posts/p163.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组和一个目标值，你要在数组中找到三个整数，使它们的和最接近目标值。然后返回这三个整数的和。","date":"2025-05-05","objectID":"/posts/p164.%E6%B1%82%E5%92%8C%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E4%B8%89%E4%B8%AA%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P164. 求和最接近目标值的三个数","uri":"/posts/p164.%E6%B1%82%E5%92%8C%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E4%B8%89%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组和一个目标值，你要在数组中找到三个整数，使它们的和最接近目标值。然后返回这三个整数的和。 注意，假设给你的数组都有一个唯一解。 比如说，给你的数组是： [-1, 2, -1, -4] 给你的目标值是 1。在这个数组中，求和后最接近目标值 1 的三个数字是： [-1, 2, -1] 它们相加等于 0，因此你要返回 0。 再比如说，给你的数组不变，但是目标值改成 -6。 在这个数组中，正好有三个数的和等于 -6，它们是： [-1, -1, -4] 因此它们的和 -6 就是最接近目标值的数字，返回它即可。 2 LeetCode 16. 最接近的三数之和 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p164.%E6%B1%82%E5%92%8C%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E4%B8%89%E4%B8%AA%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P164. 求和最接近目标值的三个数","uri":"/posts/p164.%E6%B1%82%E5%92%8C%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E4%B8%89%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组和一个目标值，你要找到数组中四个数相加等于目标值的所有可能组合。返回的答案里，每个组合都是唯一的，不能重复。","date":"2025-05-05","objectID":"/posts/p165.%E7%9B%B8%E5%8A%A0%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P165. 相加等于目标值的四个数","uri":"/posts/p165.%E7%9B%B8%E5%8A%A0%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组和一个目标值，你要找到数组中四个数相加等于目标值的所有可能组合。返回的答案里，每个组合都是唯一的，不能重复。 比如说，给你的数组是： [1, 0, -1, 0, -3, 2] 给你的目标值是 0。 这个数组中有两个组合，使得 4 个数相加等于目标值 0。第一个组合是： [-3, 0, 1, 2] 虽然数组中有两个 0，但是不管使用哪个 0，组合 [-3, 0, 1, 2] 都只算作一个。 另一个相加等于目标值的组合是： [-1, 0, 0, 1] 2 LeetCode 18. 四数之和 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p165.%E7%9B%B8%E5%8A%A0%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P165. 相加等于目标值的四个数","uri":"/posts/p165.%E7%9B%B8%E5%8A%A0%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你要设计一个数据结构用于查找数据流中的中位数。它要支持以下两个操作，addNum 用于向数据结构中添加一个整数。findMedian 用于查找该数据结构中目前所有整数的中位数。","date":"2025-05-05","objectID":"/posts/p160.0%E5%88%B0100%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E6%9F%A5%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P160. 0 到 100 的数据流中查找中位数","uri":"/posts/p160.0%E5%88%B0100%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E6%9F%A5%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你要设计一个数据结构用于查找数据流中的中位数。它要支持以下两个操作，addNum 用于向数据结构中添加一个整数。findMedian 用于查找该数据结构中目前所有整数的中位数。 注意，这个题目要求你在两种情况下设计这个数据结构。第一种情况是，数据流中的数字全部都大于等于 0 并且小于等于 100。第二种情况是，数据流中 99% 的数字大于等于 0 并且小于等于 100。 其中，中位数的定义是将序列排序后正中间的数字，如果序列的长度是偶数，则取正中间两个数字的平均数。 2 LeetCode 295. 数据流的中位数 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p160.0%E5%88%B0100%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E6%9F%A5%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P160. 0 到 100 的数据流中查找中位数","uri":"/posts/p160.0%E5%88%B0100%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E6%9F%A5%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个没有环的无向图，把图上任意一个节点当作根节点，就可以把它看作一棵树。这样一来，对于一个包含 n 个节点的无环无向图，可以产生 n 棵不同的树。你要找出这 n 棵树中，所有高度最小的树，并返回它们的根节点。其中，高度的定义是：根节点和最远的叶子节点之间，边的数量。","date":"2025-05-05","objectID":"/posts/p161.%E9%AB%98%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E6%A0%91/","tags":["AlgoCasts","LeetCode"],"title":"P161. 高度最小的树","uri":"/posts/p161.%E9%AB%98%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个没有环的无向图，把图上任意一个节点当作根节点，就可以把它看作一棵树。这样一来，对于一个包含 n 个节点的无环无向图，可以产生 n 棵不同的树。你要找出这 n 棵树中，所有高度最小的树，并返回它们的根节点。其中，高度的定义是：根节点和最远的叶子节点之间，边的数量。 注意，给你的 n 是一个正整数，表示图上共有 n 个节点，编号从 0 到 n-1。另外给你一组数字对，表示连接两个节点的边。并且给你的这组数字对中，不包含重复的边。 比如说，给你的 n 等于 4，给你的表示边的数字对是： [0, 1]， [0, 2]， [0, 3] 它表示这样一个无向图： 1 | 0 / \\ 2 3 在这个无向图中，高度最小的树只有一棵，就是以 0 为根节点的树。于是返回：[0]。 如果把 n 改成 5，然后再加一条边 [3, 4]，这个无向图就会变成： 1 | 0 / \\ 2 3 | 4 在这个无向图中，高度最小的树有两棵（高度为 2），返回它们对应的根节点是：[0, 3]。 2 LeetCode 310. 最小高度树 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p161.%E9%AB%98%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E6%A0%91/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P161. 高度最小的树","uri":"/posts/p161.%E9%AB%98%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个 32 位的整数，你要反转它每一个十进制位上的数字。对于负数，我们只反转数字部分，负号仍然放在最前面。另外，反转后如果有前缀 0，则要去掉。","date":"2025-05-05","objectID":"/posts/p162.%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P162. 反转整数","uri":"/posts/p162.%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个 32 位的整数，你要反转它每一个十进制位上的数字。对于负数，我们只反转数字部分，负号仍然放在最前面。另外，反转后如果有前缀 0，则要去掉。 注意，反转后的数字如果溢出，无法使用一个 32 位的整数表示，则返回 0。 比如说，给你的整数是 124，反转后的结果为 421： x = 124, reverse(x) =\u003e 421 再比如说，给你的整数是 -42，反转后的结果为 -24 x = -42, reverse(x) =\u003e -24 负号不需要反转，仍然放在最前面。最后，如果给你的整数是 420，返回后的结果为 24： x = 420, reverse(x) =\u003e 24 反转后要去掉前缀 0，只剩下 24。 2 LeetCode 7. 整数反转 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p162.%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P162. 反转整数","uri":"/posts/p162.%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵不为空的二叉树，你要计算出这棵二叉树中的最大路径和。","date":"2025-05-05","objectID":"/posts/p158.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/","tags":["AlgoCasts","LeetCode"],"title":"P158. 二叉树的最大路径和","uri":"/posts/p158.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵不为空的二叉树，你要计算出这棵二叉树中的最大路径和。 对于二叉树中任意两个节点，路径指的是从其中一个节点出发，经过它们的最近公共祖先，然后到达另一个节点的节点序列。另外，单个节点也算一条路径。注意，路径不一定会经过原始二叉树的根节点。 比如说，给你的二叉树是： -4 / \\ 1 2 / \\ 4 8 这棵二叉树中，最大路径和是 13。对应的路径是 4 -\u003e 1 -\u003e 8。 再比如说给你的二叉树是： 1 / \\ -2 -4 这棵二叉树中，最大路径和是 1。对应的路径只有一个节点 1。 2 LeetCode 124. 二叉树中的最大路径和 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p158.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P158. 二叉树的最大路径和","uri":"/posts/p158.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你要设计一个数据结构用于查找数据流中的中位数。它要支持以下两个操作，addNum 用于向数据结构中添加一个整数。findMedian 用于查找该数据结构中目前所有整数的中位数。","date":"2025-05-05","objectID":"/posts/p159.%E5%9C%A8%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E6%9F%A5%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P159. 在数据流中查找中位数","uri":"/posts/p159.%E5%9C%A8%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E6%9F%A5%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你要设计一个数据结构用于查找数据流中的中位数。它要支持以下两个操作，addNum 用于向数据结构中添加一个整数。findMedian 用于查找该数据结构中目前所有整数的中位数。 中位数的定义是将序列排序后正中间的数字，如果序列的长度是偶数，则取正中间两个数字的平均数。 2 LeetCode 295. 数据流的中位数 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p159.%E5%9C%A8%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E6%9F%A5%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P159. 在数据流中查找中位数","uri":"/posts/p159.%E5%9C%A8%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E6%9F%A5%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你字符串 s 和 p，你要在 s 中找到所有 p 的变位词，并返回它们的开始下标。变位词指的是使用相同字母以不同顺序构成的单词。在这个题目中，字符串 s 和 p 都只由小写字母组成，并且长度不会超过 100。","date":"2025-05-05","objectID":"/posts/p155.%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%8F%98%E4%BD%8D%E8%AF%8D/","tags":["AlgoCasts","LeetCode"],"title":"P155. 查找字符串中所有变位词","uri":"/posts/p155.%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%8F%98%E4%BD%8D%E8%AF%8D/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你字符串 s 和 p，你要在 s 中找到所有 p 的变位词，并返回它们的开始下标。变位词指的是使用相同字母以不同顺序构成的单词。在这个题目中，字符串 s 和 p 都只由小写字母组成，并且长度不会超过 100。 比如说，给你的字符串 s 和 p 是： s: bcbababac p: abc 在字符串 s 中，abc 的变位词有 cba 和 bac，它们的组成字符都是 a/b/c，只是排列顺序不一样。 我们要返回这两个变位词的开始下标。第一个变位词的开始下标是 1，第二个变位词的开始下标是 6，因此返回： [1，6] 2 LeetCode 438. 找到字符串中所有字母异位词 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p155.%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%8F%98%E4%BD%8D%E8%AF%8D/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P155. 查找字符串中所有变位词","uri":"/posts/p155.%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%8F%98%E4%BD%8D%E8%AF%8D/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个不为空的整数数组，你要返回前 K 个出现频率最高的数字。假设给你的 K 总是有效的，也就是数组中一定包含至少 K 个不同的数字。","date":"2025-05-05","objectID":"/posts/p156.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E6%95%B0%E5%AD%97/","tags":["AlgoCasts","LeetCode"],"title":"P156. 前 K 个高频数字","uri":"/posts/p156.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个不为空的整数数组，你要返回前 K 个出现频率最高的数字。假设给你的 K 总是有效的，也就是数组中一定包含至少 K 个不同的数字。 比如说，给你的数组是： 1, 2, 1, 2, 1, 4 给你的 K 是 2： K = 2 在这个数组中，数字 1 出现了 3 次，数字 2 出现 2 次，数字 4 只出现 1 次。 因此，出现频率最高的两个数字是： [1, 2] 注意，返回结果中，数字的顺序不重要，也就是说这里返回 [2, 1] 也是对的。 2 LeetCode 347. 前 K 个高频元素 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p156.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E6%95%B0%E5%AD%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P156. 前 K 个高频数字","uri":"/posts/p156.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个大小为 n+1 的整数数组，数组中的数字都大于等于 1 并且小于等于 n。尝试证明数组中至少存在一个重复的数字。假设数组中只存在一个重复的数字，你要找出这个数字。","date":"2025-05-05","objectID":"/posts/p157.%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/","tags":["AlgoCasts","LeetCode"],"title":"P157. 查找重复数字","uri":"/posts/p157.%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个大小为 n+1 的整数数组，数组中的数字都大于等于 1 并且小于等于 n。尝试证明数组中至少存在一个重复的数字。假设数组中只存在一个重复的数字，你要找出这个数字。 题目要求不能修改原数组，并且只能使用 O(1) 的辅助空间。 比如说，给你的数组是： 4, 3, 4, 1, 2, 5 这个数组的大小为 6，也就是说数组中每个数字都大于等于 1 并且小于等于 5。数组中重复的数字为 4，于是你要返回 4。 再比如说，给你的数组是： 1, 3, 3, 3 这个数组的大小为 4，也就是说数组中每个数字都大于等于 1 并且小于等于 3。数组中重复的数字是 3，于是你要返回 3。 2 LeetCode 287. 寻找重复数 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p157.%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P157. 查找重复数字","uri":"/posts/p157.%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个字符串 s，和一个模式串 p。你要实现一个能支持 \\. 和 \\* 的简易正则表达式匹配。","date":"2025-05-05","objectID":"/posts/p152.%E7%AE%80%E6%98%93%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","tags":["AlgoCasts","LeetCode"],"title":"P152. 简易正则表达式匹配","uri":"/posts/p152.%E7%AE%80%E6%98%93%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个字符串 s，和一个模式串 p。你要实现一个能支持 . 和 * 的简易正则表达式匹配。 其中，. 可以匹配任意单个非空字符。* 可以将它前面的一个字符重复 0 次或多次。s 可以是空字符串，也可以是只包含小写字母的非空字符串；p 可以是空字符串，也可以是只包含小写字母、. 或 * 的非空字符串。 注意，p 一定是合法的模式串，并且只有 p 匹配 s 的整个字符串时，才返回 true。 比如说， s: aa p: a 模式串 p 不包含通配符，且 s 和 p 不相同，于是这一组 p 和 s 不匹配。 再比如说， s: ac p: .* * 可以把 . 重复两次，变成 .. ，而 . 可以匹配任意字符。因此让第一个 . 匹配 a，第二个 . 匹配 c，即可匹配整个 s。于是对于这一组字符串，p 可以匹配 s。 最后再举个例子， s: aab p: c*a*b 只需要让第一个 * 重复 0 次 c，第二个 * 重复两次 a，即可把模式串变成 aab。于是对于这一组字符串，p 可以匹配 s。 2 LeetCode 10. 正则表达式匹配 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p152.%E7%AE%80%E6%98%93%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P152. 简易正则表达式匹配","uri":"/posts/p152.%E7%AE%80%E6%98%93%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个正整数 n，你要计算出它最少可以分解成多少个完全平方数的和。完全平方数指的是可以表示成某个整数的平方的数字，比如 1、4、9、16 等等。","date":"2025-05-05","objectID":"/posts/p153.%E6%9C%80%E5%B0%91%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%E5%88%86%E8%A7%A3/","tags":["AlgoCasts","LeetCode"],"title":"P153. 最少完全平方数分解","uri":"/posts/p153.%E6%9C%80%E5%B0%91%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%E5%88%86%E8%A7%A3/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个正整数 n，你要计算出它最少可以分解成多少个完全平方数的和。完全平方数指的是可以表示成某个整数的平方的数字，比如 1、4、9、16 等等。 比如说，给你的 n 等于 5。5 最少可以表示成 1 和 4 这两个完全平方数相加： 5 = 1 + 4 因此 5 最少可以分解成 2 个完全平方数的和。 再比如说，给你的 n 等于 12。它最少可以分解成 4 + 4 + 4： 12 = 4 + 4 + 4 因此 12 最少可以分解成 3 个完全平方数的和。 2 LeetCode 279. 完全平方数 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p153.%E6%9C%80%E5%B0%91%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%E5%88%86%E8%A7%A3/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P153. 最少完全平方数分解","uri":"/posts/p153.%E6%9C%80%E5%B0%91%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%E5%88%86%E8%A7%A3/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你要设计一个算法来序列化和反序列化一棵二叉树。你需要实现两个函数，序列化函数可以把一棵二叉树序列化成一个字符串表示；而反序列化函数可以把这个字符串还原成原来的二叉树。","date":"2025-05-05","objectID":"/posts/p154.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","tags":["AlgoCasts","LeetCode"],"title":"P154. 二叉树的序列化和反序列化","uri":"/posts/p154.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你要设计一个算法来序列化和反序列化一棵二叉树。你需要实现两个函数，序列化函数可以把一棵二叉树序列化成一个字符串表示；而反序列化函数可以把这个字符串还原成原来的二叉树。 比如说，给你的二叉树是： 0 / \\ 1 2 / \\ 4 8 你可以把它序列化成字符串： \"[0,1,2,null,null,4,8]\" 这是 leetcode 对二叉树的序列化表示，只要你刷过 leetcode，对这个应该不会陌生。 反过来，如果给你这个字符串。你也要能把它还原成原来的二叉树。 注意：序列化和反序列化具体使用什么算法不限，序列化后的字符串也并不是非得使用 leetcode 采用的形式。只要能对一棵二叉树正确地序列化和反序列化即可。 2 LeetCode 297. 二叉树的序列化与反序列化 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p154.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P154. 二叉树的序列化和反序列化","uri":"/posts/p154.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树，你要计算出这棵树的直径。二叉树的直径定义为树上任意两个节点之间最长路径的长度。其中，两个节点之间的路径不一定要经过根节点。","date":"2025-05-05","objectID":"/posts/p150.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/","tags":["AlgoCasts","LeetCode"],"title":"P150. 二叉树的直径","uri":"/posts/p150.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树，你要计算出这棵树的直径。二叉树的直径定义为树上任意两个节点之间最长路径的长度。其中，两个节点之间的路径不一定要经过根节点。 比如说，给你的二叉树是： 0 / \\ 1 2 / \\ 4 8 在这棵二叉树中，最长的路径有两条，分别为 [4, 1, 0, 2] 和 [8, 1, 0, 2]，长度都为 3，因此你要返回的直径就是 3。 注意，直径的大小由两个节点之间边的数量来表示。在这个例子中，最长的两条路径上都有 3 条边，因此直径为 3。 2 LeetCode 543. 二叉树的直径 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p150.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P150. 二叉树的直径","uri":"/posts/p150.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个只包含数字 2 ~ 9 的字符串，你要返回它对应的所有字母组合。","date":"2025-05-05","objectID":"/posts/p151.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/","tags":["AlgoCasts","LeetCode"],"title":"P151. 电话号码对应的字母组合","uri":"/posts/p151.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个只包含数字 2 ~ 9 的字符串，你要返回它对应的所有字母组合。 数字与字母的映射关系和九宫格键盘上的一样，映射关系如下： 2: abc 3: def 4: ghi 5: jkl 6: mno 7: pqrs 8: tuv 9: wxyz 比如说，给你的数字字符串是 \"23\"，你要返回的字母组合是： [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"] 其中，字母组合之间的顺序并不重要，以什么顺序返回都可以。 2 LeetCode 17. 电话号码的字母组合 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p151.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P151. 电话号码对应的字母组合","uri":"/posts/p151.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个包含 0/1 字符的二维矩阵，你要找到矩阵中只包含字符 1 的最大矩形，并返回它的面积。","date":"2025-05-05","objectID":"/posts/p147.0%E5%92%8C1%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/","tags":["AlgoCasts","LeetCode"],"title":"P147. 0/1 矩阵中的最大矩形","uri":"/posts/p147.0%E5%92%8C1%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个包含 0/1 字符的二维矩阵，你要找到矩阵中只包含字符 1 的最大矩形，并返回它的面积。 比如说，给你的二维矩阵如下所示： 1 0 1 0 0 1 1 1 1 1 0 0 1 1 1 只包含字符 1 的最大矩形是右下角 6 个 1 构成的矩形。因此，你要返回的面积就是 6。 2 LeetCode 85. 最大矩形 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p147.0%E5%92%8C1%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P147. 0/1 矩阵中的最大矩形","uri":"/posts/p147.0%E5%92%8C1%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个包含 0/1 字符的二维矩阵，你要找到矩阵中只包含字符 1 的最大正方形，并返回它的面积。","date":"2025-05-05","objectID":"/posts/p148.0%E5%92%8C1%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/","tags":["AlgoCasts","LeetCode"],"title":"P148. 0/1 矩阵中的最大正方形","uri":"/posts/p148.0%E5%92%8C1%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个包含 0/1 字符的二维矩阵，你要找到矩阵中只包含字符 1 的最大正方形，并返回它的面积。 比如说，给你的二维矩阵如下所示： 1 0 1 0 0 1 1 1 1 1 0 0 0 1 1 只包含字符 1 的最大正方形是右下角 4 个 1 构成的正方形。因此，你要返回的面积就为 4。 2 LeetCode 221. 最大正方形 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p148.0%E5%92%8C1%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P148. 0/1 矩阵中的最大正方形","uri":"/posts/p148.0%E5%92%8C1%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数 n，你要计算出，由 1 ~ n 这 n 个数字可以构成多少棵不同的二叉搜索树。","date":"2025-05-05","objectID":"/posts/p149.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%95%B0%E9%87%8F/","tags":["AlgoCasts","LeetCode"],"title":"P149. 二叉搜索树的数量","uri":"/posts/p149.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数 n，你要计算出，由 1 ~ n 这 n 个数字可以构成多少棵不同的二叉搜索树。 比如说，给你的 n 是 3，1/2/3 这 3 个数字总共可以构成 5 棵不同的二叉搜索树。如下所示： 1 1 2 3 3 \\ \\ / \\ / / 2 3 1 3 1 2 \\ / \\ / 3 2 2 1 因此，你要返回的数量就是 5。 2 LeetCode 96. 不同的二叉搜索树 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p149.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%95%B0%E9%87%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P149. 二叉搜索树的数量","uri":"/posts/p149.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%95%B0%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组，其中第 i 个元素表示的是第 i 天的股票价格，在不限制买卖次数的情况下，你要计算出买卖股票可以获得的最大利润。注意，你不能同时参与到多个交易当中，也就是你要先卖掉手上的股票，才能买进新的一股。","date":"2025-05-05","objectID":"/posts/p144.%E4%B8%8D%E9%99%90%E6%AC%A1%E6%95%B0%E8%BF%9B%E8%A1%8C%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/","tags":["AlgoCasts","LeetCode"],"title":"P144. 不限次数进行股票买卖的最大利润","uri":"/posts/p144.%E4%B8%8D%E9%99%90%E6%AC%A1%E6%95%B0%E8%BF%9B%E8%A1%8C%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组，其中第 i 个元素表示的是第 i 天的股票价格，在不限制买卖次数的情况下，你要计算出买卖股票可以获得的最大利润。注意，你不能同时参与到多个交易当中，也就是你要先卖掉手上的股票，才能买进新的一股。 比如说，给你的数组是： 2, 1, 2, 4, 2, 8, 4 你在价格为 1 时买入并在价格为 4 的時候卖出，获得利润 3；然后在价格为 2 时买入并在价格为 8 时卖出，获得利润 6。这个买卖组合可以获得最大利润 9。 再比如说给你的数组是： 8, 4, 2, 1 这时股票每天都在迭，不存在买入再卖出来获利的可能，因此没有交易，最大利润为 0。 2 LeetCode 122. 买卖股票的最佳时机 II 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p144.%E4%B8%8D%E9%99%90%E6%AC%A1%E6%95%B0%E8%BF%9B%E8%A1%8C%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P144. 不限次数进行股票买卖的最大利润","uri":"/posts/p144.%E4%B8%8D%E9%99%90%E6%AC%A1%E6%95%B0%E8%BF%9B%E8%A1%8C%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你要实现一棵前缀树（Trie），其中包含 insert, search 和 startsWith 三个方法。insert 用于插入一个单词，search 用于搜索一个单词是否存在于前缀树中，startsWith 用于判断前缀树中是否存在一个包含给定前缀的单词。注意：所有的输入都是非空字符串，并且只包含小写字母。","date":"2025-05-05","objectID":"/posts/p145.%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E6%A0%91/","tags":["AlgoCasts","LeetCode"],"title":"P145. 实现前缀树","uri":"/posts/p145.%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你要实现一棵前缀树（Trie），其中包含 insert, search 和 startsWith 三个方法。insert 用于插入一个单词，search 用于搜索一个单词是否存在于前缀树中，startsWith 用于判断前缀树中是否存在一个包含给定前缀的单词。注意：所有的输入都是非空字符串，并且只包含小写字母。 2 LeetCode 208. 实现 Trie (前缀树) 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p145.%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E6%A0%91/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P145. 实现前缀树","uri":"/posts/p145.%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个非负整数数组，数组中的整数表示直方图的高度，每个直方图的宽度都为 1，你要计算出直方图中最大矩形的面积。","date":"2025-05-05","objectID":"/posts/p146.%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/","tags":["AlgoCasts","LeetCode"],"title":"P146. 直方图中的最大矩形","uri":"/posts/p146.%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个非负整数数组，数组中的整数表示直方图的高度，每个直方图的宽度都为 1，你要计算出直方图中最大矩形的面积。 比如说，给你的数组是 2, 1, 3, 4, 1, 它对应的直方图如图所示： +--+ | | +--+ | | | | +--+ | | | | | | | | | +--+ | +--+ | | | | | | +--+--+--+--+--+--\u003e 2 1 3 4 1 在这些直方图组成的区域里，可以形成的最大矩形是 3 和 4 这两个直方图中，高度为 3，宽度为 2 的矩形。它的面积为 6，因此你要返回 6。 2 LeetCode 84. 柱状图中最大的矩形 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p146.%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P146. 直方图中的最大矩形","uri":"/posts/p146.%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个大小为 n 的整数数组 nums，其中 n \u003e 1。你要返回一个数组 output。其中，output(i) 是原数组中除了 nums(i) 以外，所有数字的乘积。注意，这道题目的求解过程不能使用除法。","date":"2025-05-05","objectID":"/posts/p142.%E9%99%A4%E4%BA%86%E8%87%AA%E8%BA%AB%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%E4%B9%98%E7%A7%AF/","tags":["AlgoCasts","LeetCode"],"title":"P142. 除了自身元素的数组乘积","uri":"/posts/p142.%E9%99%A4%E4%BA%86%E8%87%AA%E8%BA%AB%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%E4%B9%98%E7%A7%AF/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个大小为 n 的整数数组 nums，其中 n \u003e 1。你要返回一个数组 output。其中，output(i) 是原数组中除了 nums(i) 以外，所有数字的乘积。注意，这道题目的求解过程不能使用除法。 比如说，给你的数组是： 1, 4, 2, 8 你要返回的数组就是： 64, 16, 32, 8 可以看到返回的数组中，每个位置上的数字都是原数组中除了那个位置以外的所有数字乘积。 2 LeetCode 238. 除自身以外数组的乘积 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p142.%E9%99%A4%E4%BA%86%E8%87%AA%E8%BA%AB%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%E4%B9%98%E7%A7%AF/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P142. 除了自身元素的数组乘积","uri":"/posts/p142.%E9%99%A4%E4%BA%86%E8%87%AA%E8%BA%AB%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%E4%B9%98%E7%A7%AF/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树和一个目标值，你要计算出路径和等于目标值的路径一共有多少条。其中，路径不需要开始于根节点，或结束于叶子节点。但必须是从父节点到子节点。","date":"2025-05-05","objectID":"/posts/p143.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E9%87%8F/","tags":["AlgoCasts","LeetCode"],"title":"P143. 二叉树中和为给定值的路径数量","uri":"/posts/p143.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树和一个目标值，你要计算出路径和等于目标值的路径一共有多少条。其中，路径不需要开始于根节点，或结束于叶子节点。但必须是从父节点到子节点。 比如说，给你的二叉树是： 1 / \\ 2 4 \\ / \\ 3 5 6 给你的目标值是 5。 在这棵二叉树中，路径和等于 5 的路径有： 1 -\u003e 4 2 -\u003e 3 5 总共有 3 条满足条件的路径，因此你要返回 3。 2 LeetCode 437. 路径总和 III 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p143.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E9%87%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P143. 二叉树中和为给定值的路径数量","uri":"/posts/p143.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉搜索树以及树中两个节点，你要找到这两个节点的最近公共祖先，然后将它返回。注意，树上所有的节点值都不相同。","date":"2025-05-05","objectID":"/posts/p139.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","tags":["AlgoCasts","LeetCode"],"title":"P139. 二叉搜索树中节点的最近公共祖先","uri":"/posts/p139.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉搜索树以及树中两个节点，你要找到这两个节点的最近公共祖先，然后将它返回。注意，树上所有的节点值都不相同。 比如说，给你的二叉搜索树为： 4 / \\ 2 5 / \\ \\ 1 3 6 节点 1 和 3 的最近公共祖先是节点 2； 节点 3 和 6 的最近公共祖先是节点 4； 节点 4 和 6 的最近公共祖先也是节点 4。 2 LeetCode 235. 二叉搜索树的最近公共祖先 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p139.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P139. 二叉搜索树中节点的最近公共祖先","uri":"/posts/p139.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个函数 rand7()，它能等概率地生成 1～7 之间的随机数，你要用它实现 rand10()，这个函数可以等概率地生成 1～10 之间的随机数。","date":"2025-05-05","objectID":"/posts/p140.%E7%94%A8rand7%E5%AE%9E%E7%8E%B0rand10/","tags":["AlgoCasts","LeetCode"],"title":"P140. 用 rand7() 实现 rand10()","uri":"/posts/p140.%E7%94%A8rand7%E5%AE%9E%E7%8E%B0rand10/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个函数 rand7()，它能等概率地生成 1～7 之间的随机数，你要用它实现 rand10()，这个函数可以等概率地生成 1～10 之间的随机数。 2 LeetCode 470. 用 Rand7() 实现 Rand10() 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p140.%E7%94%A8rand7%E5%AE%9E%E7%8E%B0rand10/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P140. 用 rand7() 实现 rand10()","uri":"/posts/p140.%E7%94%A8rand7%E5%AE%9E%E7%8E%B0rand10/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉搜索树，你要把它转换为一棵较大树 (Greater Tree)。转换方法是，将二叉搜索树中每个节点值更新为它与所有大于它的节点值之和。","date":"2025-05-05","objectID":"/posts/p141.%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E4%B8%BA%E8%BE%83%E5%A4%A7%E6%A0%91/","tags":["AlgoCasts","LeetCode"],"title":"P141. 将二叉搜索树转为较大树","uri":"/posts/p141.%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E4%B8%BA%E8%BE%83%E5%A4%A7%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉搜索树，你要把它转换为一棵较大树 (Greater Tree)。转换方法是，将二叉搜索树中每个节点值更新为它与所有大于它的节点值之和。 比如说，给你的二叉搜索树是： 4 / \\ 2 5 / \\ \\ 1 3 6 转换后的较大树为： 15 / \\ 20 11 / \\ \\ 21 18 6 可以看出，较大树的结构和原始二叉搜索树一样，而节点值等于原始二叉树中该节点的值加上所有比它大的节点值。 2 LeetCode 538. 把二叉搜索树转换为累加树 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p141.%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E4%B8%BA%E8%BE%83%E5%A4%A7%E6%A0%91/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P141. 将二叉搜索树转为较大树","uri":"/posts/p141.%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E4%B8%BA%E8%BE%83%E5%A4%A7%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个大小为 n 的整数数组，数组中的数字都大于等于 1 并且小于等于 n。你要找出 1 ~ n 这 n 个数字中，没有出现在数组里的数字。","date":"2025-05-05","objectID":"/posts/p137.%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%89%80%E6%9C%89%E6%95%B0%E5%AD%97/","tags":["AlgoCasts","LeetCode"],"title":"P137. 缺失的所有数字","uri":"/posts/p137.%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%89%80%E6%9C%89%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个大小为 n 的整数数组，数组中的数字都大于等于 1 并且小于等于 n。你要找出 1 ~ n 这 n 个数字中，没有出现在数组里的数字。 比如说，给你的数组是： 1, 1, 4, 2, 4, 6 这个数组的长度是 6，因此你要返回 1 ~ 6 这 6 个数字里，没有在数组中出现的数字，也就是 [3, 5]。 2 LeetCode 448. 找到所有数组中消失的数字 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p137.%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%89%80%E6%9C%89%E6%95%B0%E5%AD%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P137. 缺失的所有数字","uri":"/posts/p137.%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%89%80%E6%9C%89%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树以及树中两个节点，你要找到这两个节点的最近公共祖先，然后将它返回。","date":"2025-05-05","objectID":"/posts/p138.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","tags":["AlgoCasts","LeetCode"],"title":"P138. 二叉树中节点的最近公共祖先","uri":"/posts/p138.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树以及树中两个节点，你要找到这两个节点的最近公共祖先，然后将它返回。 比如说，给你的二叉树是： 1 / \\ 2 3 / \\ \\ 4 5 6 节点 4 和 5 的最近公共祖先是节点 2； 节点 5 和 6 的最近公共祖先是节点 1； 节点 1 和 6 的最近公共祖先也是节点 1。 2 LeetCode 236. 二叉树的最近公共祖先 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p138.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P138. 二叉树中节点的最近公共祖先","uri":"/posts/p138.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组 a，如果数组中前面的一个数字比后面某个数字的 2 倍还要大，那么这两个数字构成一个重要逆序对。也就是说，对于下标 i 和 j，如果 i \u003c j 且 a(i) \u003e 2*a(j) ，则 a(i) 和 a(j) 构成一个重要逆序对。你要计算出数组里重要逆序对的数量。","date":"2025-05-05","objectID":"/posts/p134.%E9%87%8D%E8%A6%81%E9%80%86%E5%BA%8F%E5%AF%B9/","tags":["AlgoCasts","LeetCode"],"title":"P134. 重要逆序对","uri":"/posts/p134.%E9%87%8D%E8%A6%81%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组 a，如果数组中前面的一个数字比后面某个数字的 2 倍还要大，那么这两个数字构成一个重要逆序对。也就是说，对于下标 i 和 j，如果 i \u003c j 且 a(i) \u003e 2*a(j) ，则 a(i) 和 a(j) 构成一个重要逆序对。你要计算出数组里重要逆序对的数量。 比如说，给你的数组 a 是： 8, 2, 4, 1 这个数组中有 3 个重要逆序对。分别是： (8, 2), (8, 1), (4, 1), 于是你要返回 3。 如果给你的数组是： 1, 2, 4, 8 这个数组是递增的，前面数字比后面某个数字的 2 倍要大这种情况是不可能存在的，因此重要逆序对的数量为 0。 2 LeetCode 493. 翻转对 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p134.%E9%87%8D%E8%A6%81%E9%80%86%E5%BA%8F%E5%AF%B9/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P134. 重要逆序对","uri":"/posts/p134.%E9%87%8D%E8%A6%81%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组，数组中有两个数字只出现一次，而其他数字都正好出现两次。你要找到这两个只出现一次的数字。","date":"2025-05-05","objectID":"/posts/p135.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/","tags":["AlgoCasts","LeetCode"],"title":"P135. 只出现一次的两个数字","uri":"/posts/p135.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组，数组中有两个数字只出现一次，而其他数字都正好出现两次。你要找到这两个只出现一次的数字。 比如说，给你的数组是： 2, 4, 2, 1, 4, 8 在这个数组中，1 和 8 只出现一次，其他的数字都出现了两次。因此你要返回 1 和 8： 1, 8 这里返回两个数字的顺序并不重要，因此你返回 [8, 1] 也是正确的。 2 LeetCode 260. 只出现一次的数字 III 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p135.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P135. 只出现一次的两个数字","uri":"/posts/p135.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个英文句子，你要翻转句子中单词的顺序。注意，句子中的标点视为单词的一部分。原始句子的开头和结尾可能包含多余的空格，并且相邻单词之间也可能有多个空格。在翻转单词顺序后，句子的开头和结尾不能包含多余的空格，并且相邻单词之间也只允许有一个空格。","date":"2025-05-05","objectID":"/posts/p136.%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/","tags":["AlgoCasts","LeetCode"],"title":"P136. 翻转单词顺序","uri":"/posts/p136.%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个英文句子，你要翻转句子中单词的顺序。注意，句子中的标点视为单词的一部分。原始句子的开头和结尾可能包含多余的空格，并且相邻单词之间也可能有多个空格。在翻转单词顺序后，句子的开头和结尾不能包含多余的空格，并且相邻单词之间也只允许有一个空格。 比如说，给你的句子是： \" hi, how are you? \" 这个句子的开头和结尾都有两个多余的空格，并且 how 和 are 之间也是两个空格。 把这几个单词翻转顺序后，得到： \"you? are how hi,\" 可以看到，翻转单词后的句子开头和结尾都不包含多余的空格，并且相邻单词之间只有一个空格。另外，标点符号也跟着邻接的单词一起移动。 2 LeetCode 151. 反转字符串中的单词 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p136.%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P136. 翻转单词顺序","uri":"/posts/p136.%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个只包含小写字母的字符串，你要找到第一个只出现一次的字符，并返回它的下标。如果字符串中所有字符都不只出现一次，则返回 -1。","date":"2025-05-05","objectID":"/posts/p132.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/","tags":["AlgoCasts","LeetCode"],"title":"P132. 第一个只出现一次的字符","uri":"/posts/p132.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个只包含小写字母的字符串，你要找到第一个只出现一次的字符，并返回它的下标。如果字符串中所有字符都不只出现一次，则返回 -1。 比如说，给你的字符串是： apple 第一个只出现一次的字符是 a，于是你要返回它的下标 0。 如果给你的字符串是： noon 这个字符串中的两个字符 o 和 n 都不只出现一次，因此返回 -1。 2 LeetCode 387. 字符串中的第一个唯一字符 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p132.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P132. 第一个只出现一次的字符","uri":"/posts/p132.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组 a，如果数组中前面的一个数字大于后面的一个数字，那么这两个数字构成一个逆序对。也就是说，对于下标 i 和 j，如果 i \u003c j 且 a(i) \u003e a(j) ，则 a(i) 和 a(j) 构成一个逆序对。你要计算出数组中逆序对的数量。","date":"2025-05-05","objectID":"/posts/p133.%E9%80%86%E5%BA%8F%E5%AF%B9/","tags":["AlgoCasts","LeetCode"],"title":"P133. 逆序对","uri":"/posts/p133.%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组 a，如果数组中前面的一个数字大于后面的一个数字，那么这两个数字构成一个逆序对。也就是说，对于下标 i 和 j，如果 i \u003c j 且 a(i) \u003e a(j) ，则 a(i) 和 a(j) 构成一个逆序对。你要计算出数组中逆序对的数量。 比如说，给你的数组 a 是： 8, 2, 4, 1 这个数组中有 5 个逆序对。分别是： (8, 2), (8, 4), (8, 1), (2, 1), (4, 1), 于是你要返回 5。 如果给你的数组是： 1, 2, 4, 8 这个数组是递增的，不存在前面的数字大于后面数字的情况，因此逆序对的数量为 0。 2 LeetCode 无 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p133.%E9%80%86%E5%BA%8F%E5%AF%B9/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P133. 逆序对","uri":"/posts/p133.%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两个不包含重复元素的数组，你要判断它们是否可以组成一对合法的入栈出栈序列。","date":"2025-05-05","objectID":"/posts/p129.%E9%AA%8C%E8%AF%81%E5%85%A5%E6%A0%88%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97/","tags":["AlgoCasts","LeetCode"],"title":"P129. 验证入栈出栈序列","uri":"/posts/p129.%E9%AA%8C%E8%AF%81%E5%85%A5%E6%A0%88%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两个不包含重复元素的数组，你要判断它们是否可以组成一对合法的入栈出栈序列。 比如说，给你的入栈序列是： 1, 2, 3, 4, 5 给你的出栈序列是： 4, 5, 3, 2, 1 根据入栈序列，我们可以先把 1,2,3,4 入栈，然后把 4 出栈，我们就得到出栈序列中的第 0 个元素 4： 4, 5, 3, 2, 1 接着入栈 5，然后把 5 出栈，我们就得到出栈序列中的第 1 个元素 5： 4, 5, 3, 2, 1 接下来再依次出栈 3,2,1，也就得到出栈序列中最后 3 个数字： 4, 5, 3, 2, 1 因此，这两个数组是一对合法的入栈出栈序列。 2 LeetCode 946. 验证栈序列 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p129.%E9%AA%8C%E8%AF%81%E5%85%A5%E6%A0%88%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P129. 验证入栈出栈序列","uri":"/posts/p129.%E9%AA%8C%E8%AF%81%E5%85%A5%E6%A0%88%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个不包含重复数字的数组，你要验证它是否为某棵二叉搜索树的前序遍历序列。","date":"2025-05-05","objectID":"/posts/p130.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/","tags":["AlgoCasts","LeetCode"],"title":"P130. 验证二叉搜索树的前序遍历序列","uri":"/posts/p130.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个不包含重复数字的数组，你要验证它是否为某棵二叉搜索树的前序遍历序列。 比如说，给你的数组是： 4, 1, 0, 2, 8 它是以下二叉搜索树的前序遍历序列，因此要返回 true。 4 / \\ 1 8 / \\ 0 2 2 LeetCode 无 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p130.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P130. 验证二叉搜索树的前序遍历序列","uri":"/posts/p130.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树和一个整数，你要找到这棵二叉树上从根到叶子节点路径和等于这个整数的所有路径。","date":"2025-05-05","objectID":"/posts/p131.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/","tags":["AlgoCasts","LeetCode"],"title":"P131. 二叉树中和为给定值的路径","uri":"/posts/p131.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树和一个整数，你要找到这棵二叉树上从根到叶子节点路径和等于这个整数的所有路径。 比如说，给你的二叉树是： 1 / \\ 2 4 \\ / \\ 10 8 16 给你的整数是 13。 在这棵二叉树中存在两条从根到叶子节点的路径，它们的路径和等于 13。分别是： [ [1, 2, 10], [1, 4, 8] ] 因此你要返回以上两条路径。 2 LeetCode 113. 路径总和 II 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p131.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P131. 二叉树中和为给定值的路径","uri":"/posts/p131.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你要写一个函数来删除单链表中的一个节点，并且只给你指向那个节点的指针。其中，这个单链表至少有两个节点，并且不会要求你删除尾节点。","date":"2025-05-05","objectID":"/posts/p126.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/","tags":["AlgoCasts","LeetCode"],"title":"P126. 删除链表节点","uri":"/posts/p126.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你要写一个函数来删除单链表中的一个节点，并且只给你指向那个节点的指针。其中，这个单链表至少有两个节点，并且不会要求你删除尾节点。 比如说，给你的单链表是： 0 -\u003e 1 -\u003e 2 -\u003e 4 -\u003e 8 同时给你一个指针 p，指向节点 2： 0 -\u003e 1 -\u003e 2 -\u003e 4 -\u003e 8 p 删除节点 2 后，这条链表变成： 0 -\u003e 1 -\u003e 4 -\u003e 8 2 LeetCode 237. 删除链表中的节点 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p126.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P126. 删除链表节点","uri":"/posts/p126.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个不为空的旋转有序数组，数组中不包含重复数字，你要找到这个数组中的最小值并返回它。旋转有序数组是由一个原来有序的数组通过左旋或右旋部分数字到另一端形成的。注意，这里我们讨论的有序默认都指递增排序。","date":"2025-05-05","objectID":"/posts/p127.%E6%97%8B%E8%BD%AC%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/","tags":["AlgoCasts","LeetCode"],"title":"P127. 旋转有序数组的最小值","uri":"/posts/p127.%E6%97%8B%E8%BD%AC%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个不为空的旋转有序数组，数组中不包含重复数字，你要找到这个数组中的最小值并返回它。旋转有序数组是由一个原来有序的数组通过左旋或右旋部分数字到另一端形成的。注意，这里我们讨论的有序默认都指递增排序。 比如说，原来的有序数组是 0, 1, 2, 4, 8，把 0, 1 旋转到数组右边，得到的数组 a 是： 2, 4, 8, 0, 1 在这个数组中，最小值是 0，因此你要返回 0。 2 LeetCode 153. 寻找旋转排序数组中的最小值 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p127.%E6%97%8B%E8%BD%AC%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P127. 旋转有序数组的最小值","uri":"/posts/p127.%E6%97%8B%E8%BD%AC%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个 m x n 的矩阵，你要对它进行螺旋遍历，然后返回遍历结果。","date":"2025-05-05","objectID":"/posts/p128.%E7%9F%A9%E9%98%B5%E7%9A%84%E8%9E%BA%E6%97%8B%E9%81%8D%E5%8E%86/","tags":["AlgoCasts","LeetCode"],"title":"P128. 矩阵的螺旋遍历","uri":"/posts/p128.%E7%9F%A9%E9%98%B5%E7%9A%84%E8%9E%BA%E6%97%8B%E9%81%8D%E5%8E%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个 m x n 的矩阵，你要对它进行螺旋遍历，然后返回遍历结果。 比如说给你的矩阵 a 是： 1, 2, 3 4, 5, 6 7, 8, 9 螺旋遍历它得到： 1, 2, 3, 6, 9, 8, 7, 4, 5 因此你要返回以上序列。 2 LeetCode 54. 螺旋矩阵 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p128.%E7%9F%A9%E9%98%B5%E7%9A%84%E8%9E%BA%E6%97%8B%E9%81%8D%E5%8E%86/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P128. 矩阵的螺旋遍历","uri":"/posts/p128.%E7%9F%A9%E9%98%B5%E7%9A%84%E8%9E%BA%E6%97%8B%E9%81%8D%E5%8E%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你有 n 门课要上，课程编号从 0 到 n-1。在上某些课之前你需要先上另外一些课程，这种依赖关系可以用一个数对来表示。比如 (0,1) 数对表示在上课程 0 之前，你需要先上课程 1。现在给你 n 门课以及它们之间的依赖关系，你要判断是否有可能上完所有课程。","date":"2025-05-05","objectID":"/posts/p124.%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92/","tags":["AlgoCasts","LeetCode"],"title":"P124. 课程安排","uri":"/posts/p124.%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你有 n 门课要上，课程编号从 0 到 n-1。在上某些课之前你需要先上另外一些课程，这种依赖关系可以用一个数对来表示。比如 (0,1) 数对表示在上课程 0 之前，你需要先上课程 1。现在给你 n 门课以及它们之间的依赖关系，你要判断是否有可能上完所有课程。 比如说，给你的课程数量 n 等于 5： n = 5 课程之间的依赖关系是： (1, 0) (3, 0) (3, 1) (2, 1) (2, 3) (4, 2) (4, 3) 我们只要按照 0, 1, 3, 2, 4 的顺序来排课，就可以在满足依赖关系的条件下完成这 5 门课。因此返回 true。 提示：上述依赖关系可以转成以下有向图 0 ---\u003e 3 ---\u003e 4 \\ ^ \\ ^ \\ / \\ / v/ v/ 1 ---\u003e 2 2 LeetCode 207. 课程表 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p124.%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P124. 课程安排","uri":"/posts/p124.%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你有 n 门课要上，课程编号从 0 到 n-1。在上某些课之前你需要先上另外一些课程，这种依赖关系可以用一个数对来表示。比如 (0,1) 数对表示在上课程 0 之前，需要先上课程 1。现在给你 n 门课以及它们之间的依赖关系，你要计算出完成这 n 门课程的一个上课顺序。如果有多个可行顺序，只要返回其中一个即可。如果无法上完所有课程，则返回一个空数组。","date":"2025-05-05","objectID":"/posts/p125.%E4%B8%8A%E8%AF%BE%E9%A1%BA%E5%BA%8F/","tags":["AlgoCasts","LeetCode"],"title":"P125. 上课顺序","uri":"/posts/p125.%E4%B8%8A%E8%AF%BE%E9%A1%BA%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你有 n 门课要上，课程编号从 0 到 n-1。在上某些课之前你需要先上另外一些课程，这种依赖关系可以用一个数对来表示。比如 (0,1) 数对表示在上课程 0 之前，需要先上课程 1。现在给你 n 门课以及它们之间的依赖关系，你要计算出完成这 n 门课程的一个上课顺序。如果有多个可行顺序，只要返回其中一个即可。如果无法上完所有课程，则返回一个空数组。 比如说，给你的课程数量 n 等于 5： n = 5 课程之间的依赖关系是： (1, 0) (3, 0) (3, 1) (2, 1) (2, 3) (4, 2) (4, 3) 我们只要按照 0, 1, 3, 2, 4 的顺序来上课，就可以在满足依赖关系的条件下完成这 5 门课。因此返回这个数组： [0, 1, 3, 2, 4] 提示：上述依赖关系可以转成以下有向图 0 ---\u003e 3 ---\u003e 4 \\ ^ \\ ^ \\ / \\ / v/ v/ 1 ---\u003e 2 2 LeetCode 210. 课程表 II 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p125.%E4%B8%8A%E8%AF%BE%E9%A1%BA%E5%BA%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P125. 上课顺序","uri":"/posts/p125.%E4%B8%8A%E8%AF%BE%E9%A1%BA%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数 n，你要计算出 1 到 n 这 n 个整数中，数字 1 出现的次数。","date":"2025-05-05","objectID":"/posts/p121.%E6%95%B4%E6%95%B01%E5%88%B0n%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P121. 整数 1 到 n 中 1 出现的次数","uri":"/posts/p121.%E6%95%B4%E6%95%B01%E5%88%B0n%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数 n，你要计算出 1 到 n 这 n 个整数中，数字 1 出现的次数。 比如说，给你的整数 n 等于 12： n = 12 1 到 12 中包含数字 1 的整数有： 1, 10, 11, 12 这里面数字 1 出现了 5 次，因此你要返回 5。 2 LeetCode 233. 数字 1 的个数 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p121.%E6%95%B4%E6%95%B01%E5%88%B0n%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P121. 整数 1 到 n 中 1 出现的次数","uri":"/posts/p121.%E6%95%B4%E6%95%B01%E5%88%B0n%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你要使用栈来实现一个队列，需要实现队列中常用的 4 个函数。其中，push 函数往队尾加入一个元素；pop 函数把队首元素移除；peek 函数返回队首元素；empty 函数返回队列是否为空。另外你的实现不需要考虑异常操作情况，比如从一个空队列里 pop 元素。","date":"2025-05-05","objectID":"/posts/p122.%E4%BD%BF%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","tags":["AlgoCasts","LeetCode"],"title":"P122. 使用栈实现队列","uri":"/posts/p122.%E4%BD%BF%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你要使用栈来实现一个队列，需要实现队列中常用的 4 个函数。其中，push 函数往队尾加入一个元素；pop 函数把队首元素移除；peek 函数返回队首元素；empty 函数返回队列是否为空。另外你的实现不需要考虑异常操作情况，比如从一个空队列里 pop 元素。 2 LeetCode 232. 用栈实现队列 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p122.%E4%BD%BF%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P122. 使用栈实现队列","uri":"/posts/p122.%E4%BD%BF%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树，你要将它拍平，使得每个节点都只有右子树，并且拍平后的二叉树从上到下的节点是原二叉树前序遍历的结果。","date":"2025-05-05","objectID":"/posts/p123.%E6%8B%8D%E5%B9%B3%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":["AlgoCasts","LeetCode"],"title":"P123. 拍平二叉树","uri":"/posts/p123.%E6%8B%8D%E5%B9%B3%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树，你要将它拍平，使得每个节点都只有右子树，并且拍平后的二叉树从上到下的节点是原二叉树前序遍历的结果。 比如说，给你的二叉树是： 0 / \\ 1 2 / \\ \\ 4 8 16 将它拍平后，得到的二叉树是： 0 \\ 1 \\ 4 \\ 8 \\ 2 \\ 16 2 LeetCode 114. 二叉树展开为链表 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p123.%E6%8B%8D%E5%B9%B3%E4%BA%8C%E5%8F%89%E6%A0%91/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P123. 拍平二叉树","uri":"/posts/p123.%E6%8B%8D%E5%B9%B3%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个非负整数 n，你要写一个函数返回第 n 个斐波那契数。其中斐波那契数列最开始的两项是 0 和 1，后面任意一项都是它前面两个数字之和。","date":"2025-05-05","objectID":"/posts/p118.%E7%AC%ACn%E4%B8%AA%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P118. 第 n 个斐波那契数","uri":"/posts/p118.%E7%AC%ACn%E4%B8%AA%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个非负整数 n，你要写一个函数返回第 n 个斐波那契数。其中斐波那契数列最开始的两项是 0 和 1，后面任意一项都是它前面两个数字之和。 比如说，你写的函数是 f，那么就有： f(0) = 0, f(1) = 1, f(2) = 0 + 1 = 1, f(3) = 1 + 1 = 2, f(4) = 1 + 2 = 3, f(5) = 2 + 3 = 5, ... 以此类推。 2 LeetCode 509. 斐波那契数 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p118.%E7%AC%ACn%E4%B8%AA%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P118. 第 n 个斐波那契数","uri":"/posts/p118.%E7%AC%ACn%E4%B8%AA%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两棵二叉树 s 和 t，你要判断 t 是否与 s 的某一棵子树结构相同，并且节点上的值也相等。","date":"2025-05-05","objectID":"/posts/p119.%E6%A0%91t%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8E%E6%A0%91s%E7%9A%84%E5%AD%90%E6%A0%91/","tags":["AlgoCasts","LeetCode"],"title":"P119. 树 t 是否等于树 s 的子树","uri":"/posts/p119.%E6%A0%91t%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8E%E6%A0%91s%E7%9A%84%E5%AD%90%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两棵二叉树 s 和 t，你要判断 t 是否与 s 的某一棵子树结构相同，并且节点上的值也相等。 比如说，给你的第一棵树 s 是： 1 / \\ 2 4 / \\ 8 16 给你的第二棵树 t 是： 2 / \\ 8 16 t 与 s 的一棵子树相等，因此你要返回 true。如果向 s 中再加一个节点 0： 1 / \\ 2 4 / \\ 8 16 / 0 这个时候，t 就不等于 s 中的任何一棵子树了，因此返回 false。 2 LeetCode 572. 另一棵树的子树 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p119.%E6%A0%91t%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8E%E6%A0%91s%E7%9A%84%E5%AD%90%E6%A0%91/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P119. 树 t 是否等于树 s 的子树","uri":"/posts/p119.%E6%A0%91t%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8E%E6%A0%91s%E7%9A%84%E5%AD%90%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个非负整数 n，你要分别计算出 0 ~ n 这 n + 1 个整数的二进制表示中 1 的个数，将结果以数组的形式返回。","date":"2025-05-05","objectID":"/posts/p120.%E8%BF%9E%E7%BB%AD%E8%87%AA%E7%84%B6%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P120. 连续自然数二进制中 1 的个数","uri":"/posts/p120.%E8%BF%9E%E7%BB%AD%E8%87%AA%E7%84%B6%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个非负整数 n，你要分别计算出 0 ~ n 这 n + 1 个整数的二进制表示中 1 的个数，将结果以数组的形式返回。 比如说，给你的整数 n 等于 4： n = 4 你要分别计算出 0/1/2/3/4 这 5 个数的二进制表示中 1 的个数。我们先把这 5 个数的二进制表示写出来： 0: 0 1: 1 2: 10 3: 11 4: 100 于是可以得到这 5 个数二进制表示中 1 的个数分别是 0/1/1/2/1，返回这个数组即可： [0, 1, 1, 2, 1] 2 LeetCode 338. 比特位计数 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p120.%E8%BF%9E%E7%BB%AD%E8%87%AA%E7%84%B6%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P120. 连续自然数二进制中 1 的个数","uri":"/posts/p120.%E8%BF%9E%E7%BB%AD%E8%87%AA%E7%84%B6%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个不包含重复元素的整数数组，你要返回它所有可能的子集。","date":"2025-05-05","objectID":"/posts/p116.%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%90%E9%9B%86/","tags":["AlgoCasts","LeetCode"],"title":"P116. 数组的子集","uri":"/posts/p116.%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%90%E9%9B%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个不包含重复元素的整数数组，你要返回它所有可能的子集。 比如说，给你的数组是： 1, 2, 4 [1, 2, 4] 这三个数字可以形成的子集数量是 2^3 = 8 个： (), (1), (2), (4), (1, 2), (1, 4), (2, 4), (1, 2, 4) 2 LeetCode 78. 子集 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p116.%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%90%E9%9B%86/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P116. 数组的子集","uri":"/posts/p116.%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%90%E9%9B%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个二维字符矩阵和一个单词，矩阵中的字符可以和它上/下/左/右的字符连接起来形成单词，并且每个位置的字符不能重复使用。你要判断给你的单词是否存在于字符矩阵中。","date":"2025-05-05","objectID":"/posts/p117.%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D/","tags":["AlgoCasts","LeetCode"],"title":"P117. 搜索单词","uri":"/posts/p117.%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个二维字符矩阵和一个单词，矩阵中的字符可以和它上/下/左/右的字符连接起来形成单词，并且每个位置的字符不能重复使用。你要判断给你的单词是否存在于字符矩阵中。 比如说，给你的字符矩阵是： a, a, c, b i, r, a, r b, e, y, r 给你的单词是 car。car 存在于字符矩阵中，因此返回 true。 如果给你的单词是 cab，cab 不存在于字符矩阵中，因此返回 false。 2 LeetCode 79. 单词搜索 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p117.%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P117. 搜索单词","uri":"/posts/p117.%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个 n x n 的二维数组，你要沿顺时针方向将它旋转 90 度。要求你不能使用额外的存储空间，就地在原数组操作。","date":"2025-05-05","objectID":"/posts/p113.%E6%97%8B%E8%BD%AC%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/","tags":["AlgoCasts","LeetCode"],"title":"P113. 旋转二维数组","uri":"/posts/p113.%E6%97%8B%E8%BD%AC%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个 n x n 的二维数组，你要沿顺时针方向将它旋转 90 度。要求你不能使用额外的存储空间，就地在原数组操作。 比如说，给你的二维数组是： 1, 2, 3 4, 5, 6 7, 8, 9 顺时针旋转 90 度后，得到的二维数组是： 7, 4, 1 8, 5, 2 9, 6, 3 2 LeetCode 48. 旋转图像 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p113.%E6%97%8B%E8%BD%AC%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P113. 旋转二维数组","uri":"/posts/p113.%E6%97%8B%E8%BD%AC%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个字符串 J，里面包含不同的大小写字母，表示不同的珠宝。再给你一个字符串 S 表示一堆石头，你要计算出 S 中包含的珠宝数量。","date":"2025-05-05","objectID":"/posts/p114.%E7%9F%B3%E5%A4%B4%E4%B8%AD%E7%9A%84%E7%8F%A0%E5%AE%9D%E6%95%B0%E9%87%8F/","tags":["AlgoCasts","LeetCode"],"title":"P114. 石头中的珠宝数量","uri":"/posts/p114.%E7%9F%B3%E5%A4%B4%E4%B8%AD%E7%9A%84%E7%8F%A0%E5%AE%9D%E6%95%B0%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个字符串 J，里面包含不同的大小写字母，表示不同的珠宝。再给你一个字符串 S 表示一堆石头，你要计算出 S 中包含的珠宝数量。 比如说，给你的字符串 J 是： J = \"aBc\" 这三个不同的字符表示三种不同的珠宝。给你的字符串 S 是： S = \"aabbB\" 字符串 S 中的珠宝有两个 a 和一个 B 共 3 个，因此你要返回数字 3。 2 LeetCode 771. 宝石与石头 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p114.%E7%9F%B3%E5%A4%B4%E4%B8%AD%E7%9A%84%E7%8F%A0%E5%AE%9D%E6%95%B0%E9%87%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P114. 石头中的珠宝数量","uri":"/posts/p114.%E7%9F%B3%E5%A4%B4%E4%B8%AD%E7%9A%84%E7%8F%A0%E5%AE%9D%E6%95%B0%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个字符串数组，你要把变位词划分到一组。其中，字符串只由小写字母组成。变位词指的是使用相同字母以不同顺序构成的单词。","date":"2025-05-05","objectID":"/posts/p115.%E5%8F%98%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/","tags":["AlgoCasts","LeetCode"],"title":"P115. 变位词分组","uri":"/posts/p115.%E5%8F%98%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个字符串数组，你要把变位词划分到一组。其中，字符串只由小写字母组成。变位词指的是使用相同字母以不同顺序构成的单词。 比如说，给你的字符串数组是： [\"eat\", \"tea\", \"ten\", \"ate\", \"net\"] 将变位词分到一组，我们可以得到两个分组： [\"eat\", \"tea\", \"ate\"] [\"ten\", \"net\"] 2 LeetCode 49. 字母异位词分组 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p115.%E5%8F%98%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P115. 变位词分组","uri":"/posts/p115.%E5%8F%98%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个数组和一个数字 k，你要把数组右边的数字旋转到数组左边，一次旋转一个数字，共旋转 k 次。","date":"2025-05-05","objectID":"/posts/p110.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/","tags":["AlgoCasts","LeetCode"],"title":"P110. 旋转数组","uri":"/posts/p110.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个数组和一个数字 k，你要把数组右边的数字旋转到数组左边，一次旋转一个数字，共旋转 k 次。 比如说，给你的数组是： 0, 1, 2, 4, 8 给你的数字 k 是 3： k = 3 把数组右边的数字一个个旋转到左边，操作 3 次。先是 8，然后 4，最后是 2。剩下的 0 和 1 保持不动。最后得到旋转后的数组是： 2, 4, 8, 0, 1 2 LeetCode 189. 轮转数组 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p110.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P110. 旋转数组","uri":"/posts/p110.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个单链表和一个数字 k，你要把链表右边的节点旋转到链表左边，共旋转 k 次。","date":"2025-05-05","objectID":"/posts/p111.%E6%97%8B%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/","tags":["AlgoCasts","LeetCode"],"title":"P111. 旋转单链表","uri":"/posts/p111.%E6%97%8B%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个单链表和一个数字 k，你要把链表右边的节点旋转到链表左边，共旋转 k 次。 比如说，给你的单链表是： 0 -\u003e 1 -\u003e 2 -\u003e 4 -\u003e 8 给你的数字 k 是 3： k = 3 把链表右边的节点一个个旋转到左边，操作 3 次。先是节点 8，然后是节点 4，最后是节点 2。 剩下的节点 0 和 1 保持不动。最后得到旋转后的链表是： 2 -\u003e 4 -\u003e 8 -\u003e 0 -\u003e 1 2 LeetCode 61. 旋转链表 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p111.%E6%97%8B%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P111. 旋转单链表","uri":"/posts/p111.%E6%97%8B%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个正整数数组，数组中不包含重复元素，同时给你一个正整数目标值，你要找到数组中和为目标值的所有组合。另外，数组中每个元素都可以使用无限多次，并且答案中不能包含重复组合。","date":"2025-05-05","objectID":"/posts/p112.%E6%B1%82%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E7%BB%84%E5%90%88/","tags":["AlgoCasts","LeetCode"],"title":"P112. 求和为给定值的组合","uri":"/posts/p112.%E6%B1%82%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E7%BB%84%E5%90%88/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个正整数数组，数组中不包含重复元素，同时给你一个正整数目标值，你要找到数组中和为目标值的所有组合。另外，数组中每个元素都可以使用无限多次，并且答案中不能包含重复组合。 比如说，给你的数组是： 4, 2, 8 给你的目标值是 6。数组中和为 6 的组合有： [4, 2] [2, 2, 2] 2 LeetCode 39. 组合总和 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p112.%E6%B1%82%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E7%BB%84%E5%90%88/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P112. 求和为给定值的组合","uri":"/posts/p112.%E6%B1%82%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E7%BB%84%E5%90%88/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个非负整数数组表示的高度图，你要计算出下雨后，这个高度图中可以盛多少水。","date":"2025-05-05","objectID":"/posts/p108.%E9%9B%A8%E5%90%8E%E7%9B%9B%E6%B0%B4%E9%87%8F/","tags":["AlgoCasts","LeetCode"],"title":"P108. 雨后盛水量","uri":"/posts/p108.%E9%9B%A8%E5%90%8E%E7%9B%9B%E6%B0%B4%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个非负整数数组表示的高度图，你要计算出下雨后，这个高度图中可以盛多少水。 比如说，给你的数组是： 0, 2, 0, 4, 0, 1, 2 高度示意图： ^ | 4 + +--+ | | | 3 + | | | | | 2 + +--+ | | +--+ | | | | | | | 1 + | | | | +--+ | | | | | | | | | +--+--+--+--+--+--+--+--\u003e 0 1 2 3 4 5 6 在这个高度图中，下标 2 位置的盛水量是 2，下标 4 位置的盛水量是 2，下标 5 位置的盛水量是 1，因此总共的盛水量是： 2 + 2 + 1 = 5 2 LeetCode 42. 接雨水 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p108.%E9%9B%A8%E5%90%8E%E7%9B%9B%E6%B0%B4%E9%87%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P108. 雨后盛水量","uri":"/posts/p108.%E9%9B%A8%E5%90%8E%E7%9B%9B%E6%B0%B4%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个递增排序的数组和一个目标值，你要找到目标值在这个数组中的开始下标和结束下标。如果找不到目标值，就返回 [-1, -1]。","date":"2025-05-05","objectID":"/posts/p109.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97%E7%9A%84%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F%E4%B8%8B%E6%A0%87/","tags":["AlgoCasts","LeetCode"],"title":"P109. 有序数组中查找数字的开始和结束下标","uri":"/posts/p109.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97%E7%9A%84%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F%E4%B8%8B%E6%A0%87/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个递增排序的数组和一个目标值，你要找到目标值在这个数组中的开始下标和结束下标。如果找不到目标值，就返回 [-1, -1]。 比如说，给你的递增数组是： 1, 2, 2, 4, 4, 8, 8 给你的目标值是 2。2 在这个数组中的开始下标是 1，结束下标是 2，于是你要返回： [1, 2] 如果给你的目标值是 0，0 不在这个数组中，因此你要返回： [-1, -1] 2 LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p109.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97%E7%9A%84%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F%E4%B8%8B%E6%A0%87/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P109. 有序数组中查找数字的开始和结束下标","uri":"/posts/p109.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97%E7%9A%84%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F%E4%B8%8B%E6%A0%87/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个无向图，你要返回这个图的深拷贝。","date":"2025-05-05","objectID":"/posts/p105.%E5%9B%BE%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D/","tags":["AlgoCasts","LeetCode"],"title":"P105. 图的深拷贝","uri":"/posts/p105.%E5%9B%BE%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个无向图，你要返回这个图的深拷贝。 比如说，给你的图是： 1 --- 2 / \\ / / \\ / 4 --- 8 你要返回这个图的一份深拷贝，为了和原图区分，我们记为： 1’--- 2’ / \\ / / \\ / 4’--- 8’ 每个图节点可以表示成它的节点值以及它相邻的节点。比如这个图，可以表示成： 1: 2, 4, 8 2: 1, 8 4: 1, 8 8: 1, 2, 4 拷贝图本质上就是把这组结构再复制一遍即可。 2 LeetCode 133. 克隆图 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p105.%E5%9B%BE%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P105. 图的深拷贝","uri":"/posts/p105.%E5%9B%BE%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个非负整数数组，数组中的每个数字表示那个位置上可以向后跳的最大步数。一开始你站在下标为 0 的位置，你要判断是否可以跳到数组最后的位置。","date":"2025-05-05","objectID":"/posts/p106.%E8%B7%B3%E6%95%B0%E7%BB%84/","tags":["AlgoCasts","LeetCode"],"title":"P106. 跳数组","uri":"/posts/p106.%E8%B7%B3%E6%95%B0%E7%BB%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个非负整数数组，数组中的每个数字表示那个位置上可以向后跳的最大步数。一开始你站在下标为 0 的位置，你要判断是否可以跳到数组最后的位置。 比如说，给你的数组 a 是： 2, 4, 0, 1, 2 一开始站在下标为 0 的位置，最多能向后跳 2 步。你先跳 1 步，来到 4，再跳 3 步就到达最后的位置。所以要返回 true。 再比如说，给你的数组是： 2, 1, 0, 4 一开始如果跳 2 步，到达 0，不能再跳。一开始如果跳 1 步，到达 1，可以向后再跳 1 步。但跳 1 步后仍然到达 0，不能再跳。因此对于这个数组，你没办法跳到最后的位置，返回 false。 2 LeetCode 55. 跳跃游戏 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p106.%E8%B7%B3%E6%95%B0%E7%BB%84/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P106. 跳数组","uri":"/posts/p106.%E8%B7%B3%E6%95%B0%E7%BB%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个非负整数数组，数组中的每个数字表示那个位置上可以向后跳的最大步数。一开始你站在下标为 0 的位置，你要计算出最少需要跳几次才能到达数组最后位置。如果无法到达数组最后位置，则返回 -1。","date":"2025-05-05","objectID":"/posts/p107.%E8%B7%B3%E5%AE%8C%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%91%E8%B7%B3%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P107. 跳完数组的最少跳数","uri":"/posts/p107.%E8%B7%B3%E5%AE%8C%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%91%E8%B7%B3%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个非负整数数组，数组中的每个数字表示那个位置上可以向后跳的最大步数。一开始你站在下标为 0 的位置，你要计算出最少需要跳几次才能到达数组最后位置。如果无法到达数组最后位置，则返回 -1。 比如说，给你的数组 a 是： 2, 4, 0, 1, 2 一开始站在下标为 0 的位置，最多能向后跳 2 步。你先跳 1 步，来到 4，再跳 3 步就到达最后的位置。需要的最少跳数是 2。 再比如说，给你的数组是： 2, 1, 0, 4 一开始如果跳 2 步，到达 0，不能再跳。一开始如果跳 1 步，到达 1，可以向后再跳 1 步。但跳 1 步后仍然到达 0，不能再跳。因此对于这个数组，你没办法跳到最后的位置，返回 -1。 2 LeetCode 45. 跳跃游戏 II 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p107.%E8%B7%B3%E5%AE%8C%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%91%E8%B7%B3%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P107. 跳完数组的最少跳数","uri":"/posts/p107.%E8%B7%B3%E5%AE%8C%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%91%E8%B7%B3%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个单链表，链表上每个节点都包含一个随机指针，随机指针可能为空，也可能指向这条链表上任意节点。你要写一个函数，对这条链表进行深拷贝。","date":"2025-05-05","objectID":"/posts/p102.%E5%90%AB%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8%E6%8B%B7%E8%B4%9D/","tags":["AlgoCasts","LeetCode"],"title":"P102. 含随机指针的链表拷贝","uri":"/posts/p102.%E5%90%AB%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8%E6%8B%B7%E8%B4%9D/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个单链表，链表上每个节点都包含一个随机指针，随机指针可能为空，也可能指向这条链表上任意节点。你要写一个函数，对这条链表进行深拷贝。 2 LeetCode 138. 随机链表的复制 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p102.%E5%90%AB%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8%E6%8B%B7%E8%B4%9D/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P102. 含随机指针的链表拷贝","uri":"/posts/p102.%E5%90%AB%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8%E6%8B%B7%E8%B4%9D/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两个字符串 s 和 t，你要在 s 中找到一个最短子串，它包含 t 中所有的字符。如果找不到满足条件的子串，就返回空字符串。","date":"2025-05-05","objectID":"/posts/p103.%E5%8C%85%E5%90%AB%E7%BB%99%E5%AE%9A%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E4%B8%B2/","tags":["AlgoCasts","LeetCode"],"title":"P103. 包含给定字符的最短子串","uri":"/posts/p103.%E5%8C%85%E5%90%AB%E7%BB%99%E5%AE%9A%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E4%B8%B2/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两个字符串 s 和 t，你要在 s 中找到一个最短子串，它包含 t 中所有的字符。如果找不到满足条件的子串，就返回空字符串。 比如说，给你的字符串 s 和 t 分别是： s: adbcacab t: aab 在字符串 s 中，包含 a,a,b 这三个字符的最短子串是 acab，于是你要返回它。 2 LeetCode 76. 最小覆盖子串 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p103.%E5%8C%85%E5%90%AB%E7%BB%99%E5%AE%9A%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E4%B8%B2/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P103. 包含给定字符的最短子串","uri":"/posts/p103.%E5%8C%85%E5%90%AB%E7%BB%99%E5%AE%9A%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E4%B8%B2/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个单链表和一个数字，你要把小于这个数字的节点都移到链表前面，大于等于这个数字的节点都移到链表后面。并且在较小和较大的这两堆节点中，节点之间的相对顺序保持不变。","date":"2025-05-05","objectID":"/posts/p104.%E9%93%BE%E8%A1%A8%E5%88%92%E5%88%86/","tags":["AlgoCasts","LeetCode"],"title":"P104. 链表划分","uri":"/posts/p104.%E9%93%BE%E8%A1%A8%E5%88%92%E5%88%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个单链表和一个数字，你要把小于这个数字的节点都移到链表前面，大于等于这个数字的节点都移到链表后面。并且在较小和较大的这两堆节点中，节点之间的相对顺序保持不变。 比如说，给你的单链表是： 0 -\u003e 4 -\u003e 2 -\u003e 1 -\u003e 8 -\u003e 1 给你的数字是 2。小于 2 的节点有 0/1/1 共 3 个，大于等于 2 的节点有 4/2/8 共 3 个。因此重新划分后得到的链表是： 0 -\u003e 1 -\u003e 1 -\u003e 4 -\u003e 2 -\u003e 8 可以看到，较小的那一堆 0/1/1 三个节点保持了在原链表中的相对顺序，较大的那一堆 4/2/8 三个节点也保持了在原链表中的相对顺序。 2 LeetCode 86. 分隔链表 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p104.%E9%93%BE%E8%A1%A8%E5%88%92%E5%88%86/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P104. 链表划分","uri":"/posts/p104.%E9%93%BE%E8%A1%A8%E5%88%92%E5%88%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个包含左括号和右括号的字符串，你要找到能形成有效括号组合的最长子串，然后返回它的长度。","date":"2025-05-05","objectID":"/posts/p100.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6/","tags":["AlgoCasts","LeetCode"],"title":"P100. 有效括号的最大长度","uri":"/posts/p100.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个包含左括号和右括号的字符串，你要找到能形成有效括号组合的最长子串，然后返回它的长度。 比如说，给你的括号字符串是： ) ( ( ) ( ) ) 这个字符串，从下标 1 开始，一直到最后，都是一个有效的括号组合，因此你要返回长度 6。 2 LeetCode 32. 最长有效括号 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p100.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P100. 有效括号的最大长度","uri":"/posts/p100.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个单链表，你要返回它正中间的节点。如果链表节点数量是偶数个，这个时候正中间有两个节点，你要返回它们中第二个节点。","date":"2025-05-05","objectID":"/posts/p101.%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/","tags":["AlgoCasts","LeetCode"],"title":"P101. 单链表中间节点","uri":"/posts/p101.%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个单链表，你要返回它正中间的节点。如果链表节点数量是偶数个，这个时候正中间有两个节点，你要返回它们中第二个节点。 比如说，给你的单链表是： 0 -\u003e 1 -\u003e 2 -\u003e 4 -\u003e 8 你要返回的正中间节点是 2。如果给你的链表有偶数个节点，比如： 0 -\u003e 1 -\u003e 2 -\u003e 4 正中间的节点是 1 和 2，你要返回它们中第二个节点，也就是节点 2。 2 LeetCode 876. 链表的中间结点 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p101.%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P101. 单链表中间节点","uri":"/posts/p101.%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组，每一个元素是一个 0 到 9 的整数，数组的排列形成了一个有效的数字。你要找到数组的下一个排列，使它形成的数字是大于当前排列的第一个数字。如果当前排列表示的已经是最大数字，则返回这个数组的最小排列。","date":"2025-05-05","objectID":"/posts/p97.%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/","tags":["AlgoCasts","LeetCode"],"title":"P97. 数组的下一个排列","uri":"/posts/p97.%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组，每一个元素是一个 0 到 9 的整数，数组的排列形成了一个有效的数字。你要找到数组的下一个排列，使它形成的数字是大于当前排列的第一个数字。如果当前排列表示的已经是最大数字，则返回这个数组的最小排列。 比如说，给你的数组是： 2, 1, 8, 4, 2, 1 这个排列表示整数 218421，你要返回的下一个排列是： 2, 2, 1, 1, 4, 8 表示 221148，这是数组中的元素所能组成的数字中，大于当前排列的第一个数字。 再比如说，给你的数组为： 4, 2, 1 你没有办法给出一个比它更大的排列，于是返回这些数字所能构成的最小排列： 1, 2, 4 2 LeetCode 31. 下一个排列 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p97.%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P97. 数组的下一个排列","uri":"/posts/p97.%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个非空字符串，和一个非空的字符串列表。你是否可以把这个字符串分解成若干个子串，这些子串都存在于给你的字符串列表中。","date":"2025-05-05","objectID":"/posts/p98.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E8%A7%A3/","tags":["AlgoCasts","LeetCode"],"title":"P98. 字符串分解","uri":"/posts/p98.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E8%A7%A3/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个非空字符串，和一个非空的字符串列表。你是否可以把这个字符串分解成若干个子串，这些子串都存在于给你的字符串列表中。 比如说给你的字符串是： carandcard 给你的字符串列表是： car, rand, and, d carandcard 可以被分解成 4 个部分：car, and, car 和 d，这些子串都存在于字符串列表中。因此，你要返回 true。 如果给你的字符串仍然是 carandcard，但给你的字符串列表是： car, rand, card 原字符串就无法找到一种分解，使得分解后的子串都存在于给你的字符串列表中。于是你要返回 false。 2 LeetCode 139. 单词拆分 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p98.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E8%A7%A3/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P98. 字符串分解","uri":"/posts/p98.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E8%A7%A3/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数 n，你要返回第 n 个丑数。丑数的定义是质因数只包含 2，3，5 的正整数。另外，1 作为特例，也定义为丑数。","date":"2025-05-05","objectID":"/posts/p99.%E7%AC%ACn%E4%B8%AA%E4%B8%91%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P99. 第 n 个丑数","uri":"/posts/p99.%E7%AC%ACn%E4%B8%AA%E4%B8%91%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数 n，你要返回第 n 个丑数。丑数的定义是质因数只包含 2，3，5 的正整数。另外，1 作为特例，也定义为丑数。 比如说，给你的 n=6。前 6 个丑数是： 1, 2, 3, 4, 5, 6 // 它们的质因数都只包含 2，3，5 于是你要返回第 6 个丑数 6。 2 LeetCode 264. 丑数 II 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p99.%E7%AC%ACn%E4%B8%AA%E4%B8%91%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P99. 第 n 个丑数","uri":"/posts/p99.%E7%AC%ACn%E4%B8%AA%E4%B8%91%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个单链表，你要返回这个链表中，圆环的开始节点。如果单链表无环，就返回空指针。","date":"2025-05-05","objectID":"/posts/p94.%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%9C%86%E7%8E%AF%E7%9A%84%E5%BC%80%E5%A7%8B%E8%8A%82%E7%82%B9/","tags":["AlgoCasts","LeetCode"],"title":"P94. 单链表中圆环的开始节点","uri":"/posts/p94.%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%9C%86%E7%8E%AF%E7%9A%84%E5%BC%80%E5%A7%8B%E8%8A%82%E7%82%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个单链表，你要返回这个链表中，圆环的开始节点。如果单链表无环，就返回空指针。 比如说，给你的单链表是： 1 -\u003e 2 -\u003e 4 -\u003e 8 -\u003e 2 // 最后的 2 和前面的 2 是同一个节点 这个链表中存在环，并且环的开始节点是 2，于是你要返回节点 2。 2 LeetCode 142. 环形链表 II 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p94.%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%9C%86%E7%8E%AF%E7%9A%84%E5%BC%80%E5%A7%8B%E8%8A%82%E7%82%B9/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P94. 单链表中圆环的开始节点","uri":"/posts/p94.%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%9C%86%E7%8E%AF%E7%9A%84%E5%BC%80%E5%A7%8B%E8%8A%82%E7%82%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个无序的整数数组，你要找到数组中元素能够组成的最长连续整数序列，然后返回它的长度。","date":"2025-05-05","objectID":"/posts/p95.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/","tags":["AlgoCasts","LeetCode"],"title":"P95. 最长连续整数序列的长度","uri":"/posts/p95.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个无序的整数数组，你要找到数组中元素能够组成的最长连续整数序列，然后返回它的长度。 比如说，给你的数组是 8, 4, 2, 1, 2, 3, 6，这里面的数字能够组成的最长连续整数序列是 1, 2, 3, 4，因此你要返回它的长度 4。 2 LeetCode 128. 最长连续序列 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p95.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P95. 最长连续整数序列的长度","uri":"/posts/p95.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个单链表，你要写一个函数，对它进行排序，然后返回排序后的链表。","date":"2025-05-05","objectID":"/posts/p96.%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/","tags":["AlgoCasts","LeetCode"],"title":"P96. 单链表排序","uri":"/posts/p96.%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个单链表，你要写一个函数，对它进行排序，然后返回排序后的链表。 比如说，给你的单链表是： 4 -\u003e 8 -\u003e 2 -\u003e 1 你要返回排序后的链表： 1 -\u003e 2 -\u003e 4 -\u003e 8 2 LeetCode 148. 排序链表 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p96.%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P96. 单链表排序","uri":"/posts/p96.%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉搜索树和一个数值，你要删除二叉搜索树上等于这个数值的节点，然后返回处理后的二叉搜索树。注意，二叉搜索树的节点上没有重复数值，并且要求删除节点后返回的仍然是二叉搜索树。","date":"2025-05-05","objectID":"/posts/p92.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/","tags":["AlgoCasts","LeetCode"],"title":"P92. 二叉搜索树中删除节点","uri":"/posts/p92.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉搜索树和一个数值，你要删除二叉搜索树上等于这个数值的节点，然后返回处理后的二叉搜索树。注意，二叉搜索树的节点上没有重复数值，并且要求删除节点后返回的仍然是二叉搜索树。 比如说，给你的二叉搜索树是： 1 / \\ 0 4 / \\ 2 8 给你的数值为 4。删掉 4 这个节点后，可以返回： 1 / \\ 0 2 \\ 8 也可以返回： 1 / \\ 0 8 / 2 这两个都是有效的二叉搜索树，返回其中一个即可。 2 LeetCode 450. 删除二叉搜索树中的节点 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p92.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P92. 二叉搜索树中删除节点","uri":"/posts/p92.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组和整数 k，k 表示滑动窗口的大小，滑动窗口从左向右滑过数组，每移动一个位置，你要计算出当前滑动窗口内 k 个数字的最大值。最后返回这个最大值数组。","date":"2025-05-05","objectID":"/posts/p93.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","tags":["AlgoCasts","LeetCode"],"title":"P93. 滑动窗口中的最大值","uri":"/posts/p93.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组和整数 k，k 表示滑动窗口的大小，滑动窗口从左向右滑过数组，每移动一个位置，你要计算出当前滑动窗口内 k 个数字的最大值。最后返回这个最大值数组。 比如说，给你的数组是 0, 4, 2, 1, 0, 8, 2，给你的滑动窗口大小 k 等于 3。我们使用大小为 3 的滑动窗口，来找到这个最大值序列。 * 第一个滑动窗口内的数字是 0, 4, 2，最大值为 4 * 移动窗口，窗口内数字变为 4, 2, 1，最大值仍然为 4 * 继续移动窗口，窗口内数字变为 2, 1, 0，最大值变为 2 * 接着移动窗口，窗口内数字变为 1, 0, 8，最大值变为 8 * 继续移动窗口，最后窗口内的数字变为 0, 8, 2，最大值仍然是 8 这时滑动窗口再移动的话，窗口内的数字就不足 k 个，于是结束处理过程。最后就得到了最大值数组 4, 4, 2, 8, 8。 2 LeetCode 239. 滑动窗口最大值 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p93.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P93. 滑动窗口中的最大值","uri":"/posts/p93.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组，你要找到一个最短的子数组，只要把它按递增排序，那么整个数组就变成递增有序。最后返回这个最短子数组的长度。注意，子数组要求是连续的。","date":"2025-05-05","objectID":"/posts/p89.%E9%9C%80%E8%A6%81%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/","tags":["AlgoCasts","LeetCode"],"title":"P89. 需要排序的最短子数组","uri":"/posts/p89.%E9%9C%80%E8%A6%81%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组，你要找到一个最短的子数组，只要把它按递增排序，那么整个数组就变成递增有序。最后返回这个最短子数组的长度。注意，子数组要求是连续的。 比如说，给你的数组是 0, 2, 4, 1, 8。我们至少需要把子数组 2, 4, 1 排序，变成 1, 2, 4，才能使得整个数组有序。因此要返回这个子数组的长度 3。 2 LeetCode 581. 最短无序连续子数组 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p89.%E9%9C%80%E8%A6%81%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P89. 需要排序的最短子数组","uri":"/posts/p89.%E9%9C%80%E8%A6%81%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你 K 个递增排序的单链表，你要把它们合成一个链表，并且保持递增排序。合成链表的节点直接使用 K 个链表中的节点即可，无需创建新节点。","date":"2025-05-05","objectID":"/posts/p90.%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","tags":["AlgoCasts","LeetCode"],"title":"P90. 合并 K 个有序链表","uri":"/posts/p90.%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你 K 个递增排序的单链表，你要把它们合成一个链表，并且保持递增排序。合成链表的节点直接使用 K 个链表中的节点即可，无需创建新节点。 比如说，给你以下 3 个有序链表： 1 -\u003e 2 -\u003e 4 1 -\u003e 4 -\u003e 8 0 -\u003e 2 合并后的有序链表是： 0 -\u003e 1 -\u003e 1 -\u003e 2 -\u003e 2 -\u003e 4 -\u003e 4 -\u003e 8 2 LeetCode 23. 合并 K 个升序链表 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p90.%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P90. 合并 K 个有序链表","uri":"/posts/p90.%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个旋转有序的整数数组，和一个目标值，你要在数组里找到目标值，然后返回它的下标。如果找不到则返回 -1。注意：数组中不存在重复数字。旋转有序数组是由一个原来有序的数组通过左旋或右旋部分数字到另一端形成的。注意，这里我们讨论的有序默认都指递增排序。","date":"2025-05-05","objectID":"/posts/p91.%E6%97%8B%E8%BD%AC%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E6%90%9C%E7%B4%A2/","tags":["AlgoCasts","LeetCode"],"title":"P91. 旋转有序数组的搜索","uri":"/posts/p91.%E6%97%8B%E8%BD%AC%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E6%90%9C%E7%B4%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个旋转有序的整数数组，和一个目标值，你要在数组里找到目标值，然后返回它的下标。如果找不到则返回 -1。注意：数组中不存在重复数字。旋转有序数组是由一个原来有序的数组通过左旋或右旋部分数字到另一端形成的。注意，这里我们讨论的有序默认都指递增排序。 比如说，原来的有序数组是： 1, 2, 3, 4, 5, 6, 7, 8 把 1, 2, 3, 4 旋转到数组右边，得到的数组 a 是： 5, 6, 7, 8, 1, 2, 3, 4 假如给你的目标值是 6，则要返回它的下标 1；假如给你的目标值是 0，0 不在这个数组中，因此返回 -1。 2 LeetCode 33. 搜索旋转排序数组 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p91.%E6%97%8B%E8%BD%AC%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E6%90%9C%E7%B4%A2/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P91. 旋转有序数组的搜索","uri":"/posts/p91.%E6%97%8B%E8%BD%AC%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E6%90%9C%E7%B4%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一些红色/白色/蓝色的条状物，你要排序把相同颜色的放在一起，并且整体的颜色是按照红/白/蓝的顺序排列的。这三种颜色放在一起后就形成了荷兰国旗。","date":"2025-05-05","objectID":"/posts/p86.%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/","tags":["AlgoCasts","LeetCode"],"title":"P86. 荷兰国旗问题","uri":"/posts/p86.%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一些红色/白色/蓝色的条状物，你要排序把相同颜色的放在一起，并且整体的颜色是按照红/白/蓝的顺序排列的。这三种颜色放在一起后就形成了荷兰国旗。 维基百科链接：Dutch national flag problem 比如说，我们用 0, 1, 2 表示红/白/蓝三种颜色，给你一个包含 0, 1, 2 的整数数组： 2, 1, 2, 1, 0 你要返回排序后的结果是： 0, 1, 1, 2, 2 2 LeetCode 75. 颜色分类 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p86.%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P86. 荷兰国旗问题","uri":"/posts/p86.%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个包含 0/1 字符的二维数组，字符 1 构成的连通区域表示小岛，字符 0 表示海水，你要计算二维数组中有多少个小岛。在这个题目中，元素相邻只考虑上/下/左/右 4 个元素，斜方向的元素认为是不相邻的。","date":"2025-05-05","objectID":"/posts/p87.%E5%B0%8F%E5%B2%9B%E6%95%B0%E9%87%8F/","tags":["AlgoCasts","LeetCode"],"title":"P87. 小岛数量","uri":"/posts/p87.%E5%B0%8F%E5%B2%9B%E6%95%B0%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个包含 0/1 字符的二维数组，字符 1 构成的连通区域表示小岛，字符 0 表示海水，你要计算二维数组中有多少个小岛。在这个题目中，元素相邻只考虑上/下/左/右 4 个元素，斜方向的元素认为是不相邻的。 比如说，给你的二维数组 g 是： 1 0 0 0 1 1 0 1 1 这个二维数组中，左上角的 1 是一个小岛，右下角 4 个 1 也组成了一个小岛。总共有 2 个小岛，因此你要返回的就是 2。 2 LeetCode 200. 岛屿数量 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p87.%E5%B0%8F%E5%B2%9B%E6%95%B0%E9%87%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P87. 小岛数量","uri":"/posts/p87.%E5%B0%8F%E5%B2%9B%E6%95%B0%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个加密后的非空字符串，原字符串由大写 A 到 Z 组成，加密后的字符串由数字字符组成，加密方法是把大写 A 到 Z 映射成 1 到 26。你要计算出给你的加密字符串有多少种可能的解码方式。","date":"2025-05-05","objectID":"/posts/p88.%E8%A7%A3%E7%A0%81%E6%96%B9%E5%BC%8F/","tags":["AlgoCasts","LeetCode"],"title":"P88. 解码方式","uri":"/posts/p88.%E8%A7%A3%E7%A0%81%E6%96%B9%E5%BC%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个加密后的非空字符串，原字符串由大写 A 到 Z 组成，加密后的字符串由数字字符组成，加密方法是把大写 A 到 Z 映射成 1 到 26。你要计算出给你的加密字符串有多少种可能的解码方式。 比如说，给你的加密字符串是：\"124\"。这个数字字符串有 3 种解码方式： 1. 第一种是 \"124\" 各解码成一个字符，得到 ABD 2. 第二种是 \"12\" 和 \"4\" 各解码成一个字符，得到 LD 3. 第三种是 \"1\" 和 \"24\" 各解码成一个字符，得到 AX 因此，你要返回的答案就是 3 种。 映射关系： A -\u003e 1 B -\u003e 2 ... Z -\u003e 26 2 LeetCode 91. 解码方法 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p88.%E8%A7%A3%E7%A0%81%E6%96%B9%E5%BC%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P88. 解码方式","uri":"/posts/p88.%E8%A7%A3%E7%A0%81%E6%96%B9%E5%BC%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一些面值不同的硬币，每一种面值的硬币都有无限多个，现在你要用这些硬币组成一个给定的数值，那么请问，总共有多少种可能的组合方式？","date":"2025-05-05","objectID":"/posts/p84.%E7%A1%AC%E5%B8%81%E9%9D%A2%E5%80%BC%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/","tags":["AlgoCasts","LeetCode"],"title":"P84. 硬币面值组合问题","uri":"/posts/p84.%E7%A1%AC%E5%B8%81%E9%9D%A2%E5%80%BC%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一些面值不同的硬币，每一种面值的硬币都有无限多个，现在你要用这些硬币组成一个给定的数值，那么请问，总共有多少种可能的组合方式？ 比如说，给你的硬币有 1 分 2 分两种面值，现在你要用它们凑 4 分钱，有以下 3 种组合方式： 4 = 1 + 1 + 1 + 1 4 = 1 + 1 + 2 4 = 2 + 2 因此，要返回的答案是 3。 2 LeetCode 518. 零钱兑换 II 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p84.%E7%A1%AC%E5%B8%81%E9%9D%A2%E5%80%BC%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P84. 硬币面值组合问题","uri":"/posts/p84.%E7%A1%AC%E5%B8%81%E9%9D%A2%E5%80%BC%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一些面值不同的硬币，每一种面值的硬币都有无限多个，现在你要用这些硬币组成一个给定的数值，那么请问，最少需要多少个硬币。另外，如果给你的面值无法组成给定数值，就返回 -1。","date":"2025-05-05","objectID":"/posts/p85.%E6%9C%80%E5%B0%8F%E7%A1%AC%E5%B8%81%E7%BB%84%E5%90%88/","tags":["AlgoCasts","LeetCode"],"title":"P85. 最小硬币组合","uri":"/posts/p85.%E6%9C%80%E5%B0%8F%E7%A1%AC%E5%B8%81%E7%BB%84%E5%90%88/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一些面值不同的硬币，每一种面值的硬币都有无限多个，现在你要用这些硬币组成一个给定的数值，那么请问，最少需要多少个硬币。另外，如果给你的面值无法组成给定数值，就返回 -1。 比如说，给你的硬币有 1 分 2 分两种面值，现在你要用它们凑 4 分钱。 我们知道用 1 分 2 分凑 4 分有 3 种组合： 4 = 1 + 1 + 1 + 1 4 = 1 + 1 + 2 4 = 2 + 2 其中使用了最少硬币的组合是 2 + 2，用了两个硬币，于是要返回的答案就是 2。 2 LeetCode 322. 零钱兑换 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p85.%E6%9C%80%E5%B0%8F%E7%A1%AC%E5%B8%81%E7%BB%84%E5%90%88/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P85. 最小硬币组合","uri":"/posts/p85.%E6%9C%80%E5%B0%8F%E7%A1%AC%E5%B8%81%E7%BB%84%E5%90%88/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个字符串，你要写一个函数左右反转它。然后返回反转后的字符串。","date":"2025-05-05","objectID":"/posts/p81.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","tags":["AlgoCasts","LeetCode"],"title":"P81. 反转字符串","uri":"/posts/p81.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个字符串，你要写一个函数左右反转它。然后返回反转后的字符串。 比如说给你的字符串是： abcde 你要返回左右反转后的字符串： edcba 2 LeetCode 344. 反转字符串 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p81.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P81. 反转字符串","uri":"/posts/p81.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两棵二叉树，你要把它们合并起来形成一棵新的二叉树。合并规则是对应节点上的数字相加得到新节点的数字，如果有一个节点为空，则直接使用非空节点的数字，如果两个节点都为空，则合并后也为空。","date":"2025-05-05","objectID":"/posts/p82.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":["AlgoCasts","LeetCode"],"title":"P82. 合并二叉树","uri":"/posts/p82.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两棵二叉树，你要把它们合并起来形成一棵新的二叉树。合并规则是对应节点上的数字相加得到新节点的数字，如果有一个节点为空，则直接使用非空节点的数字，如果两个节点都为空，则合并后也为空。 比如说，给你的两棵二叉树是： 1 / \\ 3 5 \\ \\ 7 9 和 2 / \\ 4 6 / 8 你要返回合并后的二叉树是： 3 / \\ 7 11 / \\ \\ 8 7 9 2 LeetCode 617. 合并二叉树 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p82.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P82. 合并二叉树","uri":"/posts/p82.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个字符串，你要写一个函数反转这个字符串中的单词，然后返回处理后的字符串。注意，单词之间只用一个空格隔开。","date":"2025-05-05","objectID":"/posts/p83.%E5%8F%8D%E8%BD%AC%E5%8D%95%E8%AF%8D/","tags":["AlgoCasts","LeetCode"],"title":"P83. 反转单词","uri":"/posts/p83.%E5%8F%8D%E8%BD%AC%E5%8D%95%E8%AF%8D/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个字符串，你要写一个函数反转这个字符串中的单词，然后返回处理后的字符串。注意，单词之间只用一个空格隔开。 比如说给你的字符串是： \"I am busy.\" 反转这个字符串中的 3 个单词，得到： \"I ma .ysub\" 注意，最后的句号要连同单词一起反转。 2 LeetCode 557. 反转字符串中的单词 III 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p83.%E5%8F%8D%E8%BD%AC%E5%8D%95%E8%AF%8D/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P83. 反转单词","uri":"/posts/p83.%E5%8F%8D%E8%BD%AC%E5%8D%95%E8%AF%8D/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组，数组中的整数表示爬对应阶楼梯的代价。你可以从第 0 阶或第 1 阶楼梯开始爬，每次可以向上爬 1 阶或 2 阶。那么请问，爬完这个楼梯的最小代价是多少？","date":"2025-05-05","objectID":"/posts/p78.%E7%88%AC%E6%A5%BC%E6%A2%AF%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7/","tags":["AlgoCasts","LeetCode"],"title":"P78. 爬楼梯的最小代价","uri":"/posts/p78.%E7%88%AC%E6%A5%BC%E6%A2%AF%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组，数组中的整数表示爬对应阶楼梯的代价。你可以从第 0 阶或第 1 阶楼梯开始爬，每次可以向上爬 1 阶或 2 阶。那么请问，爬完这个楼梯的最小代价是多少？ 比如说，给你的代价数组 c 是： 1, 2, 4, 2 爬完这个楼梯的最小代价为 4，也就是从第 1 阶（对应的代价为 2）开始，然后爬两阶就爬完了，代价是 2 + 2 = 4。 2 LeetCode 746. 使用最小花费爬楼梯 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p78.%E7%88%AC%E6%A5%BC%E6%A2%AF%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P78. 爬楼梯的最小代价","uri":"/posts/p78.%E7%88%AC%E6%A5%BC%E6%A2%AF%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组，你要计算数组里最长递增子序列的长度。其中，子序列不要求连续。","date":"2025-05-05","objectID":"/posts/p79.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/","tags":["AlgoCasts","LeetCode"],"title":"P79. 最长递增子序列的长度","uri":"/posts/p79.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组，你要计算数组里最长递增子序列的长度。其中，子序列不要求连续。 比如说，给你的数组 a 是： 1, 8, 2, 6, 4, 5 在这个数组里，最长的递增子序列是： 1, 2, 4, 5 因此你要返回它的长度 4。 2 LeetCode 300. 最长递增子序列 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p79.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P79. 最长递增子序列的长度","uri":"/posts/p79.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组，你要把数组中的 0 都移动到数组末端，同时还要保持非 0 元素的相对位置不变。另外，操作直接在原数组上进行即可。","date":"2025-05-05","objectID":"/posts/p80.%E5%90%91%E5%90%8E%E7%A7%BB%E5%8A%A80/","tags":["AlgoCasts","LeetCode"],"title":"P80. 向后移动 0","uri":"/posts/p80.%E5%90%91%E5%90%8E%E7%A7%BB%E5%8A%A80/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组，你要把数组中的 0 都移动到数组末端，同时还要保持非 0 元素的相对位置不变。另外，操作直接在原数组上进行即可。 比如说，给你的数组是： 0, 1, 2, 0, 4 把 0 都移动到数组末端，得到的数组是： 1, 2, 4, 0, 0 注意，这里 1,2,4 保持了它们在原来数组中的相对顺序。 2 LeetCode 283. 移动零 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p80.%E5%90%91%E5%90%8E%E7%A7%BB%E5%8A%A80/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P80. 向后移动 0","uri":"/posts/p80.%E5%90%91%E5%90%8E%E7%A7%BB%E5%8A%A80/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组，你要找到乘积最大的连续子序列，然后返回它的乘积。","date":"2025-05-05","objectID":"/posts/p75.%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/","tags":["AlgoCasts","LeetCode"],"title":"P75. 连续子序列的最大乘积","uri":"/posts/p75.%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组，你要找到乘积最大的连续子序列，然后返回它的乘积。 比如说，给你的数组是： 8, 1, -2, 4, -1 这个数组中连续子序列的最大乘积是 64，连续子序列就是数组本身。 2 LeetCode 152. 乘积最大子数组 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p75.%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P75. 连续子序列的最大乘积","uri":"/posts/p75.%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两个整数 m 和 n，表示的是一个 m x n 的矩阵，任何时候你只能向右或向下移动，那么从矩阵左上角移动到右下角，共有多少条不同的路径。","date":"2025-05-05","objectID":"/posts/p76.%E8%B7%AF%E5%BE%84%E6%95%B0%E9%87%8F/","tags":["AlgoCasts","LeetCode"],"title":"P76. 路径数量","uri":"/posts/p76.%E8%B7%AF%E5%BE%84%E6%95%B0%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两个整数 m 和 n，表示的是一个 m x n 的矩阵，任何时候你只能向右或向下移动，那么从矩阵左上角移动到右下角，共有多少条不同的路径。 比如说，给你的 m = 2，n = 4。简单地画出这个矩阵，使用 0 作为占位符： 0, 0, 0, 0 0, 0, 0, 0 从这个矩阵的左上角走到右下角，共有 4 条不同的路径，因此返回 4。 2 LeetCode 62. 不同路径 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p76.%E8%B7%AF%E5%BE%84%E6%95%B0%E9%87%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P76. 路径数量","uri":"/posts/p76.%E8%B7%AF%E5%BE%84%E6%95%B0%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个矩阵，矩阵元素有 0 和 1 两种值。0 表示矩阵中这个格子是空的，可以走；1 表示这个格子里有障碍物，不能走。你在这个矩阵中只能向右或向下走，那么从矩阵左上角走到右下角，共有多少条不同的路径。","date":"2025-05-05","objectID":"/posts/p77.%E8%B7%AF%E5%BE%84%E6%95%B0%E9%87%8F%E5%90%AB%E9%9A%9C%E7%A2%8D%E7%89%A9/","tags":["AlgoCasts","LeetCode"],"title":"P77. 路径数量（含障碍物）","uri":"/posts/p77.%E8%B7%AF%E5%BE%84%E6%95%B0%E9%87%8F%E5%90%AB%E9%9A%9C%E7%A2%8D%E7%89%A9/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个矩阵，矩阵元素有 0 和 1 两种值。0 表示矩阵中这个格子是空的，可以走；1 表示这个格子里有障碍物，不能走。你在这个矩阵中只能向右或向下走，那么从矩阵左上角走到右下角，共有多少条不同的路径。 比如说给你的矩阵是： 0, 0, 1, 0 0, 0, 0, 0 第 0 行的 1 表示那里有个障碍物，不能走。从这个矩阵的左上角走到右下角，共有 2 条不同的路径，因此要返回 2。 2 LeetCode 63. 不同路径 II 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p77.%E8%B7%AF%E5%BE%84%E6%95%B0%E9%87%8F%E5%90%AB%E9%9A%9C%E7%A2%8D%E7%89%A9/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P77. 路径数量（含障碍物）","uri":"/posts/p77.%E8%B7%AF%E5%BE%84%E6%95%B0%E9%87%8F%E5%90%AB%E9%9A%9C%E7%A2%8D%E7%89%A9/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个单链表，这个单链表节点上的数字是有序的。对于出现多次的数字，你要把重复的去掉，只保留一个即可。最后返回去重后的单链表。","date":"2025-05-05","objectID":"/posts/p73.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D/","tags":["AlgoCasts","LeetCode"],"title":"P73. 有序链表去重","uri":"/posts/p73.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个单链表，这个单链表节点上的数字是有序的。对于出现多次的数字，你要把重复的去掉，只保留一个即可。最后返回去重后的单链表。 比如说，给你的有序单链表是： 1 -\u003e 1 -\u003e 2 -\u003e 2 -\u003e 4 去重后，你要返回的链表是： 1 -\u003e 2 -\u003e 4 2 LeetCode 83. 删除排序链表中的重复元素 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p73.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P73. 有序链表去重","uri":"/posts/p73.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个单链表，这个单链表节点上的数字是有序的。对于出现多次的数字，你要把它们全删掉，留下只出现一次的节点，最后返回处理后的单链表。","date":"2025-05-05","objectID":"/posts/p74.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/","tags":["AlgoCasts","LeetCode"],"title":"P74. 有序链表删除重复节点","uri":"/posts/p74.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个单链表，这个单链表节点上的数字是有序的。对于出现多次的数字，你要把它们全删掉，留下只出现一次的节点，最后返回处理后的单链表。 比如说，给你的有序单链表是： 1 -\u003e 1 -\u003e 2 -\u003e 4 1 出现了多次，删掉它后，你要返回的链表是： 2 -\u003e 4 2 LeetCode 82. 删除排序链表中的重复元素 II 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p74.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P74. 有序链表删除重复节点","uri":"/posts/p74.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个包含大小写英文字母的字符串，你要用这些字母构建一个最长的回文字符串，并返回它的长度。","date":"2025-05-05","objectID":"/posts/p70.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6/","tags":["AlgoCasts","LeetCode"],"title":"P70. 最长回文串的长度","uri":"/posts/p70.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个包含大小写英文字母的字符串，你要用这些字母构建一个最长的回文字符串，并返回它的长度。 比如说，给你的字符串 s 是： aaabccdd 你能用它构建的回文串的最大长度是 7，因此你要返回的就是数字 7。 长度为 7 的回文串有多种构建方式，随便举一种，比如 acdbdca 2 LeetCode 409. 最长回文串 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p70.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P70. 最长回文串的长度","uri":"/posts/p70.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，有一个强盗要去抢一排连排房子，每个房子里放着正整数金额的钱，可以用一个整数数组来表示。这个强盗唯一的限制就是不能同时抢相邻的两个房子，那么请问，这个强盗最多可以抢到多少钱。","date":"2025-05-05","objectID":"/posts/p71.%E6%8A%A2%E5%8A%AB%E8%BF%9E%E6%8E%92%E6%88%BF%E5%AD%90/","tags":["AlgoCasts","LeetCode"],"title":"P71. 抢劫连排房子","uri":"/posts/p71.%E6%8A%A2%E5%8A%AB%E8%BF%9E%E6%8E%92%E6%88%BF%E5%AD%90/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，有一个强盗要去抢一排连排房子，每个房子里放着正整数金额的钱，可以用一个整数数组来表示。这个强盗唯一的限制就是不能同时抢相邻的两个房子，那么请问，这个强盗最多可以抢到多少钱。 比如说，这排房子里放着的钱是整数数组 nums： 8, 1, 2, 9, 6 在不能抢相邻房子的情况下，最多可以抢到的钱是 17，就是抢 8 和 9 这两个数字对应的房子。 抢完 8 和 9 后，其它的房子就都不能抢了，因为都与这两所房子相邻。 而其它的抢劫组合也都没有 17 大，比如抢 8,2,6，这三个房子不相邻可以同时抢，但抢它们的话能抢到的钱只有 16，没有 17 大。 2 LeetCode 198. 打家劫舍 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p71.%E6%8A%A2%E5%8A%AB%E8%BF%9E%E6%8E%92%E6%88%BF%E5%AD%90/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P71. 抢劫连排房子","uri":"/posts/p71.%E6%8A%A2%E5%8A%AB%E8%BF%9E%E6%8E%92%E6%88%BF%E5%AD%90/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，有一个强盗要去抢一排两两相邻，并且首尾相接的环形房子，每个房子里放着正整数金额的钱，可以用一个整数数组来表示。这个强盗唯一的限制就是不能同时抢相邻的两个房子，那么请问，这个强盗最多可以抢到多少钱。","date":"2025-05-05","objectID":"/posts/p72.%E6%8A%A2%E5%8A%AB%E7%8E%AF%E5%BD%A2%E6%88%BF%E5%AD%90/","tags":["AlgoCasts","LeetCode"],"title":"P72. 抢劫环形房子","uri":"/posts/p72.%E6%8A%A2%E5%8A%AB%E7%8E%AF%E5%BD%A2%E6%88%BF%E5%AD%90/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，有一个强盗要去抢一排两两相邻，并且首尾相接的环形房子，每个房子里放着正整数金额的钱，可以用一个整数数组来表示。这个强盗唯一的限制就是不能同时抢相邻的两个房子，那么请问，这个强盗最多可以抢到多少钱。 比如说，这排房子里放着的钱是整数数组 nums： 8, 1, 2, 9 这 4 个房子实际上围成了一个圆圈，也就是说 8 和 9 是相邻的，它们不能同时被抢。 在不能抢相邻房子的情况下，这里最多可以抢到的钱是 10，可以抢 8 和 2，也可以抢 1 和 9。 2 LeetCode 213. 打家劫舍 II 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p72.%E6%8A%A2%E5%8A%AB%E7%8E%AF%E5%BD%A2%E6%88%BF%E5%AD%90/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P72. 抢劫环形房子","uri":"/posts/p72.%E6%8A%A2%E5%8A%AB%E7%8E%AF%E5%BD%A2%E6%88%BF%E5%AD%90/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉搜索树和一个数字，你要在二叉搜索树上找到这个数字，并返回它所在的节点。如果找不到这个数字，就返回空指针。","date":"2025-05-05","objectID":"/posts/p67.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/","tags":["AlgoCasts","LeetCode"],"title":"P67. 二叉搜索树中查找数字","uri":"/posts/p67.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉搜索树和一个数字，你要在二叉搜索树上找到这个数字，并返回它所在的节点。如果找不到这个数字，就返回空指针。 二叉搜索树的定义是： 1. 左子树所有节点上的值都小于根节点上的值 2. 右子树所有节点上的值都大于根节点上的值 3. 左右子树同时也为二叉搜索树 比如说，给你的二叉搜索树是： 8 / \\ 2 16 / \\ 1 4 给你的数字是 1。1 在这棵二叉搜索树里，因此你要返回节点 1。 如果给你的数字是 42，不在这棵树中，则返回空指针。 2 LeetCode 700. 二叉搜索树中的搜索 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p67.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P67. 二叉搜索树中查找数字","uri":"/posts/p67.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个递增排序的数组，你要用它构建一棵平衡的二叉搜索树。所谓平衡，是指对于这棵二叉搜索树上的每一个节点，它左右子树的高度差不能大于 1。","date":"2025-05-05","objectID":"/posts/p68.%E7%94%A8%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","tags":["AlgoCasts","LeetCode"],"title":"P68. 用有序数组构建二叉搜索树","uri":"/posts/p68.%E7%94%A8%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个递增排序的数组，你要用它构建一棵平衡的二叉搜索树。所谓平衡，是指对于这棵二叉搜索树上的每一个节点，它左右子树的高度差不能大于 1。 比如说，给你的递增数组是： 1, 2, 4, 8, 16 一种可能的构建方式是： 4 / \\ 1 8 \\ \\ 2 16 首先，这是一棵二叉搜索树。对于任意的一个节点，它左子树上的数字都小于它；右子树上的数字都大于它。 另外这棵树是平衡的，因为任何一个节点的左右子树高度差都不大于 1。 当然，这不是唯一的构建方式。比如也可以构建成： 4 / \\ 2 8 / \\ 1 16 我们只需要返回任意一个平衡的二叉搜索树即可。 2 LeetCode 108. 将有序数组转换为二叉搜索树 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p68.%E7%94%A8%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P68. 用有序数组构建二叉搜索树","uri":"/posts/p68.%E7%94%A8%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个字符串，你要把它分割成子串，并且每个子串都是回文串。你要返回所有可能的子串集合。","date":"2025-05-05","objectID":"/posts/p69.%E5%9B%9E%E6%96%87%E5%88%86%E5%89%B2/","tags":["AlgoCasts","LeetCode"],"title":"P69. 回文分割","uri":"/posts/p69.%E5%9B%9E%E6%96%87%E5%88%86%E5%89%B2/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个字符串，你要把它分割成子串，并且每个子串都是回文串。你要返回所有可能的子串集合。 比如说，给你的字符串是： aad 它有两种可能的分割方法。一种是分割成 aa 和 d。aa 是回文串，d 作为单个字符也是回文串。 另一种是分割成 a，a 和 d，3 个子串都是单字符的回文串。 2 LeetCode 131. 分割回文串 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p69.%E5%9B%9E%E6%96%87%E5%88%86%E5%89%B2/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P69. 回文分割","uri":"/posts/p69.%E5%9B%9E%E6%96%87%E5%88%86%E5%89%B2/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个二叉树，你要返回一个数组，表示二叉树前序遍历的结果。","date":"2025-05-05","objectID":"/posts/p65.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/","tags":["AlgoCasts","LeetCode"],"title":"P65. 二叉树前序遍历","uri":"/posts/p65.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个二叉树，你要返回一个数组，表示二叉树前序遍历的结果。 比如说，给你的二叉树是： 1 / \\ 2 3 \\ 4 / 5 你要返回的前序遍历结果是： 1, 2, 4, 5, 3 2 LeetCode 144. 二叉树的前序遍历 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p65.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P65. 二叉树前序遍历","uri":"/posts/p65.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个非负整数 n，你要返回帕斯卡三角形的前 n 行。帕斯卡三角形又称为杨辉三角形，它的特点是左右两条边上的数字都为 1，其它位置的数字等于左上方与右上方的两个数字之和。","date":"2025-05-05","objectID":"/posts/p66.%E5%B8%95%E6%96%AF%E5%8D%A1%E4%B8%89%E8%A7%92%E5%BD%A2/","tags":["AlgoCasts","LeetCode"],"title":"P66. 帕斯卡三角形","uri":"/posts/p66.%E5%B8%95%E6%96%AF%E5%8D%A1%E4%B8%89%E8%A7%92%E5%BD%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个非负整数 n，你要返回帕斯卡三角形的前 n 行。帕斯卡三角形又称为杨辉三角形，它的特点是左右两条边上的数字都为 1，其它位置的数字等于左上方与右上方的两个数字之和。 比如说，给你的数字是 5，你要返回帕斯卡三角形的前 5 行。 [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] 2 LeetCode 118. 杨辉三角 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p66.%E5%B8%95%E6%96%AF%E5%8D%A1%E4%B8%89%E8%A7%92%E5%BD%A2/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P66. 帕斯卡三角形","uri":"/posts/p66.%E5%B8%95%E6%96%AF%E5%8D%A1%E4%B8%89%E8%A7%92%E5%BD%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树和一个整数，你要判断这棵二叉树上是否存在一条从根到叶子节点的路径，这条路径上所有节点中的数字相加等于给你的整数。","date":"2025-05-05","objectID":"/posts/p62.%E8%B7%AF%E5%BE%84%E5%92%8C%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8E%E7%BB%99%E5%AE%9A%E5%80%BC/","tags":["AlgoCasts","LeetCode"],"title":"P62. 路径和是否等于给定值","uri":"/posts/p62.%E8%B7%AF%E5%BE%84%E5%92%8C%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8E%E7%BB%99%E5%AE%9A%E5%80%BC/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树和一个整数，你要判断这棵二叉树上是否存在一条从根到叶子节点的路径，这条路径上所有节点中的数字相加等于给你的整数。 比如说，给你的二叉树是： 1 / \\ 2 4 / \\ 8 16 给你的整数是 13。在这棵二叉树中存在一条从根到叶子节点的路径 1-\u003e4-\u003e8，路径上的数字加起来等于 13，于是要返回 true。 2 LeetCode 112. 路径总和 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p62.%E8%B7%AF%E5%BE%84%E5%92%8C%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8E%E7%BB%99%E5%AE%9A%E5%80%BC/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P62. 路径和是否等于给定值","uri":"/posts/p62.%E8%B7%AF%E5%BE%84%E5%92%8C%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8E%E7%BB%99%E5%AE%9A%E5%80%BC/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树的前序和中序遍历序列，你要根据这两个序列构建这棵二叉树。假设这棵二叉树节点上没有重复的数字。","date":"2025-05-05","objectID":"/posts/p63.%E7%94%A8%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":["AlgoCasts","LeetCode"],"title":"P63. 用前序和中序遍历序列构建二叉树","uri":"/posts/p63.%E7%94%A8%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树的前序和中序遍历序列，你要根据这两个序列构建这棵二叉树。假设这棵二叉树节点上没有重复的数字。 比如说，给你的前序遍历序列和中序遍历序列分别是： 前序遍历序列：1, 2, 4, 8, 16 中序遍历序列：2, 1, 8, 4, 16 你要返回用它们构建出的二叉树，是： 1 / \\ 2 4 / \\ 8 16 2 LeetCode 105. 从前序与中序遍历序列构造二叉树 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p63.%E7%94%A8%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P63. 用前序和中序遍历序列构建二叉树","uri":"/posts/p63.%E7%94%A8%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树的中序和后序遍历序列，你要根据这两个序列构建这棵二叉树。假设这棵二叉树节点上没有重复的数字。","date":"2025-05-05","objectID":"/posts/p64.%E7%94%A8%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":["AlgoCasts","LeetCode"],"title":"P64. 用中序和后序遍历序列构建二叉树","uri":"/posts/p64.%E7%94%A8%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树的中序和后序遍历序列，你要根据这两个序列构建这棵二叉树。假设这棵二叉树节点上没有重复的数字。 比如说，给你的中序遍历序列和后序遍历序列分别是： 中序遍历序列：2, 1, 8, 4, 16 后序遍历序列：2, 8, 16, 4, 1 你要返回用它们构建出的二叉树，是： 1 / \\ 2 4 / \\ 8 16 2 LeetCode 106. 从中序与后序遍历序列构造二叉树 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p64.%E7%94%A8%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P64. 用中序和后序遍历序列构建二叉树","uri":"/posts/p64.%E7%94%A8%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组和一个整数 K，你要找到数组中第 K 大的元素。","date":"2025-05-05","objectID":"/posts/p59.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/","tags":["AlgoCasts","LeetCode"],"title":"P59. 数组中第 K 大的元素","uri":"/posts/p59.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组和一个整数 K，你要找到数组中第 K 大的元素。 比如说，给你的整数数组是： 4, 2, 8, 1, 8 整数 K 是 2。这个数组中第 2 大的元素是 8，因此你要返回 8。 2 LeetCode 215. 数组中的第 K 个最大元素 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p59.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P59. 数组中第 K 大的元素","uri":"/posts/p59.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个区间集合，你要把有重叠的区间合并起来。","date":"2025-05-05","objectID":"/posts/p60.%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/","tags":["AlgoCasts","LeetCode"],"title":"P60. 区间合并","uri":"/posts/p60.%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个区间集合，你要把有重叠的区间合并起来。 比如说，给你的区间集合是： [1, 8] [2, 4] [9, 10] [10, 16] 这 4 个区间里，[1, 8] 区间包含了 [2, 4] 区间，于是它们合并后是 [1, 8]。 [9, 10] 区间和 [10, 16] 区间相邻，合并起来后是 [9, 16]。最后得到合并后的区间有两个： [1, 8] [9, 16] 2 LeetCode 56. 合并区间 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p60.%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P60. 区间合并","uri":"/posts/p60.%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一组矩形表示的楼房，它们的底边在同一水平线上，并且楼房之间可以相邻，也可以重叠。你要找到这组楼房的轮廓线或者叫天际线，并返回这个轮廓线的关键点。","date":"2025-05-05","objectID":"/posts/p61.%E5%AF%BB%E6%89%BE%E5%A4%A9%E9%99%85%E7%BA%BF/","tags":["AlgoCasts","LeetCode"],"title":"P61. 寻找天际线","uri":"/posts/p61.%E5%AF%BB%E6%89%BE%E5%A4%A9%E9%99%85%E7%BA%BF/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一组矩形表示的楼房，它们的底边在同一水平线上，并且楼房之间可以相邻，也可以重叠。你要找到这组楼房的轮廓线或者叫天际线，并返回这个轮廓线的关键点。 2 LeetCode 218. 天际线问题 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p61.%E5%AF%BB%E6%89%BE%E5%A4%A9%E9%99%85%E7%BA%BF/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P61. 寻找天际线","uri":"/posts/p61.%E5%AF%BB%E6%89%BE%E5%A4%A9%E9%99%85%E7%BA%BF/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你要实现一个类，用来求数据流中第 K 大的元素。你需要实现这个类中的两个函数。第一个是构造函数，它接收一个整数数组以及一个整数 K，整数数组作为初始数据流。第二个是 add 函数，接收一个整数表示新流入的数据，然后返回当前第 K 大的元素。","date":"2025-05-05","objectID":"/posts/p57.%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/","tags":["AlgoCasts","LeetCode"],"title":"P57. 数据流中第 K 大的元素","uri":"/posts/p57.%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你要实现一个类，用来求数据流中第 K 大的元素。你需要实现这个类中的两个函数。第一个是构造函数，它接收一个整数数组以及一个整数 K，整数数组作为初始数据流。第二个是 add 函数，接收一个整数表示新流入的数据，然后返回当前第 K 大的元素。 比如说，给你的 K 是 3，初始的数组是： 1, 5, 2, 8 这时假如调用 add 函数增加一个数字 9，数据流变成： 1, 5, 2, 8, 9 你要返回第 3 大的元素是 5。 假如再调用 add 函数增加一个数字 0，数据流变成： 1, 5, 2, 8, 9, 0 这时你要返回的第 3 大元素仍然是 5。 2 LeetCode 703. 数据流中的第 K 大元素 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p57.%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P57. 数据流中第 K 大的元素","uri":"/posts/p57.%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组表示一副牌，你要写一个随机洗牌函数来返回这个数组的一个排列。并且要保证每次返回的排列都是等概率的。假设已经给你一个完美的随机数生成器。","date":"2025-05-05","objectID":"/posts/p58.%E9%9A%8F%E6%9C%BA%E6%B4%97%E7%89%8C/","tags":["AlgoCasts","LeetCode"],"title":"P58. 随机洗牌","uri":"/posts/p58.%E9%9A%8F%E6%9C%BA%E6%B4%97%E7%89%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组表示一副牌，你要写一个随机洗牌函数来返回这个数组的一个排列。并且要保证每次返回的排列都是等概率的。假设已经给你一个完美的随机数生成器。 2 LeetCode 384. 打乱数组 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p58.%E9%9A%8F%E6%9C%BA%E6%B4%97%E7%89%8C/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P58. 随机洗牌","uri":"/posts/p58.%E9%9A%8F%E6%9C%BA%E6%B4%97%E7%89%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你要实现一个函数，来计算非负整数 n 的平方根，平方根只需返回整数部分即可。","date":"2025-05-05","objectID":"/posts/p54.%E5%AE%9E%E7%8E%B0%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%87%BD%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P54. 实现平方根函数","uri":"/posts/p54.%E5%AE%9E%E7%8E%B0%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%87%BD%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你要实现一个函数，来计算非负整数 n 的平方根，平方根只需返回整数部分即可。 比如，使用你实现的函数来计算 9 的平方根是 3： f(9) = 3 由于 8 的平方根是 2 点几，使用你实现的函数只需要返回整数部分 2 即可： f(8) = 2 2 LeetCode 69. x 的平方根 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p54.%E5%AE%9E%E7%8E%B0%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%87%BD%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P54. 实现平方根函数","uri":"/posts/p54.%E5%AE%9E%E7%8E%B0%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%87%BD%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两个整数，你要计算出它们的二进制表示中，相应的二进制位有多少个是不同的。这个不同的个数，也称为这两个整数的汉明距离。","date":"2025-05-05","objectID":"/posts/p55.%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/","tags":["AlgoCasts","LeetCode"],"title":"P55. 汉明距离","uri":"/posts/p55.%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两个整数，你要计算出它们的二进制表示中，相应的二进制位有多少个是不同的。这个不同的个数，也称为这两个整数的汉明距离。 比如说，给你的两个整数是 3 和 8。它们的二进制表示分别是： 3: 0011 8: 1000 这两个数有 3 个二进制位是不相同的，因此它们的汉明距离是 3。 2 LeetCode 461. 汉明距离 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p55.%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P55. 汉明距离","uri":"/posts/p55.%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个排好序的整数数组，里面的数字都出现两次，只有一个数字出现了一次，我们管它叫单身数字，你要写代码找到这个单身数字。","date":"2025-05-05","objectID":"/posts/p56.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E8%BA%AB%E6%95%B0%E5%AD%97/","tags":["AlgoCasts","LeetCode"],"title":"P56. 有序数组中的单身数字","uri":"/posts/p56.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E8%BA%AB%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个排好序的整数数组，里面的数字都出现两次，只有一个数字出现了一次，我们管它叫单身数字，你要写代码找到这个单身数字。 比如说给你的有序数组是： 1, 1, 2, 2, 4, 4, 6, 8, 8 这个数组里 6 只出现了一次，因此你要返回的数字就是 6。 2 LeetCode 540. 有序数组中的单一元素 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p56.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E8%BA%AB%E6%95%B0%E5%AD%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P56. 有序数组中的单身数字","uri":"/posts/p56.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E8%BA%AB%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个 m x n 的整数矩阵，你要计算从矩阵的左上角到右下角的所有路径中，最小的路径和。路径的移动方向只能是向右或向下。","date":"2025-05-05","objectID":"/posts/p51.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","tags":["AlgoCasts","LeetCode"],"title":"P51. 最小路径和","uri":"/posts/p51.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个 m x n 的整数矩阵，你要计算从矩阵的左上角到右下角的所有路径中，最小的路径和。路径的移动方向只能是向右或向下。 比如说，给你的矩阵 a 是： 1, 2, 1 8, 4, 1 -8, 2, 1 对于这个矩阵，从左上角走到右下角，和最小的一条路径是 1,8,-8,2,1，它的和是 4，因此你需要返回 4。 2 LeetCode 64. 最小路径和 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p51.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P51. 最小路径和","uri":"/posts/p51.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个单链表和数字 n，你要移除单链表倒数第 n 个节点，然后返回单链表。","date":"2025-05-05","objectID":"/posts/p52.%E7%A7%BB%E9%99%A4%E5%8D%95%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/","tags":["AlgoCasts","LeetCode"],"title":"P52. 移除单链表倒数第 n 个节点","uri":"/posts/p52.%E7%A7%BB%E9%99%A4%E5%8D%95%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个单链表和数字 n，你要移除单链表倒数第 n 个节点，然后返回单链表。 比如说，给你的单链表是： 1 -\u003e 2 -\u003e 4 -\u003e 8 给你的数字 n 是 3，单链表中倒数第 3 个节点是 2，移除 2 以后的单链表是： 1 -\u003e 4 -\u003e 8 2 LeetCode 19. 删除链表的倒数第 N 个结点 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p52.%E7%A7%BB%E9%99%A4%E5%8D%95%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P52. 移除单链表倒数第 n 个节点","uri":"/posts/p52.%E7%A7%BB%E9%99%A4%E5%8D%95%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组，你要找到数组中三个数相加等于 0 的所有可能组合。返回的答案里，每个组合都是唯一的，不能重复。","date":"2025-05-05","objectID":"/posts/p53.%E7%9B%B8%E5%8A%A0%E7%AD%89%E4%BA%8E0%E7%9A%84%E4%B8%89%E4%B8%AA%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P53. 相加等于 0 的三个数","uri":"/posts/p53.%E7%9B%B8%E5%8A%A0%E7%AD%89%E4%BA%8E0%E7%9A%84%E4%B8%89%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组，你要找到数组中三个数相加等于 0 的所有可能组合。返回的答案里，每个组合都是唯一的，不能重复。 比如说，给你的数组是： -1, 0, -1, 0, 1, 0, -4 这个数组中有两个组合，使得三个数相加等于 0。第一个组合是： -1, 0, 1 虽然数组里有 3 个 0，两个 -1，但不管用哪个 0 或 -1，组合 -1,0,1 都只算一个。另一个有效的组合是： 0, 0, 0 2 LeetCode 15. 三数之和 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p53.%E7%9B%B8%E5%8A%A0%E7%AD%89%E4%BA%8E0%E7%9A%84%E4%B8%89%E4%B8%AA%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P53. 相加等于 0 的三个数","uri":"/posts/p53.%E7%9B%B8%E5%8A%A0%E7%AD%89%E4%BA%8E0%E7%9A%84%E4%B8%89%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数，你要计算它的二进制表示中 1 的个数，然后返回。","date":"2025-05-05","objectID":"/posts/p49.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P49. 二进制中 1 的个数","uri":"/posts/p49.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数，你要计算它的二进制表示中 1 的个数，然后返回。 比如说，给你的整数是 12，它的二进制表示是： 1100 包含两个 1，因此你要返回 2。 2 LeetCode 191. 位 1 的个数 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p49.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P49. 二进制中 1 的个数","uri":"/posts/p49.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个 m x n 的矩阵，你要把这个矩阵中等于 0 的元素所在的行和列都置 0。","date":"2025-05-05","objectID":"/posts/p50.%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/","tags":["AlgoCasts","LeetCode"],"title":"P50. 矩阵置零","uri":"/posts/p50.%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个 m x n 的矩阵，你要把这个矩阵中等于 0 的元素所在的行和列都置 0。 比如说，给你的矩阵 a 是： 1, 2, 3 4, 0, 6 0, 8, 9 这个矩阵中有两个 0，把它们所在的行和列都置 0 后，得到的矩阵是： 0, 0, 3 0, 0, 0 0, 0, 0 2 LeetCode 73. 矩阵置零 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p50.%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P50. 矩阵置零","uri":"/posts/p50.%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组，其中第 i 个元素表示的是第 i 天的股票价格，你要计算出先买一股，然后再卖出它能获得的最大利润。","date":"2025-05-05","objectID":"/posts/p46.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/","tags":["AlgoCasts","LeetCode"],"title":"P46. 买卖股票的最大利润","uri":"/posts/p46.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组，其中第 i 个元素表示的是第 i 天的股票价格，你要计算出先买一股，然后再卖出它能获得的最大利润。 比如说，给你的数组是： 9, 3, 7, 5, 1, 8 如果你在价格为 1 时买入并在价格为 8 时卖出，这时能获得最大的利润 7。 再比如说给你的数组是： 9, 8, 7, 6 这时股票每天都在跌，不存在买入再卖出来获利的可能，因此没有交易，最大利润为 0。 2 LeetCode 121. 买卖股票的最佳时机 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p46.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P46. 买卖股票的最大利润","uri":"/posts/p46.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树，你要把它左右镜像翻转，然后返回翻转后的二叉树。","date":"2025-05-05","objectID":"/posts/p47.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":["AlgoCasts","LeetCode"],"title":"P47. 翻转二叉树","uri":"/posts/p47.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树，你要把它左右镜像翻转，然后返回翻转后的二叉树。 比如说，给你的二叉树是： 1 / \\ 2 4 / \\ 8 16 左右翻转后的二叉树是： 1 / \\ 4 2 / \\ 16 8 我们可以看到，二叉树上所有节点都沿中轴线左右互换了位置。 2 LeetCode 226. 翻转二叉树 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p47.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P47. 翻转二叉树","uri":"/posts/p47.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个单链表和一个数字，你要删除节点上数字等于给定数字的那些节点，然后返回删除节点后的单链表。","date":"2025-05-05","objectID":"/posts/p48.%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E6%95%B0%E5%AD%97/","tags":["AlgoCasts","LeetCode"],"title":"P48. 单链表删除数字","uri":"/posts/p48.%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个单链表和一个数字，你要删除节点上数字等于给定数字的那些节点，然后返回删除节点后的单链表。 比如说，给你的单链表是： 1 -\u003e 2 -\u003e 4 -\u003e 1 -\u003e 8 -\u003e 1 要删除的数字是 1。那么删除 1 后，你要返回的单链表是： 2 -\u003e 4 -\u003e 8 2 LeetCode 203. 移除链表元素 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p48.%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E6%95%B0%E5%AD%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P48. 单链表删除数字","uri":"/posts/p48.%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你要实现 C 语言里面的 strstr 函数，这个函数接收两个字符串，你要找到第二个字符串在第一个字符串中的开始下标，如果找不到则返回 -1。","date":"2025-05-05","objectID":"/posts/p43.%E5%AE%9E%E7%8E%B0strstr/","tags":["AlgoCasts","LeetCode"],"title":"P43. 实现 strstr","uri":"/posts/p43.%E5%AE%9E%E7%8E%B0strstr/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你要实现 C 语言里面的 strstr 函数，这个函数接收两个字符串，你要找到第二个字符串在第一个字符串中的开始下标，如果找不到则返回 -1。 比如说，给你的两个字符串分别是： marvel studio 和 studio 第二个字符串存在于第一个字符串中，于是你要返回它在第一个字符串中的开始下标 7。 再比如说给你的字符串是： doctor strange 和 master 第二个字符串没有在第一个字符串中出现，因此返回 -1。 2 LeetCode 28. 找出字符串中第一个匹配项的下标 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p43.%E5%AE%9E%E7%8E%B0strstr/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P43. 实现 strstr","uri":"/posts/p43.%E5%AE%9E%E7%8E%B0strstr/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树，你要判断它是不是一棵二叉搜索树。","date":"2025-05-05","objectID":"/posts/p44.%E6%A3%80%E9%AA%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","tags":["AlgoCasts","LeetCode"],"title":"P44. 检验二叉搜索树","uri":"/posts/p44.%E6%A3%80%E9%AA%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树，你要判断它是不是一棵二叉搜索树。 二叉搜索树的定义是： 1. 左子树所有节点上的值都小于根节点上的值 2. 右子树所有节点上的值都大于根节点上的值 3. 左右子树同时也为二叉搜索树 比如说，给你的二叉树是： 4 / \\ 2 6 左子树只有一个节点 2，小于 4；右子树也只有一个节点 6，大于 4。因此这是一棵二叉搜索树。 再比如说，给你的二叉树是： 4 / \\ 2 6 / \\ 3 8 右子树存在一个节点 3，它不大于根节点 4。因此这不是一棵二叉搜索树。 2 LeetCode 98. 验证二叉搜索树 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p44.%E6%A3%80%E9%AA%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P44. 检验二叉搜索树","uri":"/posts/p44.%E6%A3%80%E9%AA%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个括号序列，里面包含小括号，中括号和大括号。你要判断这个括号序列是否有效。有效的括号序列要求，每个左括号都必须有一个同类的右括号与它正确配对。另外，空字符串认为是有效的括号序列。","date":"2025-05-05","objectID":"/posts/p45.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/","tags":["AlgoCasts","LeetCode"],"title":"P45. 有效的括号序列","uri":"/posts/p45.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个括号序列，里面包含小括号，中括号和大括号。你要判断这个括号序列是否有效。有效的括号序列要求，每个左括号都必须有一个同类的右括号与它正确配对。另外，空字符串认为是有效的括号序列。 比如说，给你的序列是： ()[]{} 小括号/中括号/大括号的左右括号都能正确配对，因此这是一个有效的括号序列。 再比如说给你的序列是： ([)] 这里面虽然正好有一对小括号和一对中括号，但它们的顺序不对，括号间无法正确配对，因此这不是一个有效的括号序列。 2 LeetCode 20. 有效的括号 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p45.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P45. 有效的括号序列","uri":"/posts/p45.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两个非空的单链表，它们代表两个非负整数，并且逆序表示。你要将这两个数求和，并将结果以链表形式返回。你不需要考虑前导 0 这种情况，也就说 3 不会表示成 003 这样子。","date":"2025-05-05","objectID":"/posts/p40.%E6%B1%82%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%92%8C/","tags":["AlgoCasts","LeetCode"],"title":"P40. 求两个单链表之和","uri":"/posts/p40.%E6%B1%82%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%92%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两个非空的单链表，它们代表两个非负整数，并且逆序表示。你要将这两个数求和，并将结果以链表形式返回。你不需要考虑前导 0 这种情况，也就说 3 不会表示成 003 这样子。 比如说给你的两个链接表是： 1 -\u003e 2 -\u003e 3 6 -\u003e 7 -\u003e 8 -\u003e 9 1 -\u003e 2 -\u003e 3 表示的整数是 321，6 -\u003e 7 -\u003e 8 -\u003e 9 表示的整数是 9876。我们需要输出的是它们求和后的链表： 7 -\u003e 9 -\u003e 1 -\u003e 0 -\u003e 1 2 LeetCode 2. 两数相加 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p40.%E6%B1%82%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%92%8C/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P40. 求两个单链表之和","uri":"/posts/p40.%E6%B1%82%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%92%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个数字，你要判断它是不是一个丑数。丑数的定义是质因数只包含 2，3，5 的正整数。另外，1 作为特例，也定义为丑数。","date":"2025-05-05","objectID":"/posts/p41.%E4%B8%91%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P41. 丑数","uri":"/posts/p41.%E4%B8%91%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个数字，你要判断它是不是一个丑数。丑数的定义是质因数只包含 2，3，5 的正整数。另外，1 作为特例，也定义为丑数。 比如说给你的数字是 45，45 做质因数分解，可以写成： 45 = 3 x 3 x 5 不包含 2，3，5 以外的质因数，因此它是一个丑数。 再比如说 42，它做质因数分解得到： 42 = 2 x 3 x 7 7 不在 2，3，5 中，因此 42 不是丑数。 2 LeetCode 263. 丑数 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p41.%E4%B8%91%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P41. 丑数","uri":"/posts/p41.%E4%B8%91%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个字符串，你要把它转成一个 int 类型的数字。这个字符串里可能会包含空格，字母或是其它字符。","date":"2025-05-05","objectID":"/posts/p42.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P42. 字符串转整数","uri":"/posts/p42.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个字符串，你要把它转成一个 int 类型的数字。这个字符串里可能会包含空格，字母或是其它字符。 一个可以有效地转成数字的字符串包含以下特点： 1. 可以有前导空格或前导 0，但不能有其它前导字符 2. 可能会有一个加号或减号表示正负，也可能没有，连续的多个加号或减号则视为不合法 3. 紧接着是一段连续的数字，如果没有数字则示为不合法 4. 数字后的其它字符都可以忽略 5. 如果数字大于 int 的最大值或小于 int 的最小值，返回相应的极值即可 6. 字符串如果不能合法地转为整数，则返回 0 2 LeetCode 8. 字符串转换整数 (atoi) 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p42.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P42. 字符串转整数","uri":"/posts/p42.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个二维数组 matrix，和一个目标值 target。你要在数组里找到这个目标值，然后返回它的行/列下标。如果找不到，则返回 [-1,-1]。","date":"2025-05-05","objectID":"/posts/p38.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","tags":["AlgoCasts","LeetCode"],"title":"P38. 二维数组的二分搜索","uri":"/posts/p38.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个二维数组 matrix，和一个目标值 target。你要在数组里找到这个目标值，然后返回它的行/列下标。如果找不到，则返回 [-1,-1]。 这个数组的每一行都是递增的，并且每一行的第一个数都比上一行的最后一个数要大。也就是，这个数组可以看成，从左到右、从上到下，呈 Z 字形递增。 比如说，给你的二维数组是： 1, 3, 5 7, 9, 11 给你的目标值是 9。9 在这个数组中，找到后返回它的下标 [1, 1] 即可。 如果给你的目标值是 100。显然它不在这个二维数组中，你要返回 [-1，-1]。 2 LeetCode 74. 搜索二维矩阵 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p38.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P38. 二维数组的二分搜索","uri":"/posts/p38.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树，你要判断它是否平衡。这里平衡指的是，对于树上任意一个节点，它的两棵子树的高度差不能大于 1。","date":"2025-05-05","objectID":"/posts/p39.%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%B9%B3%E8%A1%A1/","tags":["AlgoCasts","LeetCode"],"title":"P39. 判断二叉树是否平衡","uri":"/posts/p39.%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%B9%B3%E8%A1%A1/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树，你要判断它是否平衡。这里平衡指的是，对于树上任意一个节点，它的两棵子树的高度差不能大于 1。 比如说，给你的二叉树是： 1 / \\ 2 4 / \\ 8 16 它的任意节点的左右子树高度差都不大于 1，因此它是一棵平衡二叉树。 再比如说，给你的二叉树是： 1 / \\ 2 4 \\ 8 \\ 16 在这棵树中，根节点的左右子树高度差为 2，因此它不是一棵平衡二叉树。 2 LeetCode 110. 平衡二叉树 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p39.%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%B9%B3%E8%A1%A1/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P39. 判断二叉树是否平衡","uri":"/posts/p39.%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%B9%B3%E8%A1%A1/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个二叉树，你要返回一个数组，表示二叉树中序遍历的结果。","date":"2025-05-05","objectID":"/posts/p35.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","tags":["AlgoCasts","LeetCode"],"title":"P35. 二叉树中序遍历","uri":"/posts/p35.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个二叉树，你要返回一个数组，表示二叉树中序遍历的结果。 比如说，给你的二叉树是： 1 / \\ 2 3 \\ 4 / 5 你要返回的中序遍历结果是：2, 5, 4, 1, 3 2 LeetCode 94. 二叉树的中序遍历 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p35.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P35. 二叉树中序遍历","uri":"/posts/p35.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个递增排序的整数数组 nums，和一个目标值 target。你要在数组里找到 target，然后返回它的下标。如果找不到则返回 -1。","date":"2025-05-05","objectID":"/posts/p36.%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","tags":["AlgoCasts","LeetCode"],"title":"P36. 二分搜索","uri":"/posts/p36.%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个递增排序的整数数组 nums，和一个目标值 target。你要在数组里找到 target，然后返回它的下标。如果找不到则返回 -1。 比如说，给你的数组是： -2, 0, 2, 4, 5, 8, 9 给你的目标值是 5。5 在这个数组中，找到后返回它的下标 4 即可。 2 LeetCode 704. 二分查找 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p36.%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P36. 二分搜索","uri":"/posts/p36.%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个递增排序的整数数组 nums，和一个目标值 target。你要在数组里找到 target，然后返回它的下标。如果找不到，则返回目标值应该插入的位置的下标，要求插入目标值后，数组仍然保持有序。","date":"2025-05-05","objectID":"/posts/p37.%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/","tags":["AlgoCasts","LeetCode"],"title":"P37. 二分搜索插入位置","uri":"/posts/p37.%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个递增排序的整数数组 nums，和一个目标值 target。你要在数组里找到 target，然后返回它的下标。如果找不到，则返回目标值应该插入的位置的下标，要求插入目标值后，数组仍然保持有序。 2 LeetCode 35. 搜索插入位置 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p37.%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P37. 二分搜索插入位置","uri":"/posts/p37.%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个 n 阶的楼梯，每次你可以爬 1 阶或 2 阶，你要求出爬完这个楼梯有多少种不同的方法。","date":"2025-05-05","objectID":"/posts/p32.%E7%88%AC%E6%A5%BC%E6%A2%AF%E6%96%B9%E6%B3%95%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P32. 爬楼梯方法数","uri":"/posts/p32.%E7%88%AC%E6%A5%BC%E6%A2%AF%E6%96%B9%E6%B3%95%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个 n 阶的楼梯，每次你可以爬 1 阶或 2 阶，你要求出爬完这个楼梯有多少种不同的方法。 比如说，楼梯只有 1 阶，显然你只有一种爬法，就是爬 1 阶，然后到顶。 再比如说，楼梯有 2 阶，那么你可以用两次 1 阶爬到顶，也可以用一次 2 阶爬到顶。共 2 种爬法。 2 LeetCode 70. 爬楼梯 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p32.%E7%88%AC%E6%A5%BC%E6%A2%AF%E6%96%B9%E6%B3%95%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P32. 爬楼梯方法数","uri":"/posts/p32.%E7%88%AC%E6%A5%BC%E6%A2%AF%E6%96%B9%E6%B3%95%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树，要求你从根节点到叶子节点一层一层地对其进行访问，对于每一层的节点，则是从左向右进行访问。将访问的结果以二维数组返回。","date":"2025-05-05","objectID":"/posts/p33.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","tags":["AlgoCasts","LeetCode"],"title":"P33. 二叉树的层序遍历","uri":"/posts/p33.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树，要求你从根节点到叶子节点一层一层地对其进行访问，对于每一层的节点，则是从左向右进行访问。将访问的结果以二维数组返回。 比如说，给你的二叉树是： 1 / \\ 2 4 / \\ 8 16 它的层序遍历结果是： [ [1], [2, 4], [8, 16] ] 2 LeetCode 102. 二叉树的层序遍历 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p33.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P33. 二叉树的层序遍历","uri":"/posts/p33.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树，要求你从叶子节点到根节点一层一层地对其进行访问，对于每一层的节点，则是从左向右进行访问。将访问的结果以二维数组返回。","date":"2025-05-05","objectID":"/posts/p34.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%86%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","tags":["AlgoCasts","LeetCode"],"title":"P34. 二叉树的逆层序遍历","uri":"/posts/p34.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%86%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树，要求你从叶子节点到根节点一层一层地对其进行访问，对于每一层的节点，则是从左向右进行访问。将访问的结果以二维数组返回。 这道题目和二叉树层序遍历的唯一区别是，它是从下向上一层一层去访问的。 比如说，给你的二叉树是： 1 / \\ 2 4 / \\ 8 16 它的逆层序遍历结果是： [ [8, 16]， [2, 4], [1], ] 2 LeetCode 107. 二叉树的层序遍历 II 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p34.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%86%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P34. 二叉树的逆层序遍历","uri":"/posts/p34.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%86%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你 n 对括号，你要返回这 n 对括号的所有合法排列方式。","date":"2025-05-05","objectID":"/posts/p29.%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%90%88%E6%B3%95%E6%8E%92%E5%88%97/","tags":["AlgoCasts","LeetCode"],"title":"P29. 括号的合法排列","uri":"/posts/p29.%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%90%88%E6%B3%95%E6%8E%92%E5%88%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你 n 对括号，你要返回这 n 对括号的所有合法排列方式。 比如说，n 等于 3 时，合法的排列有 5 个： ((())) (()()) (())() ()(()) ()()() 2 LeetCode 22. 括号生成 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p29.%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%90%88%E6%B3%95%E6%8E%92%E5%88%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P29. 括号的合法排列","uri":"/posts/p29.%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%90%88%E6%B3%95%E6%8E%92%E5%88%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两个字符串，你要求出由其中一个字符串转成另一个所需要的最少编辑操作次数。允许的操作有 3 种，分别是：替换一个字符，插入一个字符和删除一个字符。","date":"2025-05-05","objectID":"/posts/p30.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/","tags":["AlgoCasts","LeetCode"],"title":"P30. 编辑距离","uri":"/posts/p30.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两个字符串，你要求出由其中一个字符串转成另一个所需要的最少编辑操作次数。允许的操作有 3 种，分别是：替换一个字符，插入一个字符和删除一个字符。 比如说，给你的两个字符串是 car 和 ba。 s1: car s2: ba 你要把 car 转成 ba，需要先把 c 替换成 b，然后再删除 r。总共操作 2 次，因此它们的编辑距离是 2。 2 LeetCode 72. 编辑距离 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p30.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P30. 编辑距离","uri":"/posts/p30.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个非负整数数组，数组中的数字表示高度值，在平面坐标画出来后，连同 X 轴一起，会形成许多的凹槽。你要找到两个高度值，使其形成的凹槽所能容纳的水最多。最后返回容纳的水量。","date":"2025-05-05","objectID":"/posts/p31.%E5%AE%B9%E7%BA%B3%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%87%B9%E6%A7%BD%E5%AE%B9%E9%87%8F/","tags":["AlgoCasts","LeetCode"],"title":"P31. 容纳最多水的凹槽容量","uri":"/posts/p31.%E5%AE%B9%E7%BA%B3%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%87%B9%E6%A7%BD%E5%AE%B9%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个非负整数数组，数组中的数字表示高度值，在平面坐标画出来后，连同 X 轴一起，会形成许多的凹槽。你要找到两个高度值，使其形成的凹槽所能容纳的水最多。最后返回容纳的水量。 2 LeetCode 11. 盛最多水的容器 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p31.%E5%AE%B9%E7%BA%B3%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%87%B9%E6%A7%BD%E5%AE%B9%E9%87%8F/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P31. 容纳最多水的凹槽容量","uri":"/posts/p31.%E5%AE%B9%E7%BA%B3%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%87%B9%E6%A7%BD%E5%AE%B9%E9%87%8F/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个单链表，你要判断它是否会形成环，也就是链表的最后一个节点指向了前面一个已经存在的节点。","date":"2025-05-05","objectID":"/posts/p27.%E5%88%A4%E6%96%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/","tags":["AlgoCasts","LeetCode"],"title":"P27. 判断单链表是否有环","uri":"/posts/p27.%E5%88%A4%E6%96%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个单链表，你要判断它是否会形成环，也就是链表的最后一个节点指向了前面一个已经存在的节点。 2 LeetCode 141. 环形链表 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p27.%E5%88%A4%E6%96%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P27. 判断单链表是否有环","uri":"/posts/p27.%E5%88%A4%E6%96%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两个单链表，你要找到它们相交的第一个节点。如果两个链表没有相交，则返回空指针。假设链表无环，并且你不能改变它的原始结构。另外要求算法是线性时间复杂度，空间复杂度要求是 O(1)。","date":"2025-05-05","objectID":"/posts/p28.%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E4%BA%A4%E8%8A%82%E7%82%B9/","tags":["AlgoCasts","LeetCode"],"title":"P28. 链表的相交节点","uri":"/posts/p28.%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E4%BA%A4%E8%8A%82%E7%82%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两个单链表，你要找到它们相交的第一个节点。如果两个链表没有相交，则返回空指针。假设链表无环，并且你不能改变它的原始结构。另外要求算法是线性时间复杂度，空间复杂度要求是 O(1)。 比如说，两条链表分别是： A: 1 -\u003e 2 \\ 6 -\u003e 7 -\u003e null / B: 3 -\u003e 4 -\u003e 5 你要返回的是 6 这个节点。 2 LeetCode 160. 相交链表 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p28.%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E4%BA%A4%E8%8A%82%E7%82%B9/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P28. 链表的相交节点","uri":"/posts/p28.%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E4%BA%A4%E8%8A%82%E7%82%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你要实现一个 LRU 缓存，提供 get 和 put 两个操作，并且要求两个操作的时间复杂度都是 O(1)。另外为了简单起见，在这个题目中，key 和 value 都是整数值，并且 value 只为正整数。因此在 get 操作中，当 key 不存在时，返回 -1 即可。","date":"2025-05-05","objectID":"/posts/p24.%E5%AE%9E%E7%8E%B0lru%E7%BC%93%E5%AD%98/","tags":["AlgoCasts","LeetCode"],"title":"P24. 实现 LRU 缓存","uri":"/posts/p24.%E5%AE%9E%E7%8E%B0lru%E7%BC%93%E5%AD%98/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你要实现一个 LRU 缓存，提供 get 和 put 两个操作，并且要求两个操作的时间复杂度都是 O(1)。另外为了简单起见，在这个题目中，key 和 value 都是整数值，并且 value 只为正整数。因此在 get 操作中，当 key 不存在时，返回 -1 即可。 2 LeetCode 146. LRU 缓存 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p24.%E5%AE%9E%E7%8E%B0lru%E7%BC%93%E5%AD%98/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P24. 实现 LRU 缓存","uri":"/posts/p24.%E5%AE%9E%E7%8E%B0lru%E7%BC%93%E5%AD%98/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个字符串，你要找到没有重复字符的最长子串，然后返回它的长度。","date":"2025-05-05","objectID":"/posts/p25.%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6/","tags":["AlgoCasts","LeetCode"],"title":"P25. 没有重复字符的最长子串长度","uri":"/posts/p25.%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个字符串，你要找到没有重复字符的最长子串，然后返回它的长度。 比如说给你的字符串 s 是： abcabcbb 没有重复字符的最长子串是 abc，这里再往下的字符是 a，和前面这个 a 重复了。 后面满足条件的子串还有 bca，cab，abc 等，不过它们的长度都是 3，因此返回的长度为 3。 再比如说 ddd，没有重复字符的最长子串就是一个 d，因此你要返回的长度是 1。 2 LeetCode 3. 无重复字符的最长子串 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p25.%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P25. 没有重复字符的最长子串长度","uri":"/posts/p25.%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个字符串，你要在它所有的回文子串中，找到长度最长的子串，并返回它。","date":"2025-05-05","objectID":"/posts/p26.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","tags":["AlgoCasts","LeetCode"],"title":"P26. 最长回文子串","uri":"/posts/p26.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个字符串，你要在它所有的回文子串中，找到长度最长的子串，并返回它。 比如说，给你的字符串是： abcbab 你要返回的最长回文子串是： abcba 2 LeetCode 5. 最长回文子串 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p26.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P26. 最长回文子串","uri":"/posts/p26.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个非空整数数组，你要找到和最大的连续子序列，然后返回它的和。","date":"2025-05-05","objectID":"/posts/p21.%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/","tags":["AlgoCasts","LeetCode"],"title":"P21. 连续子序列的最大和","uri":"/posts/p21.%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个非空整数数组，你要找到和最大的连续子序列，然后返回它的和。 比如说，给你的数组 a 是： 2, -8, 3, -2, 4, -10 和最大的连续子序列是 3, -2, 4, 他们的和是 5。 2 LeetCode 53. 最大子数组和 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p21.%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P21. 连续子序列的最大和","uri":"/posts/p21.%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树，你要找到从根节点到最远叶子节点的深度。","date":"2025-05-05","objectID":"/posts/p22.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","tags":["AlgoCasts","LeetCode"],"title":"P22. 二叉树的最大深度","uri":"/posts/p22.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树，你要找到从根节点到最远叶子节点的深度。 比如说，给你的二叉树是 1 / \\ 2 4 / \\ 8 16 这棵树有 3 个叶子节点，分别是 2，8，16。最远的叶子节点是 8 和 16，根节点到 8 或 16 都有 3 个节点，因此最大深度是 3。 2 LeetCode 104. 二叉树的最大深度 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p22.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P22. 二叉树的最大深度","uri":"/posts/p22.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个数组，里面有一个数字出现的次数超过了一半，你要找到这个数字并返回。","date":"2025-05-05","objectID":"/posts/p23.%E6%95%B0%E7%BB%84%E4%B8%AD%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/","tags":["AlgoCasts","LeetCode"],"title":"P23. 数组中超过一半的数字","uri":"/posts/p23.%E6%95%B0%E7%BB%84%E4%B8%AD%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个数组，里面有一个数字出现的次数超过了一半，你要找到这个数字并返回。 比如说，给你的数组是 1, 3, 3, 1, 3, 1, 1 这个数组的长度是 7，这里我们只考虑整数除法，长度 7 除以 2 是 3。数组里面 1 出现了 4 次，超过了一半的数量 3，因此你要返回的就是 1。 2 LeetCode 169. 多数元素 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p23.%E6%95%B0%E7%BB%84%E4%B8%AD%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P23. 数组中超过一半的数字","uri":"/posts/p23.%E6%95%B0%E7%BB%84%E4%B8%AD%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两个递增排序的链表，你要把它们合成一个链表，并且保持递增排序。另外要求，新链表上的节点使用的就是旧的两个链表上的节点，不能创建新节点。","date":"2025-05-05","objectID":"/posts/p18.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","tags":["AlgoCasts","LeetCode"],"title":"P18. 合并两个有序链表","uri":"/posts/p18.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两个递增排序的链表，你要把它们合成一个链表，并且保持递增排序。另外要求，新链表上的节点使用的就是旧的两个链表上的节点，不能创建新节点。 比如说，给你的两个链表 L1 和 L2，分别是： L1: 1 -\u003e 3 L2: 2 -\u003e 4 -\u003e 6 合并后的链表就是： 1 -\u003e 2 -\u003e 3 -\u003e 4 -\u003e 6 2 LeetCode 21. 合并两个有序链表 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p18.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P18. 合并两个有序链表","uri":"/posts/p18.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两个递增排序的数组，你要把第二个数组合并到第一个，并使其仍然保持递增排序。两个数组中的元素个数会显式地给出，并且第一个数组的大小可以容纳下两个数组中所有的元素。","date":"2025-05-05","objectID":"/posts/p19.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","tags":["AlgoCasts","LeetCode"],"title":"P19. 合并两个有序数组","uri":"/posts/p19.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两个递增排序的数组，你要把第二个数组合并到第一个，并使其仍然保持递增排序。两个数组中的元素个数会显式地给出，并且第一个数组的大小可以容纳下两个数组中所有的元素。 比如说给你的两个数组是： 2, 4, _, _ 1, 3 它们都有 2 个元素。并且第一个数组后面有足够的空间来填充第二个数组。把第二个数组合并到第一个数组后，得到的是： 1, 2, 3, 4 2 LeetCode 88. 合并两个有序数组 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p19.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P19. 合并两个有序数组","uri":"/posts/p19.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两个排好序的整数数组 nums1 和 nums2，假设数组是以递增排序的，数组的大小分别是 m 和 n。你要找到这两个数组的中位数。要求算法的时间复杂度是 O(log(m+n))。","date":"2025-05-05","objectID":"/posts/p20.%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P20. 求两个有序数组的中位数","uri":"/posts/p20.%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两个排好序的整数数组 nums1 和 nums2，假设数组是以递增排序的，数组的大小分别是 m 和 n。你要找到这两个数组的中位数。要求算法的时间复杂度是 O(log(m+n))。 这里两个数组中位数的意思是，两个数组合到一起排序后，位于中间的那个数，如果一共有偶数个，则是位于中间的两个数的平均数。 比如说，给你的两个数组是： 1, 3 2 它们放在一起排序后是： 1, 2, 3 所以中位数就是 2。 再比如说，给你的两个数组是： 1, 3 2, 4 它们放在一起排序后是： 1, 2, 3, 4 所以中位数就是 (2 + 3) / 2 = 2.5。 2 LeetCode 4. 寻找两个正序数组的中位数 3 难度 困难 4 题解 ","date":"2025-05-05","objectID":"/posts/p20.%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P20. 求两个有序数组的中位数","uri":"/posts/p20.%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一棵二叉树，你要找到从根节点到最近的叶子节点的深度。","date":"2025-05-05","objectID":"/posts/p16.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/","tags":["AlgoCasts","LeetCode"],"title":"P16. 二叉树的最小深度","uri":"/posts/p16.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一棵二叉树，你要找到从根节点到最近的叶子节点的深度。 比如说，给你的二叉树是： 1 / \\ 2 4 / \\ 8 16 这棵树有 3 个叶子节点，分别是 2，8，16。最近的叶子节点是 2，根节点到 2 共有两个节点，因此最小深度是 2。 再比如说，给你的二叉树是： 1 \\ 2 \\ 4 这棵树唯一的叶子节点是 4，根节点到它共有 3 个节点，因此最小深度是 3。 2 LeetCode 111. 二叉树的最小深度 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p16.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P16. 二叉树的最小深度","uri":"/posts/p16.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你要实现一个栈，除了提供 push，pop，top 等常用函数，还需要提供一个函数在 O(1) 时间内取得这个栈里的最小元素。","date":"2025-05-05","objectID":"/posts/p17.%E5%B8%A6%E6%9C%89min%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/","tags":["AlgoCasts","LeetCode"],"title":"P17. 带有 min 函数的栈","uri":"/posts/p17.%E5%B8%A6%E6%9C%89min%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你要实现一个栈，除了提供 push，pop，top 等常用函数，还需要提供一个函数在 O(1) 时间内取得这个栈里的最小元素。 2 LeetCode 155. 最小栈 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p17.%E5%B8%A6%E6%9C%89min%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P17. 带有 min 函数的栈","uri":"/posts/p17.%E5%B8%A6%E6%9C%89min%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数，你要判断它是否是一个回文数字。所谓回文数字就是，你正着读和反着读都是同一个数字。","date":"2025-05-05","objectID":"/posts/p13.%E5%9B%9E%E6%96%87%E6%95%B0%E5%AD%97%E5%88%A4%E6%96%AD/","tags":["AlgoCasts","LeetCode"],"title":"P13. 回文数字判断","uri":"/posts/p13.%E5%9B%9E%E6%96%87%E6%95%B0%E5%AD%97%E5%88%A4%E6%96%AD/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数，你要判断它是否是一个回文数字。所谓回文数字就是，你正着读和反着读都是同一个数字。 比如，给你的数字是： 12321 无论你从左向右读，还是从右向左读，都是 12321，所以它是一个回文数字，你要返回 true。 再比如说： -232 你从左向右读是 -232，但从右向左读则是 232-，和 -232 不一样，因此它不是一个回文数字，你要返回 false。 2 LeetCode 9. 回文数 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p13.%E5%9B%9E%E6%96%87%E6%95%B0%E5%AD%97%E5%88%A4%E6%96%AD/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P13. 回文数字判断","uri":"/posts/p13.%E5%9B%9E%E6%96%87%E6%95%B0%E5%AD%97%E5%88%A4%E6%96%AD/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个单链表表示的数，你要判断它是不是一个回文数字。回文数字就是正着读和反着读都相同的数字。","date":"2025-05-05","objectID":"/posts/p14.%E5%88%A4%E6%96%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/","tags":["AlgoCasts","LeetCode"],"title":"P14. 判断单链表是否为回文链表","uri":"/posts/p14.%E5%88%A4%E6%96%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个单链表表示的数，你要判断它是不是一个回文数字。回文数字就是正着读和反着读都相同的数字。 比如说，给你的链表是： 4 -\u003e 2 它表示 42，反过来是 24，不是一个回文数字，因此你要返回 false。 再比如说，给你的链表是： 4 -\u003e 2 -\u003e 2 -\u003e 4 它表示 4224，反过来也是 4224，它是一个回文数字，因此你要返回 true。 2 LeetCode 234. 回文链表 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p14.%E5%88%A4%E6%96%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P14. 判断单链表是否为回文链表","uri":"/posts/p14.%E5%88%A4%E6%96%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，从 0 到 n 这 n+1 个整数中去掉一个，然后把剩下的 n 个整数放进一个长度为 n 的数组，给你这个数组，你要找到那个去掉的整数。","date":"2025-05-05","objectID":"/posts/p15.%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/","tags":["AlgoCasts","LeetCode"],"title":"P15. 缺失的数字","uri":"/posts/p15.%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，从 0 到 n 这 n+1 个整数中去掉一个，然后把剩下的 n 个整数放进一个长度为 n 的数组，给你这个数组，你要找到那个去掉的整数。 比如说，给你的数组是： 4, 1, 0, 2 这里的数组长度是 4，说明这是从 0 到 4 中去掉一个数字后形成的数组。数组中缺失的数字是 3，因此我们要返回 3。 2 LeetCode 268. 丢失的数字 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p15.%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P15. 缺失的数字","uri":"/posts/p15.%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，你要实现一个函数，用它来计算浮点数的 n 次方。","date":"2025-05-05","objectID":"/posts/p10.%E6%95%B0%E5%80%BC%E7%9A%84n%E6%AC%A1%E6%96%B9/","tags":["AlgoCasts","LeetCode"],"title":"P10. 数值的 n 次方","uri":"/posts/p10.%E6%95%B0%E5%80%BC%E7%9A%84n%E6%AC%A1%E6%96%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，你要实现一个函数，用它来计算浮点数的 n 次方。 比如说，给你 2 和 11，你要计算出 2 的 11 次方的结果： f(2, 11) = 2^11 2 LeetCode 50. Pow(x, n) 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p10.%E6%95%B0%E5%80%BC%E7%9A%84n%E6%AC%A1%E6%96%B9/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P10. 数值的 n 次方","uri":"/posts/p10.%E6%95%B0%E5%80%BC%E7%9A%84n%E6%AC%A1%E6%96%B9/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组，并且数组中没有重复元素，你要返回这个数组所有可能的排列。","date":"2025-05-05","objectID":"/posts/p11.%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97/","tags":["AlgoCasts","LeetCode"],"title":"P11. 数组的全排列","uri":"/posts/p11.%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组，并且数组中没有重复元素，你要返回这个数组所有可能的排列。 比如说给你的数组是： 0, 1, 2 你要返回的所有排列是： 0, 1, 2 0, 2, 1 1, 0, 2 1, 2, 0 2, 0, 1 2, 1, 0 2 LeetCode 46. 全排列 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p11.%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P11. 数组的全排列","uri":"/posts/p11.%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个字符串，你要计算出它所包含的回文子串个数。只要起始下标或终止下标不同，即使子串相同，我们也认为是不同的回文子串。","date":"2025-05-05","objectID":"/posts/p12.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E4%B8%AA%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P12. 回文子串个数","uri":"/posts/p12.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个字符串，你要计算出它所包含的回文子串个数。只要起始下标或终止下标不同，即使子串相同，我们也认为是不同的回文子串。 比如说，给你的字符串是： abc 这个字符串中总共有 3 个回文子串，分别是 a，b 和 c。因此你要返回的个数是 3。 再比如说，给你的字符串是： aba 这个字符串中总共有 4 个回文子串，分别是 a，b，a，和 aba。因此你要返回的个数是 4。 2 LeetCode 647. 回文子串 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p12.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E4%B8%AA%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P12. 回文子串个数","uri":"/posts/p12.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个二维数组 matrix，和一个目标值 target。你要在数组里找到这个目标值，然后返回它的行/列下标。如果找不到，则返回 [-1,-1]。","date":"2025-05-05","objectID":"/posts/p7.%E8%A1%8C%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%90%9C%E7%B4%A2/","tags":["AlgoCasts","LeetCode"],"title":"P7. 行列递增的二维数组搜索","uri":"/posts/p7.%E8%A1%8C%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%90%9C%E7%B4%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个二维数组 matrix，和一个目标值 target。你要在数组里找到这个目标值，然后返回它的行/列下标。如果找不到，则返回 [-1,-1]。 这个数组的每一行都是从左向右递增，每一列都是从上到下递增。和「二维数组的二分搜索」不同，这道题目并不保证每一行的第一个数都比上一行的最后一个数要大。 比如说，给你的二维数组是： 1, 3, 5 2, 4, 6 给你的目标值是 4。目标值 4 在这个数组中，找到后返回它的下标 [1, 1] 即可。 如果给你的目标值是 100，显然它不在这个二维数组中，你要返回 [-1，-1]。 2 LeetCode 240. 搜索二维矩阵 II 3 难度 中等 4 题解 ","date":"2025-05-05","objectID":"/posts/p7.%E8%A1%8C%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%90%9C%E7%B4%A2/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P7. 行列递增的二维数组搜索","uri":"/posts/p7.%E8%A1%8C%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%90%9C%E7%B4%A2/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两个二叉树，你要判断它们是否相同。这里所谓相同，指的是两棵树结构相同，并且相应节点上的数值相等。","date":"2025-05-05","objectID":"/posts/p8.%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C/","tags":["AlgoCasts","LeetCode"],"title":"P8. 判断二叉树是否相同","uri":"/posts/p8.%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两个二叉树，你要判断它们是否相同。这里所谓相同，指的是两棵树结构相同，并且相应节点上的数值相等。 比如说，给你的两棵二叉树都是： 1 1 / \\ / \\ 2 4 2 4 它们的结构相同，相应节点上的值也相等，因此返回 true。如果另一棵树是： 1 / \\ 2 5 或 1 / 2 / 4 两棵树则不相同，返回 false。 2 LeetCode 100. 相同的树 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p8.%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P8. 判断二叉树是否相同","uri":"/posts/p8.%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个单链表，你需要反转它，然后返回。","date":"2025-05-05","objectID":"/posts/p9.%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/","tags":["AlgoCasts","LeetCode"],"title":"P9. 反转单链表","uri":"/posts/p9.%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个单链表，你需要反转它，然后返回。 比如说给你的单链表是： 1 -\u003e 2 -\u003e 3 -\u003e 4 -\u003e 5 -\u003e null 你要返回的反转后的链表是： 5 -\u003e 4 -\u003e 3 -\u003e 2 -\u003e 1 -\u003e null 2 LeetCode 206. 反转链表 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p9.%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P9. 反转单链表","uri":"/posts/p9.%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你两个整数，在不使用 +/- 这两个运算符的前提下，求它们的和。","date":"2025-05-05","objectID":"/posts/p5.%E4%B8%8D%E7%94%A8-%E5%92%8C-%E6%B1%82%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","tags":["AlgoCasts","LeetCode"],"title":"P5. 不用+/-求两数之和","uri":"/posts/p5.%E4%B8%8D%E7%94%A8-%E5%92%8C-%E6%B1%82%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你两个整数，在不使用 +/- 这两个运算符的前提下，求它们的和。 2 LeetCode 371. 两整数之和 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p5.%E4%B8%8D%E7%94%A8-%E5%92%8C-%E6%B1%82%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P5. 不用+/-求两数之和","uri":"/posts/p5.%E4%B8%8D%E7%94%A8-%E5%92%8C-%E6%B1%82%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个非空的整数数组，这个数组中有一个整数只出现了一次，其它的整数都出现两次，你要找出这个只出现一次的整数。","date":"2025-05-05","objectID":"/posts/p6.%E5%8D%95%E8%BA%AB%E6%95%B0%E5%AD%97/","tags":["AlgoCasts","LeetCode"],"title":"P6. 单身数字","uri":"/posts/p6.%E5%8D%95%E8%BA%AB%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个非空的整数数组，这个数组中有一个整数只出现了一次，其它的整数都出现两次，你要找出这个只出现一次的整数。 比如说，给你的数组是： 5, 7, 5, 6, 6 这里 7 只出现了一次，因此你要返回的就是 7。 2 LeetCode 136. 只出现一次的数字 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p6.%E5%8D%95%E8%BA%AB%E6%95%B0%E5%AD%97/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P6. 单身数字","uri":"/posts/p6.%E5%8D%95%E8%BA%AB%E6%95%B0%E5%AD%97/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组和一个目标值，你要找到数组里两个整数，它们的和等于目标值。然后返回这两个整数的下标。","date":"2025-05-05","objectID":"/posts/p2.%E6%B1%82%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P2. 求和为给定值的两个数","uri":"/posts/p2.%E6%B1%82%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组和一个目标值，你要找到数组里两个整数，它们的和等于目标值。然后返回这两个整数的下标。 比如说给你的整数数组是： 1, 2, 3, 6, 8, 11 目标值是 10。那么，满足条件的两个整数是，2 和 8，它们的和是 10。所以你要返回它们的下标是 1 和 4。 2 LeetCode 1. 两数之和 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p2.%E6%B1%82%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P2. 求和为给定值的两个数","uri":"/posts/p2.%E6%B1%82%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个整数数组，并且这个数组是按递增排序的，你要找到数组中的两个整数，它们的和等于给定的目标值，然后返回它们的下标。题目假设给你的数组总是有且只有一个解，而且同一个元素不能使用两次。另外，返回结果的下标要从 1 开始。","date":"2025-05-05","objectID":"/posts/p3.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B1%82%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0/","tags":["AlgoCasts","LeetCode"],"title":"P3. 有序数组中求和为给定值的两个数","uri":"/posts/p3.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B1%82%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个整数数组，并且这个数组是按递增排序的，你要找到数组中的两个整数，它们的和等于给定的目标值，然后返回它们的下标。题目假设给你的数组总是有且只有一个解，而且同一个元素不能使用两次。另外，返回结果的下标要从 1 开始。 比如说给你的数组是： 1, 2, 3, 6, 8, 11 目标值是 10。那么，满足条件的两个整数是，2 和 8，它们的和是 10。所以你要返回它们的下标是 [2, 5]。 2 LeetCode 167. 两数之和 II - 输入有序数组 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p3.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B1%82%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P3. 有序数组中求和为给定值的两个数","uri":"/posts/p3.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B1%82%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个二叉树，你要判断它是否沿中轴线对称。","date":"2025-05-05","objectID":"/posts/p4.%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0/","tags":["AlgoCasts","LeetCode"],"title":"P4. 判断二叉树是否对称","uri":"/posts/p4.%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个二叉树，你要判断它是否沿中轴线对称。 比如说，给你的二叉树是： 1 / \\ 2 2 / \\ / \\ 4 8 8 4 这棵二叉树是沿中轴线对称的，因此要返回 true。如果我去掉最后这个 4： 1 / \\ 2 2 / \\ / 4 8 8 就不对称了，这时就要返回 false。 2 LeetCode 101. 对称二叉树 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p4.%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P4. 判断二叉树是否对称","uri":"/posts/p4.%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0/"},{"categories":["AlgoCasts","LeetCode"],"content":"这个题目说的是，给你一个字符串，你要判断它是否是回文字符串。字符串里只考虑字母和数字，其它的字符可以无视。另外，对于字母，可以忽略大小写。","date":"2025-05-05","objectID":"/posts/p1.%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A4%E6%96%AD/","tags":["AlgoCasts","LeetCode"],"title":"P1. 回文字符串判断","uri":"/posts/p1.%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A4%E6%96%AD/"},{"categories":["AlgoCasts","LeetCode"],"content":"1 描述 这个题目说的是，给你一个字符串，你要判断它是否是回文字符串。字符串里只考虑字母和数字，其它的字符可以无视。另外，对于字母，可以忽略大小写。 比如说，给你的字符串是： \" race a E-car \" 只考虑字母数字并且忽略大小写，它是一个回文字符串，因此返回 true。再比如说，给你的字符串是 \" race a car \" 对比到最后，中间的 e 和 a 不相等，因此不是一个回文字符串，返回 false。 2 LeetCode 125. 验证回文串 3 难度 简单 4 题解 ","date":"2025-05-05","objectID":"/posts/p1.%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A4%E6%96%AD/:0:0","tags":["AlgoCasts","LeetCode"],"title":"P1. 回文字符串判断","uri":"/posts/p1.%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A4%E6%96%AD/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"MySQL 中的自增 id 存在上限问题，本文从表定义自增值 id、InnoDB 系统自增 row_id 和 Xid 三个方面分析了自增 id 达到上限后可能出现的情况。","date":"2025-03-10","objectID":"/posts/45.%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E/","tags":["MySQL 实战 45 讲","MySQL"],"title":"45 | 自增 id 用完怎么办？","uri":"/posts/45.%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 MySQL 中的自增 id 存在上限问题，本文从表定义自增值 id、InnoDB 系统自增 row_id 和 Xid 三个方面分析了自增 id 达到上限后可能出现的情况。在表定义自增值 id 方面，当自增 id 达到上限后，可能导致主键冲突错误。在 InnoDB 系统自增 row_id 方面，达到上限后可能导致数据覆盖。而在 Xid 方面，可能会出现同一个 binlog 里面出现相同 Xid 的场景。此外，文章还介绍了 Innodb trx_id Xid 和 InnoDB 的 trx_id 的概念，以及 thread_id 的逻辑。 MySQL 里有很多自增的 id，每个自增 id 都是定义了初始值，然后不停地往上加步长。虽然自然数是没有上限的，但是在计算机里，只要定义了表示这个数的字节长度，那它就有上限。比如，无符号整型 (unsigned int) 是 4 个字节，上限就是 232-1。 既然自增 id 有上限，就有可能被用完。但是，自增 id 用完了会怎么样呢？ 1 表定义自增值 id 表定义的自增值达到上限后的逻辑是：再申请下一个 id 时，得到的值保持不变。可以通过下面这个语句序列验证一下： create table t(id int unsigned auto_increment primary key) auto_increment=4294967295; insert into t values(null); //成功插入一行 4294967295 show create table t; /* CREATE TABLE `t` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=4294967295; */ insert into t values(null); //Duplicate entry '4294967295' for key 'PRIMARY' 可以看到，第一个 insert 语句插入数据成功后，这个表的 AUTO_INCREMENT 没有改变（还是 4294967295），就导致了第二个 insert 语句又拿到相同的自增 id 值，再试图执行插入语句，报主键冲突错误。 232-1（4294967295）不是一个特别大的数，对于一个频繁插入删除数据的表来说，是可能会被用完的。因此在建表的时候需要考察表是否有可能达到这个上限，如果有可能，就应该创建成 8 个字节的 bigint unsigned。 2 InnoDB 系统自增 row_id 如果创建的 InnoDB 表没有指定主键，那么 InnoDB 会创建一个不可见的，长度为 6 个字节的 row_id。InnoDB 维护了一个全局的 dict_sys.row_id 值，所有无主键的 InnoDB 表，每插入一行数据，都将当前的 dict_sys.row_id 值作为要插入数据的 row_id，然后把 dict_sys.row_id 的值加 1。 实际上，在代码实现时 row_id 是一个长度为 8 字节的无符号长整型 (bigint unsigned)。但是，InnoDB 在设计时，给 row_id 留的只是 6 个字节的长度，这样写到数据表中时只放了最后 6 个字节，所以 row_id 能写到数据表中的值，就有两个特征： row_id 写入表中的值范围，是从 0 到 248-1； 当 dict_sys.row_id=248时，如果再有插入数据的行为要来申请 row_id，拿到以后再取最后 6 个字节的话就是 0。 也就是说，写入表的 row_id 是从 0 开始到 248-1。达到上限后，下一个值就是 0，然后继续循环。 当然，248-1 这个值本身已经很大了，但是如果一个 MySQL 实例跑得足够久的话，还是可能达到这个上限的。在 InnoDB 逻辑里，申请到 row_id=N 后，就将这行数据写入表中；如果表中已经存在 row_id=N 的行，新写入的行就会覆盖原有的行。 要验证这个结论的话，可以通过 gdb 修改系统的自增 row_id 来实现。注意，用 gdb 改变量这个操作是为了便于复现问题，只能在测试环境使用。 可以看到，在用 gdb 将 dict_sys.row_id 设置为 248之后，再插入的 a=2 的行会出现在表 t 的第一行，因为这个值的 row_id=0。之后再插入的 a=3 的行，由于 row_id=1，就覆盖了之前 a=1 的行，因为 a=1 这一行的 row_id 也是 1。 从这个角度看，还是应该在 InnoDB 表中主动创建自增主键。因为，表自增 id 到达上限后，再插入数据时报主键冲突错误，是更能被接受的。 毕竟覆盖数据，就意味着数据丢失，影响的是数据可靠性；报主键冲突，是插入失败，影响的是可用性。而一般情况下，可靠性优先于可用性。 3 Xid 介绍 redo log 和 binlog 相配合的时候，提到了它们有一个共同的字段叫作 Xid。它在 MySQL 中是用来对应事务的。那么，Xid 在 MySQL 内部是怎么生成的呢？ MySQL 内部维护了一个全局变量 global_query_id，每次执行语句的时候将它赋值给 Query_id，然后给这个变量加 1。如果当前语句是这个事务执行的第一条语句，那么 MySQL 还会同时把 Query_id 赋值给这个事务的 Xid。 而 global_query_id 是一个纯内存变量，重启之后就清零了。所以在同一个数据库实例中，不同事务的 Xid 也是有可能相同的。但是 MySQL 重启之后会重新生成新的 binlog 文件，这就保证了，同一个 binlog 文件里，Xid 一定是惟一的。 虽然 MySQL 重启不会导致同一个 binlog 里面出现两个相同的 Xid，但是如果 global_query_id 达到上限后，就会继续从 0 开始计数。从理论上讲，还是就会出现同一个 binlog 里面出现相同 Xid 的场景。 因为 global_query_id 定义的长度是 8 个字节，这个自增值的上限是 264-1。要出现这种情况，必须是下面这样的过程： 执行一个事务，假设 Xid 是 A； 接下来执行 264次查询语句，让 global_query_id 回到 A； 再启动一个事务，这个事务的 Xid 也是 A。 不过，264这个值太大了，大到可以认为这个可能性只会存在于理论上。 4 Innodb trx_id Xid 和 InnoDB 的 trx_id 是两个容易混淆的概念。Xid 是由 server 层维护的。InnoDB 内部使用 Xid，就是为了能够在 InnoDB 事务和 server 之间做关联。但是，InnoDB 自己的 trx_id，是另外维护的。也就是讲事务可见性时，用到的事务 id（transaction id）。 InnoDB 内部维护了一个 max_trx_id 全局变量，每次需要申请一个新的 trx_id 时，就获得 max_trx_id 的当前值，然后并将 max_trx_id 加 1。 InnoDB 数据可见性的核心思想是：每一行数据都记录了更新它的 trx_id，当一个事务读到一行数据的时候，判断这个数据是否可见的方法，就是通过事务的一致性视图与这行数据的 trx_id 做对比。 对于正在执行的事务，可以从 information_schema.innodb_trx 表中看到事务的 trx_id。上一篇文章的末尾留的思考题，就是关于从 innodb_trx 表里面查到的 trx_id 的。现在一起来看一个事务现场： session B 里，从 innodb_trx 表里查出的这两个字段，第二个字段 trx_mysql_thread_id 就是线程 id。显示线程 id，是为了说明这两次查询看到的事务对应的线程 id 都是 5，也就是 session A 所在的线程。 可以看到，T2 时刻显示的 trx_id 是一个很大的数；T4 时刻显示的 trx_id 是 1289，看上去是一个比较正常的数字。这是什么原因呢？ 实际上，在 T1 时刻，session A 还没有涉及到更新，是一个只读事务。而对于只读事务，InnoDB 并不会分配 trx_id。也就是说： 在 T1 时刻，trx_id 的值其实就是 0。而这个很大的数，只是显示用的。 直到 session A 在 T3 时刻执行 insert 语句的时候，InnoDB 才真正分配了 trx_id。所以，T4 时刻，session B 查到的这个 trx_id 的值就是 1289。 需要注意的是，除了显而易见的修改类语句外，如果在 select 语句后面加上 for update，这个事务也不是只读事务。有的人做实验的时候发现不止加 1。这是因为： update 和 delete 语句除了事务本身，还涉及到标记删除旧数据，也就是要把数据放到 purge 队列里等待后续物理删除，这个操作也会把 max_trx_id+1，因此在一个事务中至少加 2； InnoDB 的后台操作，比如表的索引信息统计这类操作，也是会启动内部事务的，因此可能看到，trx_id 值并不是按照加 1 递增的。 那么，T2 时刻查到的这个很大的数字是怎么来的呢？其实，这个数字是每次查询的时候由系统临时计算出来的。它的算法是：把当前事务的 trx 变量的指针地址转成整数，再加上","date":"2025-03-10","objectID":"/posts/45.%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"45 | 自增 id 用完怎么办？","uri":"/posts/45.%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"SQL join 语句执行顺序和性能优化是本文的主题。","date":"2025-03-10","objectID":"/posts/44.%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%89%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98/","tags":["MySQL 实战 45 讲","MySQL"],"title":"44 | 答疑文章（三）：说一说这些好问题","uri":"/posts/44.%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%89%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 SQL join 语句执行顺序和性能优化是本文的主题，深入讨论了使用 left join 时左表是否一定是驱动表、join 语句中条件放在 on 部分和 where 部分的区别，以及 left join 语义下被驱动表字段放在 where 条件中的影响。通过实际案例和执行计划的分析，详细解释了这些问题的原理和执行过程。 1 join 的写法 之前讲 join 语句优化的时候用的都是 straight_join。 如果用 left join 的话，左边的表一定是驱动表吗？ 如果两个表的 join 包含多个条件的等值匹配，是都要写到 on 里面呢，还是只把一个条件写到 on 里面，其他条件写到 where 部分？ 为了同时回答这两个问题，来构造两个表 a 和 b： create table a(f1 int, f2 int, index(f1))engine=innodb; create table b(f1 int, f2 int)engine=innodb; insert into a values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6); insert into b values(3,3),(4,4),(5,5),(6,6),(7,7),(8,8); 表 a 和 b 都有两个字段 f1 和 f2，不同的是表 a 的字段 f1 上有索引。然后，往两个表中都插入了 6 条记录，其中在表 a 和 b 中同时存在的数据有 4 行。第二个问题，其实就是下面这两种写法的区别： select * from a left join b on(a.f1=b.f1) and (a.f2=b.f2); /*Q1*/ select * from a left join b on(a.f1=b.f1) where (a.f2=b.f2);/*Q2*/ 把这两条语句分别记为 Q1 和 Q2。首先，需要说明的是，这两个 left join 语句的语义逻辑并不相同。先来看一下它们的执行结果。 可以看到： 语句 Q1 返回的数据集是 6 行，表 a 中即使没有满足匹配条件的记录，查询结果中也会返回一行，并将表 b 的各个字段值填成 NULL。 语句 Q2 返回的是 4 行。从逻辑上可以这么理解，最后的两行，由于表 b 中没有匹配的字段，结果集里面 b.f2 的值是空，不满足 where 部分的条件判断，因此不能作为结果集的一部分。 接下来看看实际执行这两条语句时，MySQL 是怎么做的。先看看语句 Q1 的 explain 结果： 可以看到，这个结果符合预期： 驱动表是表 a，被驱动表是表 b； 由于表 b 的 f1 字段上没有索引，所以使用的是 Block Nested Loop Join（简称 BNL）算法。 看到 BNL 算法，应该知道这条语句的执行流程其实是这样的： 把表 a 的内容读入 join_buffer 中。因为是 select * ，所以字段 f1 和 f2 都被放入 join_buffer 了。 顺序扫描表 b，对于每一行数据，判断 join 条件（也就是 (a.f1=b.f1) and (a.f1=1)）是否满足，满足条件的记录，作为结果集的一行返回。如果语句中有 where 子句，需要先判断 where 部分满足条件后，再返回。 表 b 扫描完成后，对于没有被匹配的表 a 的行（在这个例子中就是 (1,1)、(2,2) 这两行），把剩余字段补上 NULL，再放入结果集中。 对应的流程图如下： 可以看到，这条语句确实是以表 a 为驱动表，而且从执行效果看，也和使用 straight_join 是一样的。那么语句 Q2 的查询结果里面少了最后两行数据，是不是就是把上面流程中的步骤 3 去掉呢？还是先看一下语句 Q2 的 expain 结果吧。 可以看到，这条语句是以表 b 为驱动表的。而如果一条 join 语句的 Extra 字段什么都没写的话，就表示使用的是 Index Nested-Loop Join（简称 NLJ）算法。 因此，语句 Q2 的执行流程是这样的：顺序扫描表 b，每一行用 b.f1 到表 a 中去查，匹配到记录后判断 a.f2=b.f2 是否满足，满足条件的话就作为结果集的一部分返回。 那么，为什么语句 Q1 和 Q2 这两个查询的执行流程会差距这么大呢？其实，这是因为优化器基于 Q2 这个查询的语义做了优化。为了理解这个问题，需要再交代一个背景知识点：在 MySQL 里，NULL 跟任何值执行等值判断和不等值判断的结果，都是 NULL。这里包括，select NULL = NULL 的结果，也是返回 NULL。 因此，语句 Q2 里面 where a.f2=b.f2 就表示，查询结果里面不会包含 b.f2 是 NULL 的行，这样这个 left join 的语义就是“找到这两个表里面，f1、f2 对应相同的行。对于表 a 中存在，而表 b 中匹配不到的行，就放弃”。这样，这条语句虽然用的是 left join，但是语义跟 join 是一致的。 因此，优化器就把这条语句的 left join 改写成了 join，然后因为表 a 的 f1 上有索引，就把表 b 作为驱动表，这样就可以用上 NLJ 算法。在执行 explain 之后，再执行 show warnings，就能看到这个改写的结果，如下图所示。 这个例子说明，即使在 SQL 语句中写成 left join，执行过程还是有可能不是从左到右连接的。也就是说，使用 left join 时，左边的表不一定是驱动表。 这样看来，如果需要 left join 的语义，就不能把被驱动表的字段放在 where 条件里面做等值判断或不等值判断，必须都写在 on 里面。那如果是 join 语句呢？再看看这两条语句： select * from a join b on(a.f1=b.f1) and (a.f2=b.f2); /*Q3*/ select * from a join b on(a.f1=b.f1) where (a.f2=b.f2);/*Q4*/ 再使用一次看 explain 和 show warnings 的方法，看看优化器是怎么做的。 可以看到，这两条语句都被改写成： select * from a join b where (a.f1=b.f1) and (a.f2=b.f2); 执行计划自然也是一模一样的。也就是说，在这种情况下，join 将判断条件是否全部放在 on 部分就没有区别了。 2 Simple Nested Loop Join 的性能问题 之前说过，虽然 BNL 算法和 Simple Nested Loop Join 算法都是要判断 M*N 次（M 和 N 分别是 join 的两个表的行数），但是 Simple Nested Loop Join 算法的每轮判断都要走全表扫描，因此性能上 BNL 算法执行起来会快很多。为了便于说明，还是先简单描述一下这两个算法。 BNL 算法的执行逻辑是： 首先，将驱动表的数据全部读入内存 join_buffer 中，这里 join_buffer 是无序数组； 然后，顺序遍历被驱动表的所有行，每一行数据都跟 join_buffer 中的数据进行匹配，匹配成功则作为结果集的一部分返回。 Simple Nested Loop Join 算法的执行逻辑是：顺序取出驱动表中的每一行数据，到被驱动表去做全表扫描匹配，匹配成功则作为结果集的一部分返回。 那么，Simple Nested Loop Join 算法，其实也是把数据读到内存里，然后按照匹配条件进行判断，为什么性能差距会这么大呢？解释这个问题，需要用到 MySQL 中索引结构和 Buffer Pool 的相关知识点： 在对被驱动表做全表扫描的时候，如果数据没有在 Buffer Pool 中，就需要等待这部分数据从磁盘读入；从磁盘读入数据到内存中，会影响正常业务的 Buffer Pool 命中率，而且这个算法天然会对被驱动表的数据做多次访问，更容易将这些数据页放到 Buffer Pool 的头部。 即使被驱动表数据都在内存中，每次查找“下一个记录的操作”，都是类似指针操作。而 join_buffer 中是数组，遍历的成本更低。 所以说，BNL 算法的性能会更好。 3 distinct 和 group by 的性能 如果只需要去重，不需要执行聚合函数，distinct 和 group by 哪种效率高一些呢？如果表 t 的字段 a 上没有索引，那么下面这两条语句： select a from t group by a order by null; select distinct a from t; 的性能是不是相同的？ 首先需要说明的是，这种 group by 的写法，并不是 SQL 标准的写法。标准的 group by 语句，是需要在 select 部分加一个聚合函数，比如： select a,count(*) from t group by a order by null; 这条语句的逻辑是：按照字段 a 分组，计算每组的 a 出现的次数。在这个结果里，由于做的是聚合计算，相同的 a 只出现一次。 没有了 count(*) 以后，也就是不再需要执行“计算总数”的逻辑时，第一条语句的逻辑就变成是：按照字段 a 做分组，相同的 a 的值只返回一行。而这就是 distinct 的语义，所以不需要执行聚合函数时，distinct 和 group by 这两条语句的语义","date":"2025-03-10","objectID":"/posts/44.%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%89%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"44 | 答疑文章（三）：说一说这些好问题","uri":"/posts/44.%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%89%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"分区表是数据库中的一种组织形式，通过将数据分散存储在不同的分区中，可以提高查询性能和管理大型数据表。","date":"2025-03-10","objectID":"/posts/43.%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8/","tags":["MySQL 实战 45 讲","MySQL"],"title":"43 | 要不要使用分区表？","uri":"/posts/43.%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 分区表是数据库中的一种组织形式，通过将数据分散存储在不同的分区中，可以提高查询性能和管理大型数据表。文章首先介绍了分区表的引擎层行为，包括 InnoDB 和 MyISAM 引擎对分区表的处理方式。其次，文章讨论了手动分表和分区表的区别，指出从引擎层看，这两种方式并没有实质的差别。 1 分区表是什么？ 为了说明分区表的组织形式，先创建一个表 t： CREATE TABLE `t` ( `ftime` datetime NOT NULL, `c` int(11) DEFAULT NULL, KEY (`ftime`) ) ENGINE=InnoDB DEFAULT CHARSET=latin1 PARTITION BY RANGE (YEAR(ftime)) (PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB, PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB, PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB, PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB); insert into t values('2017-4-1',1),('2018-4-1',1); 在表 t 中初始化插入了两行记录，按照定义的分区规则，这两行记录分别落在 p_2018 和 p_2019 这两个分区上。可以看到，这个表包含了一个.frm 文件和 4 个.ibd 文件，每个分区对应一个.ibd 文件。也就是说： 对于引擎层来说，这是 4 个表； 对于 Server 层来说，这是 1 个表。 你可能会觉得这两句都是废话。其实不然，这两句话非常重要，可以帮我们理解分区表的执行逻辑。 2 分区表的引擎层行为 先举个在分区表加间隙锁的例子，目的是说明对于 InnoDB 来说，这是 4 个表。 始化表 t 的时候，只插入了两行数据，ftime 的值分别是，‘2017-4-1’ 和'2018-4-1’ 。session A 的 select 语句对索引 ftime 上这两个记录之间的间隙加了锁。如果是一个普通表的话，那么 T1 时刻，在表 t 的 ftime 索引上，间隙和加锁状态应该是下图这样的。 也就是说，‘2017-4-1’ 和'2018-4-1’ 这两个记录之间的间隙是会被锁住的。那么，sesion B 的两条插入语句应该都要进入锁等待状态。 但是，从上面的实验效果可以看出，session B 的第一个 insert 语句是可以执行成功的。这是因为，对于引擎来说，p_2018 和 p_2019 是两个不同的表，也就是说 2017-4-1 的下一个记录并不是 2018-4-1，而是 p_2018 分区的 supremum。所以 T1 时刻，在表 t 的 ftime 索引上，间隙和加锁的状态其实是下图这样的： 由于分区表的规则，session A 的 select 语句其实只操作了分区 p_2018，因此加锁范围就是上图中深绿色的部分。 所以，session B 要写入一行 ftime 是 2018-2-1 的时候是可以成功的，而要写入 2017-12-1 这个记录，就要等 session A 的间隙锁。 下图就是这时候的 show engine innodb status 的部分结果。 看完 InnoDB 引擎的例子，再来一个 MyISAM 分区表的例子。首先用 alter table t engine=myisam，把表 t 改成 MyISAM 表；然后，再用下面这个例子说明，对于 MyISAM 引擎来说，这是 4 个表。 在 session A 里面，用 sleep(100) 将这条语句的执行时间设置为 100 秒。由于 MyISAM 引擎只支持表锁，所以这条 update 语句会锁住整个表 t 上的读。但看到的结果是，session B 的第一条查询语句是可以正常执行的，第二条语句才进入锁等待状态。 这正是因为 MyISAM 的表锁是在引擎层实现的，session A 加的表锁，其实是锁在分区 p_2018 上。因此，只会堵住在这个分区上执行的查询，落到其他分区的查询是不受影响的。 看到这里，你可能会说，分区表看来还不错嘛，为什么不让用呢？使用分区表的一个重要原因就是单表过大。那么，如果不使用分区表的话，就是要使用手动分表的方式。接下来，一起看看手动分表和分区表有什么区别。 比如，按照年份来划分，就分别创建普通表 t_2017、t_2018、t_2019 等等。手工分表的逻辑，也是找到需要更新的所有分表，然后依次执行更新。在性能上，这和分区表并没有实质的差别。 分区表和手工分表，一个是由 server 层来决定使用哪个分区，一个是由应用层代码来决定使用哪个分表。因此，从引擎层看，这两种方式也是没有差别的。 其实这两个方案的区别，主要是在 server 层上。从 server 层看，就不得不提到分区表一个被广为诟病的问题：打开表的行为。 3 分区策略 每当第一次访问一个分区表的时候，MySQL 需要把所有的分区都访问一遍。一个典型的报错情况是这样的：如果一个分区表的分区很多，比如超过了 1000 个，而 MySQL 启动的时候，open_files_limit 参数使用的是默认值 1024，那么就会在访问这个表的时候，由于需要打开所有的文件，导致打开表文件的个数超过了上限而报错。下图就是一个包含了很多分区的表 t_myisam，执行一条插入语句后报错的情况。 可以看到，这条 insert 语句，明显只需要访问一个分区，但语句却无法执行。这时，从表名可以猜到，这个表是 MyISAM 引擎。是的，因为使用 InnoDB 引擎的话，并不会出现这个问题。 MyISAM 分区表使用的分区策略，称为通用分区策略（generic partitioning），每次访问分区都由 server 层控制。通用分区策略，是 MySQL 一开始支持分区表的时候就存在的代码，在文件管理、表管理的实现上很粗糙，因此有比较严重的性能问题。 从 MySQL 5.7.9 开始，InnoDB 引擎引入了本地分区策略（native partitioning）。这个策略是在 InnoDB 内部自己管理打开分区的行为。 MySQL 从 5.7.17 开始，将 MyISAM 分区表标记为即将弃用 (deprecated)，意思是“从这个版本开始不建议这么使用，请使用替代方案。在将来的版本中会废弃这个功能”。 从 MySQL 8.0 版本开始，就不允许创建 MyISAM 分区表了，只允许创建已经实现了本地分区策略的引擎。目前来看，只有 InnoDB 和 NDB 这两个引擎支持了本地分区策略。 4 分区表的 server 层行为 如果从 server 层看的话，一个分区表就只是一个表。接下来就用下面这个例子来说明。如下面两幅图所示，分别是这个例子的操作序列和执行结果图。 可以看到，虽然 session B 只需要操作 p_2017 这个分区，但是由于 session A 持有整个表 t 的 MDL 锁，就导致了 session B 的 alter 语句被堵住。 这也是 DBA 同学经常说的，分区表，在做 DDL 的时候，影响会更大。如果使用的是普通分表，那么在 truncate 一个分表的时候，肯定不会跟另外一个分表上的查询语句，出现 MDL 锁冲突。到这里小结一下： MySQL 在第一次打开分区表的时候，需要访问所有的分区； 在 server 层，认为这是同一张表，因此所有分区共用同一个 MDL 锁； 在引擎层，认为这是不同的表，因此 MDL 锁之后的执行过程，会根据分区表规则，只访问必要的分区。 而关于“必要的分区”的判断，就是根据 SQL 语句中的 where 条件，结合分区规则来实现的。比如上面的例子中，where ftime=‘2018-4-1’，根据分区规则 year 函数算出来的值是 2018，那么就会落在 p_2019 这个分区。 但是，如果这个 where 条件改成 where ftime\u003e=‘2018-4-1’，虽然查询结果相同，但是这时候根据 where 条件，就要访问 p_2019 和 p_others 这两个分区。 如果查询语句的 where 条件中没有分区 key，那就只能访问所有分区了。当然，这并不是分区表的问题。即使是使用业务分表的方式，where 条件中没有使用分表的 key，也必须访问所有的分表。 5 分区表的应用场景 分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区表的业务代码更简洁。还有，分区表可以很方便的清理历史数据。 如果一项业务跑的时间足够长，往往就会有根据时间删除历史数据的需求。这时候，按照时间分区的分区表，就可以直接通过 alter table t drop partition … 这个语法删掉分区，从而删掉过期的历史数据。 这个 alter table t drop partition … 操作是直接删除分区文件，效果跟 drop 普通表类似。与使用 delete 语句删除数据相比，优势是速度快、对系统影响小。 6 小结 实际使用时，分区表跟用户分表比起来，有两个绕不开的问题：一个是第一次访问的时候需要访问所有分区，另一个是共用 MDL 锁。因此，如果要使用分区表，就不要创建太多的分区","date":"2025-03-10","objectID":"/posts/43.%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"43 | 要不要使用分区表？","uri":"/posts/43.%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"MySQL 中 grant 和 flush privileges 命令的作用及影响是本文的重点。","date":"2025-03-10","objectID":"/posts/42.grant%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80flush-privileges%E5%90%97/","tags":["MySQL 实战 45 讲","MySQL"],"title":"42 | grant 之后要跟着 flush privileges 吗？","uri":"/posts/42.grant%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80flush-privileges%E5%90%97/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 MySQL 中 grant 和 flush privileges 命令的作用及影响是本文的重点。grant 命令用于赋予用户权限，包括全局、库级、表和列权限，并对已存在的连接产生不同影响。flush privileges 命令则用于重新加载权限数据，保持内存数据与磁盘数据一致。文章指出，规范使用 grant 和 revoke 语句时不需要随后加上 flush privileges 语句，而 flush privileges 适用于权限数据不一致的情况。 在 MySQL 里面，grant 语句是用来给用户赋权的。在一些操作文档里面提到，grant 之后要马上跟着执行一个 flush privileges 命令，才能使赋权语句生效。那么，grant 之后真的需要执行 flush privileges 吗？如果没有执行这个 flush 命令的话，赋权语句真的不能生效吗？ 接下来介绍一下 grant 语句和 flush privileges 语句分别做了什么事情，然后再一起来分析这个问题。为了便于说明，先创建一个用户： create user 'ua'@'%' identified by 'pa'; 这条语句的逻辑是创建一个用户’ua’@’%’，密码是 pa。注意，在 MySQL 里面，用户名 (user)+ 地址 (host) 才表示一个用户，因此 ua@ip1 和 ua@ip2 代表的是两个不同的用户。这条命令做了两个动作： 磁盘上，往 mysql.user 表里插入一行，由于没有指定权限，所以这行数据上所有表示权限的字段的值都是 N； 内存里，往数组 acl_users 里插入一个 acl_user 对象，这个对象的 access 字段值为 0。 下图就是这个时刻用户 ua 在 user 表中的状态。 在 MySQL 中，用户权限是有不同的范围的。接下来就按照用户权限范围从大到小的顺序依次说明。 1 全局权限 全局权限，作用于整个 MySQL 实例，这些权限信息保存在 mysql 库的 user 表里。如果要给用户 ua 赋一个最高权限的话，语句是这么写的： grant all privileges on *.* to 'ua'@'%' with grant option; 这个 grant 命令做了两个动作： 磁盘上，将 mysql.user 表里，用户’ua’@’%‘这一行的所有表示权限的字段的值都修改为‘Y’； 内存里，从数组 acl_users 中找到这个用户对应的对象，将 access 值（权限位）修改为二进制的“全 1”。 在这个 grant 命令执行完成后，如果有新的客户端使用用户名 ua 登录成功，MySQL 会为新连接维护一个线程对象，然后从 acl_users 数组里查到这个用户的权限，并将权限值拷贝到这个线程对象中。之后在这个连接中执行的语句，所有关于全局权限的判断，都直接使用线程对象内部保存的权限位。基于上面的分析可以知道： grant 命令对于全局权限，同时更新了磁盘和内存。命令完成后即时生效，接下来新创建的连接会使用新的权限。 对于一个已经存在的连接，它的全局权限不受 grant 命令的影响。 需要说明的是，一般在生产环境上要合理控制用户权限的范围。上面用到的这个 grant 语句就是一个典型的错误示范。如果一个用户有所有权限，一般就不应该设置为所有 IP 地址都可以访问。如果要回收上面的 grant 语句赋予的权限，可以使用下面这条命令： revoke all privileges on *.* from 'ua'@'%'; 这条 revoke 命令的用法与 grant 类似，做了如下两个动作： 磁盘上，将 mysql.user 表里，用户’ua’@’%‘这一行的所有表示权限的字段的值都修改为“N”； 内存里，从数组 acl_users 中找到这个用户对应的对象，将 access 的值修改为 0。 2 db 权限 除了全局权限，MySQL 也支持库级别的权限定义。如果要让用户 ua 拥有库 db1 的所有权限，可以执行下面这条命令： grant all privileges on db1.* to 'ua'@'%' with grant option; 基于库的权限记录保存在 mysql.db 表中，在内存里则保存在数组 acl_dbs 中。这条 grant 命令做了如下两个动作： 磁盘上，往 mysql.db 表中插入了一行记录，所有权限位字段设置为“Y”； 内存里，增加一个对象到数组 acl_dbs 中，这个对象的权限位为“全 1”。 下图就是这个时刻用户 ua 在 db 表中的状态。 每次需要判断一个用户对一个数据库读写权限的时候，都需要遍历一次 acl_dbs 数组，根据 user、host 和 db 找到匹配的对象，然后根据对象的权限位来判断。也就是说，grant 修改 db 权限的时候，是同时对磁盘和内存生效的。 grant 操作对于已经存在的连接的影响，在全局权限和基于 db 的权限效果是不同的。接下来，做一个对照试验来分别看一下。 需要说明的是，图中 set global sync_binlog 这个操作是需要 super 权限的。 可以看到，虽然用户 ua 的 super 权限在 T3 时刻已经通过 revoke 语句回收了，但是在 T4 时刻执行 set global 的时候，权限验证还是通过了。这是因为 super 是全局权限，这个权限信息在线程对象中，而 revoke 操作影响不到这个线程对象。 而在 T5 时刻去掉 ua 对 db1 库的所有权限后，在 T6 时刻 session B 再操作 db1 库的表，就会报错“权限不足”。这是因为 acl_dbs 是一个全局数组，所有线程判断 db 权限都用这个数组，这样 revoke 操作马上就会影响到 session B。 这里在代码实现上有一个特别的逻辑，如果当前会话已经处于某一个 db 里面，之前 use 这个库的时候拿到的库权限会保存在会话变量中。 可以看到在 T6 时刻，session C 和 session B 对表 t 的操作逻辑是一样的。但是 session B 报错，而 session C 可以执行成功。这是因为 session C 在 T2 时刻执行的 use db1，拿到了这个库的权限，在切换出 db1 库之前，session C 对这个库就一直有权限。 3 表权限和列权限 除了 db 级别的权限外，MySQL 支持更细粒度的表权限和列权限。其中，表权限定义存放在表 mysql.tables_priv 中，列权限定义存放在表 mysql.columns_priv 中。这两类权限，组合起来存放在内存的 hash 结构 column_priv_hash 中。这两类权限的赋权命令如下： create table db1.t1(id int, a int); grant all privileges on db1.t1 to 'ua'@'%' with grant option; GRANT SELECT(id), INSERT (id,a) ON mydb.mytbl TO 'ua'@'%' with grant option; 跟 db 权限类似，这两个权限每次 grant 的时候都会修改数据表，也会同步修改内存中的 hash 结构。因此，对这两类权限的操作，也会马上影响到已经存在的连接。 看到这里，你一定会问，看来 grant 语句都是即时生效的，那这么看应该就不需要执行 flush privileges 语句了呀。答案也确实是这样的。 flush privileges 命令会清空 acl_users 数组，然后从 mysql.user 表中读取数据重新加载，重新构造一个 acl_users 数组。也就是说，以数据表中的数据为准，会将全局权限内存数组重新加载一遍。 同样地，对于 db 权限、表权限和列权限，MySQL 也做了这样的处理。也就是说，如果内存的权限数据和磁盘数据表相同的话，不需要执行 flush privileges。而如果都是用 grant/revoke 语句来执行的话，内存和数据表本来就是保持同步更新的。 因此，正常情况下，grant 命令之后，没有必要跟着执行 flush privileges 命令。 4 flush privileges 使用场景 那么，flush privileges 是在什么时候使用呢？显然，当数据表中的权限数据跟内存中的权限数据不一致的时候，flush privileges 语句可以用来重建内存数据，达到一致状态。 这种不一致往往是由不规范的操作导致的，比如直接用 DML 语句操作系统权限表。来看一下下面这个场景： 可以看到，T3 时刻虽然已经用 delete 语句删除了用户 ua，但是在 T4 时刻，仍然可以用 ua 连接成功。原因就是，这时候内存中 acl_users 数组中还有这个用户，因此系统判断时认为用户还正常存在。 在 T5 时刻执行过 flush 命令后，内存更新，T6 时刻再要用 ua 来登录的话，就会报错“无法访问”了。 直接操作系统表是不规范的操作，这个不一致状态也会导致一些更“诡异”的现象发生。比如，前面这个通过 delete 语句删除用户的例子，就会出现下面的情况： 可以看到，由于在 T3 时刻直接删除了数据表的记录，而内存的数据还存在。这就导致了： T4 时刻给用户 ua 赋权限失败，因为 mysql.user 表中找不到这行记录； 而 T5 时刻要重新创建","date":"2025-03-10","objectID":"/posts/42.grant%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80flush-privileges%E5%90%97/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"42 | grant 之后要跟着 flush privileges 吗？","uri":"/posts/42.grant%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80flush-privileges%E5%90%97/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文介绍了在 MySQL 中最快地复制一张表的方法，包括使用 mysqldump 命令导出 INSERT 语句、直接导出.csv 文件以及使用 mysqldump 的--tab 参数导出表结构定义文件和 CSV 数据文件的方法。","date":"2025-03-10","objectID":"/posts/41.%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/","tags":["MySQL 实战 45 讲","MySQL"],"title":"41 | 怎么最快地复制一张表？","uri":"/posts/41.%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文介绍了在 MySQL 中最快地复制一张表的方法，包括使用 mysqldump 命令导出 INSERT 语句、直接导出.csv 文件以及使用 mysqldump 的–tab 参数导出表结构定义文件和 CSV 数据文件的方法。此外，还介绍了在 MySQL 5.6 版本中引入的可传输表空间的方法，实现物理拷贝表的功能。文章总结了三种方法的优缺点，指出物理拷贝方式速度最快，但有一定的局限性；而逻辑备份方式则更为灵活，支持跨引擎使用。 怎么在两张表中拷贝数据。如果可以控制对源表的扫描行数和加锁范围很小的话，简单地使用 insert … select 语句即可实现。 当然，为了避免对源表加读锁，更稳妥的方案是先将数据写到外部文本文件，然后再写回目标表。这时，有两种常用的方法。为了便于说明，还是先创建一个表 db1.t，并插入 1000 行数据，同时创建一个相同结构的表 db2.t。 create database db1; use db1; create table t(id int primary key, a int, b int, index(a))engine=innodb; delimiter ;; create procedure idata() begin declare i int; set i=1; while(i\u003c=1000)do insert into t values(i,i,i); set i=i+1; end while; end;; delimiter ; call idata(); create database db2; create table db2.t like db1.t 假设，要把 db1.t 里面 a\u003e900 的数据行导出来，插入到 db2.t 中。 1 mysqldump 方法 一种方法是使用 mysqldump 命令将数据导出成一组 INSERT 语句。可以使用下面的命令： mysqldump -h$host -P$port -u$user --add-locks=0 --no-create-info --single-transaction --set-gtid-purged=OFF db1 t --where=\"a\u003e900\" --result-file=/client_tmp/t.sql 把结果输出到临时文件。这条命令中，主要参数含义如下： –single-transaction 的作用是，在导出数据的时候不需要对表 db1.t 加表锁，而是使用 START TRANSACTION WITH CONSISTENT SNAPSHOT 的方法； –add-locks 设置为 0，表示在输出的文件结果里，不增加\" LOCK TABLES t WRITE;\" ； –no-create-info 的意思是，不需要导出表结构； –set-gtid-purged=off 表示的是，不输出跟 GTID 相关的信息； –result-file 指定了输出文件的路径，其中 client 表示生成的文件是在客户端机器上的。 通过这条 mysqldump 命令生成的 t.sql 文件中就包含了如图 1 所示的 INSERT 语句。 可以看到，一条 INSERT 语句里面会包含多个 value 对，这是为了后续用这个文件来写入数据的时候，执行速度可以更快。 如果希望生成的文件中一条 INSERT 语句只插入一行数据的话，可以在执行 mysqldump 命令时，加上参数–skip-extended-insert。然后，可以通过下面这条命令，将这些 INSERT 语句放到 db2 库里去执行。 mysql -h127.0.0.1 -P13000 -uroot db2 -e \"source /client_tmp/t.sql\" 需要说明的是，source 并不是一条 SQL 语句，而是一个客户端命令。mysql 客户端执行这个命令的流程是这样的： 打开文件，默认以分号为结尾读取一条条的 SQL 语句； 将 SQL 语句发送到服务端执行。 也就是说，服务端执行的并不是这个“source t.sql\"语句，而是 INSERT 语句。所以，不论是在慢查询日志（slow log），还是在 binlog，记录的都是这些要被真正执行的 INSERT 语句。 2 导出 CSV 文件 另一种方法是直接将结果导出成.csv 文件。MySQL 提供了下面的语法，用来将查询结果导出到服务端本地目录： select * from db1.t where a\u003e900 into outfile '/server_tmp/t.csv'; 在使用这条语句时，需要注意如下几点。 这条语句会将结果保存在服务端。如果执行命令的客户端和 MySQL 服务端不在同一个机器上，客户端机器的临时目录下是不会生成 t.csv 文件的。 into outfile 指定了文件的生成位置（/server_tmp/），这个位置必须受参数 secure_file_priv 的限制。参数 secure_file_priv 的可选值和作用分别是： 如果设置为 empty，表示不限制文件生成的位置，这是不安全的设置； 如果设置为一个表示路径的字符串，就要求生成的文件只能放在这个指定的目录，或者它的子目录； 如果设置为 NULL，就表示禁止在这个 MySQL 实例上执行 select … into outfile 操作。 这条命令不会帮你覆盖文件，因此需要确保 /server_tmp/t.csv 这个文件不存在，否则执行语句时就会因为有同名文件的存在而报错。 这条命令生成的文本文件中，原则上一个数据行对应文本文件的一行。但是，如果字段中包含换行符，在生成的文本中也会有换行符。不过类似换行符、制表符这类符号，前面都会跟上“\\”这个转义符，这样就可以跟字段之间、数据行之间的分隔符区分开。 得到.csv 导出文件后，就可以用下面的 load data 命令将数据导入到目标表 db2.t 中。 load data infile '/server_tmp/t.csv' into table db2.t; 这条语句的执行流程如下所示。 打开文件 /server_tmp/t.csv，以制表符 (\\t) 作为字段间的分隔符，以换行符（\\n）作为记录之间的分隔符，进行数据读取； 启动事务。 判断每一行的字段数与表 db2.t 是否相同： 若不相同，则直接报错，事务回滚； 若相同，则构造成一行，调用 InnoDB 引擎接口，写入到表中。 重复步骤 3，直到 /server_tmp/t.csv 整个文件读入完成，提交事务。 如果 binlog_format=statement，这个 load 语句记录到 binlog 里以后，怎么在备库重放呢？由于 /server_tmp/t.csv 文件只保存在主库所在的主机上，如果只是把这条语句原文写到 binlog 中，在备库执行的时候，备库的本地机器上没有这个文件，就会导致主备同步停止。所以，这条语句执行的完整流程，其实是下面这样的。 主库执行完成后，将 /server_tmp/t.csv 文件的内容直接写到 binlog 文件中。 往 binlog 文件中写入语句 load data local infile‘/tmp/SQL_LOAD_MB-1-0’INTO TABLE db2.t。 把这个 binlog 日志传到备库。 备库的 apply 线程在执行这个事务日志时： 先将 binlog 中 t.csv 文件的内容读出来，写入到本地临时目录 /tmp/SQL_LOAD_MB-1-0 中； 再执行 load data 语句，往备库的 db2.t 表中插入跟主库相同的数据。 执行流程如下图所示： 注意，这里备库执行的 load data 语句里面，多了一个“local”。它的意思是“将执行这条命令的客户端所在机器的本地文件 /tmp/SQL_LOAD_MB-1-0 的内容，加载到目标表 db2.t 中”。也就是说，load data 命令有两种用法： 不加“local”，是读取服务端的文件，这个文件必须在 secure_file_priv 指定的目录或子目录下； 加上“local”，读取的是客户端的文件，只要 mysql 客户端有访问这个文件的权限即可。这时候，MySQL 客户端会先把本地文件传给服务端，然后执行上述的 load data 流程。 另外需要注意的是，select …into outfile 方法不会生成表结构文件，所以导数据时还需要单独的命令得到表结构定义。mysqldump 提供了一个–tab 参数，可以同时导出表结构定义文件和 csv 数据文件。这条命令的使用方法如下： mysqldump -h$host -P$port -u$user ---single-transaction --set-gtid-purged=OFF db1 t --where=\"a\u003e900\" --tab=$secure_file_priv 这条命令会在 $secure_file_priv 定义的目录下，创建一个 t.sql 文件保存建表语句，同时创建一个 t.txt 文件保存 CSV 数据。 3 物理拷贝方法 前面提到的 mysqldump 方法和导出 CSV 文件的方法，都是逻辑导数据的方法，也就是将数据从表 db1.t 中读出来，生成文本，然后再写入目标表 db2.t 中。那么有物理导数据的方法吗？比如，直接把 db1.t 表的.frm 文件和.ibd 文件拷贝到 db2 ","date":"2025-03-10","objectID":"/posts/41.%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"41 | 怎么最快地复制一张表？","uri":"/posts/41.%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"MySQL 的 insert 语句在执行过程中可能会涉及到不同的锁，导致一些特殊情况下的性能问题。","date":"2025-03-10","objectID":"/posts/40.insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A/","tags":["MySQL 实战 45 讲","MySQL"],"title":"40 | insert 语句的锁为什么这么多？","uri":"/posts/40.insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 MySQL 的 insert 语句在执行过程中可能会涉及到不同的锁，导致一些特殊情况下的性能问题。文章深入剖析了在可重复读隔离级别下，binlog_format=statement 时执行 insert … select 语句时，需要对表 t 的所有行和间隙加锁的情况。同时，讨论了 insert 循环写入的情况，以及对目标表的锁范围和执行流程。文章还介绍了执行 insert … select 语句时的慢查询日志和 explain 结果，以及对 InnoDB 扫描行数的分析。最后，提出了针对这类语句的优化方法，以及使用内存临时表来优化的写法。 MySQL 对自增主键锁做了优化，尽量在申请到自增 id 以后，就释放自增锁。因此，insert 语句是一个很轻量的操作。不过，这个结论对于“普通的 insert 语句”才有效。也就是说，还有些 insert 语句是属于“特殊情况”的，在执行过程中需要给其他资源加锁，或者无法在申请到自增 id 以后就立马释放自增锁。 1 insert … select 语句 表 t 和 t2 的表结构、初始化数据语句如下，还是先针对这两个表展开。 CREATE TABLE `t` ( `id` int(11) NOT NULL AUTO_INCREMENT, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `c` (`c`) ) ENGINE=InnoDB; insert into t values(null, 1,1); insert into t values(null, 2,2); insert into t values(null, 3,3); insert into t values(null, 4,4); create table t2 like t 现在，一起来看看为什么在可重复读隔离级别下，binlog_format=statement 时执行： insert into t2(c,d) select c,d from t; 这个语句时，需要对表 t 的所有行和间隙加锁呢？其实，这个问题需要考虑的还是日志和数据的一致性。看下这个执行序列： 实际的执行效果是，如果 session B 先执行，由于这个语句对表 t 主键索引加了 (-∞,1] 这个 next-key lock，会在语句执行完成后，才允许 session A 的 insert 语句执行。 但如果没有锁的话，就可能出现 session B 的 insert 语句先执行，但是后写入 binlog 的情况。于是，在 binlog_format=statement 的情况下，binlog 里面就记录了这样的语句序列： insert into t values(-1,-1,-1); insert into t2(c,d) select c,d from t; 这个语句到了备库执行，就会把 id=-1 这一行也写到表 t2 中，出现主备不一致。 2 insert 循环写入 当然了，执行 insert … select 的时候，对目标表也不是锁全表，而是只锁住需要访问的资源。如果现在有这么一个需求：要往表 t2 中插入一行数据，这一行的 c 值是表 t 中 c 值的最大值加 1。此时，可以这么写这条 SQL 语句： insert into t2(c,d) (select c+1, d from t force index(c) order by c desc limit 1); 这个语句的加锁范围，就是表 t 索引 c 上的 (3,4] 和 (4,supremum] 这两个 next-key lock，以及主键索引上 id=4 这一行。 它的执行流程也比较简单，从表 t 中按照索引 c 倒序，扫描第一行，拿到结果写入到表 t2 中。因此整条语句的扫描行数是 1。这个语句执行的慢查询日志（slow log），如下图所示： 通过这个慢查询日志，看到 Rows_examined=1，正好验证了执行这条语句的扫描行数为 1。那么，如果要把这样的一行数据插入到表 t 中的话： insert into t(c,d) (select c+1, d from t force index(c) order by c desc limit 1); 语句的执行流程是怎样的？扫描行数又是多少呢？这时候，再看慢查询日志就会发现不对了。 可以看到，这时候的 Rows_examined 的值是 5。如下图所示就是这条语句的 explain 结果。 从 Extra 字段可以看到“Using temporary”字样，表示这个语句用到了临时表。也就是说，执行过程中，需要把表 t 的内容读出来，写入临时表。 图中 rows 显示的是 1，不妨先对这个语句的执行流程做一个猜测：如果说是把子查询的结果读出来（扫描 1 行），写入临时表，然后再从临时表读出来（扫描 1 行），写回表 t 中。那么，这个语句的扫描行数就应该是 2，而不是 5。 所以，这个猜测不对。实际上，Explain 结果里的 rows=1 是因为受到了 limit 1 的影响。从另一个角度考虑的话，可以看看 InnoDB 扫描了多少行。如下图所示，是在执行这个语句前后查看 Innodb_rows_read 的结果。 可以看到，这个语句执行前后，Innodb_rows_read 的值增加了 4。因为默认临时表是使用 Memory 引擎的，所以这 4 行查的都是表 t，也就是说对表 t 做了全表扫描。这样，就把整个执行过程理清楚了： 创建临时表，表里有两个字段 c 和 d。 按照索引 c 扫描表 t，依次取 c=4、3、2、1，然后回表，读到 c 和 d 的值写入临时表。这时，Rows_examined=4。 由于语义里面有 limit 1，所以只取了临时表的第一行，再插入到表 t 中。这时，Rows_examined 的值加 1，变成了 5。 也就是说，这个语句会导致在表 t 上做全表扫描，并且会给索引 c 上的所有间隙都加上共享的 next-key lock。所以，这个语句执行期间，其他事务不能在这个表上插入数据。 至于这个语句的执行为什么需要临时表，原因是这类一边遍历数据，一边更新数据的情况，如果读出来的数据直接写回原表，就可能在遍历过程中，读到刚刚插入的记录，新插入的记录如果参与计算逻辑，就跟语义不符。 由于实现上这个语句没有在子查询中就直接使用 limit 1，从而导致了这个语句的执行需要遍历整个表 t。它的优化方法也比较简单，就是用前面介绍的方法，先 insert into 到临时表 temp_t，这样就只需要扫描一行；然后再从表 temp_t 里面取出这行数据插入表 t1。 当然，由于这个语句涉及的数据量很小，可以考虑使用内存临时表来做这个优化。使用内存临时表优化时，语句序列的写法如下： create temporary table temp_t(c int,d int) engine=memory; insert into temp_t (select c+1, d from t force index(c) order by c desc limit 1); insert into t select * from temp_t; drop table temp_t; 3 insert 唯一键冲突 对于有唯一键的表，插入数据时出现唯一键冲突也是常见的情况了。先举一个简单的唯一键冲突的例子。 这个例子也是在可重复读（repeatable read）隔离级别下执行的。可以看到，session B 要执行的 insert 语句进入了锁等待状态。 也就是说，session A 执行的 insert 语句，发生唯一键冲突的时候，并不只是简单地报错返回，还在冲突的索引上加了锁。前面说过，一个 next-key lock 就是由它右边界的值定义的。这时候，session A 持有索引 c 上的 (5,10] 共享 next-key lock（读锁）。 再分享一个经典的死锁场景： 在 session A 执行 rollback 语句回滚的时候，session C 几乎同时发现死锁并返回。这个死锁产生的逻辑是这样的： 在 T1 时刻，启动 session A，并执行 insert 语句，此时在索引 c 的 c=5 上加了记录锁。注意，这个索引是唯一索引，因此退化为记录锁。 在 T2 时刻，session B 要执行相同的 insert 语句，发现了唯一键冲突，加上读锁；同样地，session C 也在索引 c 上，c=5 这一个记录上，加了读锁。 T3 时刻，session A 回滚。这时候，session B 和 session C 都试图继续执行插入操作，都要加上写锁。两个 session 都要等待对方的行锁，所以就出现了死锁。 这个流程的状态变化图如下所示。 4 insert into … on duplicate key update 上面这个例子是主键冲突后直接报错，如果是改写成 insert into t values(11,10,10) on duplicate key update d=100; 的话，就会给索引 c 上 (5,10] 加一个排他的 next-key lock（写锁）。 insert into … on duplicate key update 这个语义的逻辑是，插入一行数据，如果碰到唯一","date":"2025-03-10","objectID":"/posts/40.insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"40 | insert 语句的锁为什么这么多？","uri":"/posts/40.insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入探讨了自增主键的不连续性原因及相关技术细节。","date":"2025-03-10","objectID":"/posts/39.%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84/","tags":["MySQL 实战 45 讲","MySQL"],"title":"39 | 自增主键为什么不是连续的？","uri":"/posts/39.%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入探讨了自增主键的不连续性原因及相关技术细节。首先介绍了自增值的保存位置和不同引擎对自增值的保存策略，以及自增值的修改机制和生成算法。此外，分析了 MySQL 设计中不允许自增值回退的原因，主要是为了提升性能。最后，总结了 InnoDB 放弃自增值回退设计的原因，强调了自增主键保证递增但不保证连续的特点。 由于自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，因此索引更紧凑。有的业务设计依赖于自增主键的连续性，也就是说，这个设计假设自增主键是连续的。但实际上，这样的假设是错的，因为自增主键不能保证连续递增。那么什么情况下自增主键会出现“空洞”？为了便于说明，创建一个表 t，其中 id 是自增主键字段、c 是唯一索引。 CREATE TABLE `t` ( `id` int(11) NOT NULL AUTO_INCREMENT, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `c` (`c`) ) ENGINE=InnoDB; 1 自增值保存在哪儿？ 在这个空表 t 里面执行 insert into t values(null, 1, 1); 插入一行数据，再执行 show create table 命令，就可以看到如下图所示的结果： 可以看到，表定义里面出现了一个 AUTO_INCREMENT=2，表示下一次插入数据时，如果需要自动生成自增值，会生成 id=2。 其实，这个输出结果容易引起这样的误解：自增值是保存在表结构定义里的。实际上，表的结构定义存放在后缀名为.frm 的文件中，但是并不会保存自增值。不同的引擎对于自增值的保存策略不同。 MyISAM 引擎的自增值保存在数据文件中。 InnoDB 引擎的自增值，其实是保存在了内存里，并且到了 MySQL 8.0 版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为 MySQL 重启前的值”，具体情况是： 在 MySQL 5.7 及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为这个表当前的自增值。举例来说，如果一个表当前数据行里最大的 id 是 10，AUTO_INCREMENT=11。这时候，我们删除 id=10 的行，AUTO_INCREMENT 还是 11。但如果马上重启实例，重启后这个表的 AUTO_INCREMENT 就会变成 10。也就是说，MySQL 重启可能会修改一个表的 AUTO_INCREMENT 的值。 在 MySQL 8.0 版本，将自增值的变更记录在了 redo log 中，重启的时候依靠 redo log 恢复重启之前的值。 理解了 MySQL 对自增值的保存策略以后，再看看自增值修改机制。 2 自增值修改机制 在 MySQL 里面，如果字段 id 被定义为 AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下： 如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段； 如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。 根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是 X，当前的自增值是 Y。 如果 X\u003cY，那么这个表的自增值不变； 如果 X≥Y，就需要把当前自增值修改为新的自增值。 新的自增值生成算法是：从 auto_increment_offset 开始，以 auto_increment_increment 为步长，持续叠加，直到找到第一个大于 X 的值，作为新的自增值。 其中，auto_increment_offset 和 auto_increment_increment 是两个系统参数，分别用来表示自增的初始值和步长，默认值都是 1。 备注：在一些场景下，使用的就不全是默认值。比如，双 M 的主备结构里要求双写的时候，就可能会设置成 auto_increment_increment=2，让一个库的自增 id 都是奇数，另一个库的自增 id 都是偶数，避免两个库生成的主键发生冲突。 当 auto_increment_offset 和 auto_increment_increment 都是 1 的时候，新的自增值生成逻辑很简单，就是： 如果准备插入的值 \u003e= 当前自增值，新的自增值就是“准备插入的值 +1”； 否则，自增值不变。 这就引入了文章开头提到的问题，在这两个参数都设置为 1 的时候，自增主键 id 却不能保证是连续的，这是什么原因呢？ 3 自增值的修改时机 要回答这个问题，就要看一下自增值的修改时机。假设，表 t 里面已经有了 (1,1,1) 这条记录，这时再执行一条插入数据命令： insert into t values(null, 1, 1); 这个语句的执行流程就是： 执行器调用 InnoDB 引擎接口写入一行，传入的这一行的值是 (0,1,1); InnoDB 发现用户没有指定自增 id 的值，获取表 t 当前的自增值 2； 将传入的行的值改成 (2,1,1); 将表的自增值改成 3； 继续执行插入数据操作，由于已经存在 c=1 的记录，所以报 Duplicate key error，语句返回。 对应的执行流程图如下： 可以看到，这个表的自增值改成 3，是在真正执行插入数据的操作之前。这个语句真正执行的时候，因为碰到唯一键 c 冲突，所以 id=2 这一行并没有插入成功，但也没有将自增值再改回去。 所以，在这之后，再插入新的数据行时，拿到的自增 id 就是 3。也就是说，出现了自增主键不连续的情况。如下图所示就是完整的演示结果。 可以看到，这个操作序列复现了一个自增主键 id 不连续的现场 (没有 id=2 的行）。可见，唯一键冲突是导致自增主键 id 不连续的第一种原因。 同样地，事务回滚也会产生类似的现象，这就是第二种原因。下面这个语句序列就可以构造不连续的自增 id。 insert into t values(null,1,1); begin; insert into t values(null,2,2); rollback; insert into t values(null,2,2); //插入的行是(3,2,2) 为什么在出现唯一键冲突或者回滚的时候，MySQL 没有把表 t 的自增值改回去呢？如果把表 t 的当前自增值从 3 改回 2，再插入新数据的时候，不就可以生成 id=2 的一行数据了吗？其实，MySQL 这么设计是为了提升性能。接下来分析一下这个设计思路，看看自增值为什么不能回退。 假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请。 假设事务 A 申请到了 id=2，事务 B 申请到 id=3，那么这时候表 t 的自增值是 4，之后继续执行。 事务 B 正确提交了，但事务 A 出现了唯一键冲突。 如果允许事务 A 把自增 id 回退，也就是把表 t 的当前自增值改回 2，那么就会出现这样的情况：表里面已经有 id=3 的行，而当前的自增 id 值是 2。 接下来，继续执行的其他事务就会申请到 id=2，然后再申请到 id=3。这时，就会出现插入语句报错“主键冲突”。 而为了解决这个主键冲突，有两种方法： 每次申请 id 之前，先判断表里面是否已经存在这个 id。如果存在，就跳过这个 id。但是，这个方法的成本很高。因为，本来申请 id 是一个很快的操作，现在还要再去主键索引树上判断 id 是否存在。 把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。 可见，这两个方法都会导致性能问题。造成这些麻烦的罪魁祸首，就是假设的这个“允许自增 id 回退”的前提导致的。 因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。也正是因为这样，所以才只保证了自增 id 是递增的，但不保证是连续的。 4 自增锁的优化 可以看到，自增 id 锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。其实，在 MySQL 5.1 版本之前，并不是这样的。 在 MySQL 5.0 版本的时候，自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。显然，这样设计会影响并发度。 MySQL 5.1.22 版本引入了一个新策略，新增参数 innodb_autoinc_lock_mode，默认值是 1。 这个参数的值被设置为 0 时，表示采用之前 MySQL 5.0 版本的策略，即语句执行结束后才释放锁； 这个参数的值被设置为 1 时： 普通 insert 语句，自增锁在申请之后就马上释放； 类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放； 这个参数的值被设置为 2 时，所有的申请自增主键的动作都是申请后就释放锁。 为什么默认设置下，insert … select 要使用语句级的锁？为什么这个参数的默认值不是 2？答案是，这么设计还是为了数据的一致性。一起来看一下这个场景： 在这个例子里，往表 t1 中插入了 4 行数据，然后创建了一个相同结构的表 t","date":"2025-03-10","objectID":"/posts/39.%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"39 | 自增主键为什么不是连续的？","uri":"/posts/39.%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"内存引擎和 InnoDB 引擎在数据组织方式上存在显著差异。InnoDB 引擎将数据存储在主键索引上，而内存引擎则将数据和索引分开存放。","date":"2025-03-10","objectID":"/posts/38.%E9%83%BD%E8%AF%B4innodb%E5%A5%BD%E9%82%A3%E8%BF%98%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8memory%E5%BC%95%E6%93%8E/","tags":["MySQL 实战 45 讲","MySQL"],"title":"38 | 都说 InnoDB 好，那还要不要使用 Memory 引擎？","uri":"/posts/38.%E9%83%BD%E8%AF%B4innodb%E5%A5%BD%E9%82%A3%E8%BF%98%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8memory%E5%BC%95%E6%93%8E/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 内存引擎和 InnoDB 引擎在数据组织方式上存在显著差异。InnoDB 引擎将数据存储在主键索引上，而内存引擎则将数据和索引分开存放。这导致了内存表的数据是按照写入顺序存放的，而 InnoDB 表的数据总是有序存放的。此外，内存表不支持行锁，只支持表锁，这会影响并发访问的性能。尽管内存引擎速度快且支持 hash 索引，但在生产环境中使用时需要注意锁粒度问题和数据持久化问题。 1 内存表的数据组织结构 假设有以下的两张表 t1 和 t2，其中表 t1 使用 Memory 引擎，表 t2 使用 InnoDB 引擎。 create table t1(id int primary key, c int) engine=Memory; create table t2(id int primary key, c int) engine=innodb; insert into t1 values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(0,0); insert into t2 values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(0,0); 然后，分别执行 select * from t1 和 select * from t2。 可以看到，内存表 t1 的返回结果里面 0 在最后一行，而 InnoDB 表 t2 的返回结果里 0 在第一行。出现这个区别的原因，要从这两个引擎的主键索引的组织方式说起。 表 t2 用的是 InnoDB 引擎，它的主键索引 id 的组织方式，InnoDB 表的数据就放在主键索引树上，主键索引是 B+ 树。所以表 t2 的数据组织方式如下图所示： 主键索引上的值是有序存储的。在执行 select * 的时候，就会按照叶子节点从左到右扫描，所以得到的结果里，0 就出现在第一行。 与 InnoDB 引擎不同，Memory 引擎的数据和索引是分开的。来看一下表 t1 中的数据内容。 可以看到，内存表的数据部分以数组的方式单独存放，而主键 id 索引里，存的是每个数据的位置。主键 id 是 hash 索引，可以看到索引上的 key 并不是有序的。 在内存表 t1 中，当执行 select * 的时候，走的是全表扫描，也就是顺序扫描这个数组。因此，0 就是最后一个被读到，并放入结果集的数据。 可见，InnoDB 和 Memory 引擎的数据组织方式是不同的： InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，称之为索引组织表（Index Organizied Table）。 而 Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，称之为堆组织表（Heap Organizied Table）。 从中可以看出，这两个引擎的一些典型不同： InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的； 当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值； 数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引； InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。 InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。 由于内存表的这些特性，每个数据行被删除以后，空出的这个位置都可以被接下来要插入的数据复用。比如，如果要在表 t1 中执行： delete from t1 where id=5; insert into t1 values(10,10); select * from t1; 就会看到返回结果里，id=10 这一行出现在 id=4 之后，也就是原来 id=5 这行数据的位置。需要指出的是，表 t1 的这个主键索引是哈希索引，因此如果执行范围查询，比如 select * from t1 where id\u003c5; 是用不上主键索引的，需要走全表扫描。那如果要让内存表支持范围扫描，应该怎么办呢？ 2 hash 索引和 B-Tree 索引 实际上，内存表也是支持 B-Tree 索引的。在 id 列上创建一个 B-Tree 索引，SQL 语句可以这么写： alter table t1 add index a_btree_index using btree (id); 这时，表 t1 的数据组织形式就变成了这样： 新增的这个 B-Tree 索引看着就眼熟了，这跟 InnoDB 的 b+ 树索引组织形式类似。作为对比，可以看一下这下面这两个语句的输出： 可以看到，执行 select * from t1 where id\u003c5 的时候，优化器会选择 B-Tree 索引，所以返回结果是 0 到 4。使用 force index 强行使用主键 id 这个索引，id=0 这一行就在结果集的最末尾了。 其实，一般在我们的印象中，内存表的优势是速度快，其中的一个原因就是 Memory 引擎支持 hash 索引。当然，更重要的原因是，内存表的所有数据都保存在内存，而内存的读写速度总是比磁盘快。但是，接下来要说明，为什么不建议在生产环境上使用内存表。这里的原因主要包括两个方面： 锁粒度问题； 数据持久化问题。 3 内存表的锁 内存表不支持行锁，只支持表锁。因此，一张表只要有更新，就会堵住其他所有在这个表上的读写操作。 需要注意的是，这里的表锁跟之前介绍过的 MDL 锁不同，但都是表级的锁。接下来，通过下面这个场景，模拟一下内存表的表级锁。 在这个执行序列里，session A 的 update 语句要执行 50 秒，在这个语句执行期间 session B 的查询会进入锁等待状态。session C 的 show processlist 结果输出如下： 跟行锁比起来，表锁对并发访问的支持不够好。所以，内存表的锁粒度问题，决定了它在处理并发事务的时候，性能也不会太好。 4 数据持久性问题 数据放在内存中，是内存表的优势，但也是一个劣势。因为，数据库重启的时候，所有的内存表都会被清空。 你可能会说，如果数据库异常重启，内存表被清空也就清空了，不会有什么问题啊。但是，在高可用架构下，内存表的这个特点简直可以当做 bug 来看待了。为什么这么说呢？先看看 M-S 架构下，使用内存表存在的问题。 来看一下下面这个时序： 业务正常访问主库； 备库硬件升级，备库重启，内存表 t1 内容被清空； 备库重启后，客户端发送一条 update 语句，修改表 t1 的数据行，这时备库应用线程就会报错“找不到要更新的行”。 这样就会导致主备同步停止。当然，如果这时候发生主备切换的话，客户端会看到，表 t1 的数据“丢失”了。 在上图中这种有 proxy 的架构里，大家默认主备切换的逻辑是由数据库系统自己维护的。这样对客户端来说，就是“网络断开，重连之后，发现内存表数据丢失了”。 你可能说这还好啊，毕竟主备发生切换，连接会断开，业务端能够感知到异常。 但是，接下来内存表的这个特性就会让使用现象显得更“诡异”了。由于 MySQL 知道重启之后，内存表的数据会丢失。所以，担心主库重启之后，出现主备不一致，MySQL 在实现上做了这样一件事儿：在数据库重启之后，往 binlog 里面写入一行 DELETE FROM t1。 如果你使用是下图所示的双 M 结构的话： 在备库重启的时候，备库 binlog 里的 delete 语句就会传到主库，然后把主库内存表的内容删除。这样在使用的时候就会发现，主库的内存表数据突然被清空了。基于上面的分析，可以看到，内存表并不适合在生产环境上作为普通数据表使用。但是内存表执行速度快呀。这个问题，其实可以这么分析： 如果表更新量大，那么并发度是一个很重要的参考指标，InnoDB 支持行锁，并发度比内存表好； 能放到内存表的数据量都不大。如果考虑的是读的性能，一个读 QPS 很高并且数据量不大的表，即使是使用 InnoDB，数据也是都会缓存在 InnoDB Buffer Pool 里的。因此，使用 InnoDB 表的读性能也不会差。 所以，建议把普通内存表都用 InnoDB 表来代替。但是，有一个场景却是例外的。这个场景就是，在数据量可控，不会耗费过多内存的情况下，可以考虑使用内存表。 内存临时表刚好可以无视内存表的两个不足，主要是下面的三个原因： 临时表不会被其他线程访问，没有并发性的问题； 临时表重启后也是需要删除的，清空数据这个问题不存在； 备库的临时表也不会影响主库的用户线程。 现在回过头再看一下之前说的 join 语句优化的例子，当时建议的是创建一个 InnoDB 临时表，使用的语句序列是： create temporary table temp_t(id int primary key, a int, b int, index(b))engine=innodb; insert into temp_t select * from t2 where b\u003e=1 and b\u003c=2000; select * from t1 join temp_t on (t1.b=temp_t.b); 了解了内存","date":"2025-03-10","objectID":"/posts/38.%E9%83%BD%E8%AF%B4innodb%E5%A5%BD%E9%82%A3%E8%BF%98%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8memory%E5%BC%95%E6%93%8E/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"38 | 都说 InnoDB 好，那还要不要使用 Memory 引擎？","uri":"/posts/38.%E9%83%BD%E8%AF%B4innodb%E5%A5%BD%E9%82%A3%E8%BF%98%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8memory%E5%BC%95%E6%93%8E/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入介绍了 MySQL 内部临时表的使用情况，重点讨论了在 union 和 group by 语句中的应用。","date":"2025-03-10","objectID":"/posts/37.%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/","tags":["MySQL 实战 45 讲","MySQL"],"title":"37 | 什么时候会使用内部临时表？","uri":"/posts/37.%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入介绍了 MySQL 内部临时表的使用情况，重点讨论了在 union 和 group by 语句中的应用。在 union 语句中，内部临时表用于暂存数据并执行两个子查询的并集。通过示例展示了内部临时表的执行流程。对于 group by 语句，文章详细解释了其执行流程和优化方法，特别强调了通过索引优化 group by 语句的执行效率。 1 union 执行流程 为了便于量化分析，用下面的表 t1 来举例。 create table t1(id int primary key, a int, b int, index(a)); delimiter ;; create procedure idata() begin declare i int; set i=1; while(i\u003c=1000)do insert into t1 values(i, i, i); set i=i+1; end while; end;; delimiter ; call idata(); 然后执行下面这条语句： (select 1000 as f) union (select id from t1 order by id desc limit 2); 这条语句用到了 union，它的语义是，取这两个子查询结果的并集。并集的意思就是这两个集合加起来，重复的行只保留一行。下图是这个语句的 explain 结果。 可以看到： 第二行的 key=PRIMARY，说明第二个子句用到了索引 id。 第三行的 Extra 字段，表示在对子查询的结果集做 union 的时候，使用了临时表 (Using temporary)。 这个语句的执行流程是这样的： 创建一个内存临时表，这个临时表只有一个整型字段 f，并且 f 是主键字段。 执行第一个子查询，得到 1000 这个值，并存入临时表中。 执行第二个子查询： 拿到第一行 id=1000，试图插入临时表中。但由于 1000 这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行； 取到第二行 id=999，插入临时表成功。 从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是 1000 和 999。 这个过程的流程图如下所示： 可以看到，这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了临时表主键 id 的唯一性约束，实现了 union 的语义。 顺便提一下，如果把上面这个语句中的 union 改成 union all 的话，就没有了“去重”的语义。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端。因此也就不需要临时表了。 可以看到，第二行的 Extra 字段显示的是 Using index，表示只使用了覆盖索引，没有用临时表了。 2 group by 执行流程 另外一个常见的使用临时表的例子是 group by，来看一下这个语句： select id%10 as m, count(*) as c from t1 group by m; 这个语句的逻辑是把表 t1 里的数据，按照 id%10 进行分组统计，并按照 m 的结果排序后输出。它的 explain 结果如下： 在 Extra 字段里面，可以看到三个信息： Using index，表示这个语句使用了覆盖索引，选择了索引 a，不需要回表； Using temporary，表示使用了临时表； Using filesort，表示需要排序。 这个语句的执行流程是这样的： 创建内存临时表，表里有两个字段 m 和 c，主键是 m； 扫描表 t1 的索引 a，依次取出叶子节点上的 id 值，计算 id%10 的结果，记为 x； 如果临时表中没有主键为 x 的行，就插入一个记录 (x,1); 如果表中有主键为 x 的行，就将 x 这一行的 c 值加 1； 遍历完成后，再根据字段 m 做排序，得到结果集返回给客户端。 这个流程的执行图如下： 图中最后一步，是对内存临时表的排序，流程如下所示： 其中，临时表的排序过程就是上图中虚线框内的过程。接下来，再看一下这条语句的执行结果： 如果你的需求并不需要对结果进行排序，可以在 SQL 语句末尾增加 order by null，也就是改成： select id%10 as m, count(*) as c from t1 group by m order by null; 这样就跳过了最后排序的阶段，直接从临时表中取数据返回。返回的结果如下图所示。 由于表 t1 中的 id 值是从 1 开始的，因此返回的结果集中第一行是 id=1；扫描到 id=10 的时候才插入 m=0 这一行，因此结果集里最后一行才是 m=0。 这个例子里由于临时表只有 10 行，内存可以放得下，因此全程只使用了内存临时表。但是，内存临时表的大小是有限制的，参数 tmp_table_size 就是控制这个内存大小的，默认是 16M。如果执行下面这个语句序列： set tmp_table_size=1024; select id%100 as m, count(*) as c from t1 group by m order by null limit 10; 把内存临时表的大小限制为最大 1024 字节，并把语句改成 id % 100，这样返回结果里有 100 行数据。但是，这时的内存临时表大小不够存下这 100 行数据，也就是说，执行过程中会发现内存临时表大小到达了上限（1024 字节）。 那么，这时候就会把内存临时表转成磁盘临时表，磁盘临时表默认使用的引擎是 InnoDB。这时，返回的结果如下图所示。 如果这个表 t1 的数据量很大，很可能这个查询需要的磁盘临时表就会占用大量的磁盘空间。 3 group by 优化方法 – 索引 可以看到，不论是使用内存临时表还是磁盘临时表，group by 逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的。如果表的数据量比较大，上面这个 group by 语句执行起来就会很慢，有什么优化的方法呢？要解决 group by 语句的优化问题，可以先想一下这个问题：执行 group by 语句为什么需要临时表？ group by 的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的 id%100 的结果是无序的，所以就需要有一个临时表，来记录并统计结果。 那么，如果扫描过程中可以保证出现的数据是有序的，是不是就简单了呢？假设，现在有一个类似下图的这么一个数据结构，先来看看 group by 可以怎么做。 可以看到，如果可以确保输入的数据是有序的，那么计算 group by 的时候，就只需要从左到右，顺序扫描，依次累加。也就是下面这个过程： 当碰到第一个 1 的时候，已经知道累积了 X 个 0，结果集里的第一行就是 (0,X); 当碰到第一个 2 的时候，已经知道累积了 Y 个 1，结果集里的第二行就是 (1,Y); 按照这个逻辑执行的话，扫描到整个输入的数据结束，就可以拿到 group by 的结果，不需要临时表，也不需要再额外排序。你一定想到了，InnoDB 的索引，就可以满足这个输入有序的条件。 在 MySQL 5.7 版本支持了 generated column 机制，用来实现列数据的关联更新。可以用下面的方法创建一个列 z，然后在 z 列上创建一个索引（如果是 MySQL 5.6 及之前的版本，也可以创建普通列和索引，来解决这个问题）。 alter table t1 add column z int generated always as(id % 100), add index(z); 这样，索引 z 上的数据就是类似上图这样有序的了。上面的 group by 语句就可以改成： select z, count(*) as c from t1 group by z; 优化后的 group by 语句的 explain 结果，如下图所示： 从 Extra 字段可以看到，这个语句的执行不再需要临时表，也不需要排序了。 4 group by 优化方法 – 直接排序 所以，如果可以通过加索引来完成 group by 逻辑就再好不过了。但是，如果碰上不适合创建索引的场景，还是要老老实实做排序的。那么，这时候的 group by 要怎么优化呢？ 如果明明知道，一个 group by 语句中需要放到临时表上的数据量特别大，却还是要按照“先放到内存临时表，插入一部分数据后，发现内存临时表不够用了再转成磁盘临时表”，看上去就有点儿傻。那么就会想了，MySQL 有没有直接走磁盘临时表的方法呢？答案是，有的。 在 group by 语句中加入 SQL_BIG_RESULT 这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。 MySQL 的优化器一看，磁盘临时表是 B+ 树存储，存储效率不如数组来得高。所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。因此，下面这个语句 select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m; 的执行流程就是这样的： 初始化 sort_buffer，确定放入一个整型字段，记为 m； 扫描表 t1 的索引 a，依次取出里面的 id 值，将 id%100 的值存入 sort_buffer 中； 扫描完成后，对 sort_buffer 的字段 m 做排序（如果 sort_buffer 内存不够用，就会利用磁盘临时文件辅","date":"2025-03-10","objectID":"/posts/37.%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"37 | 什么时候会使用内部临时表？","uri":"/posts/37.%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"临时表在 MySQL 中具有独特的特性，适合于复杂查询优化和分库分表系统中的应用。与内存表不同，临时表可以使用各种引擎类型，包括 InnoDB 和 MyISAM 引擎，且可以与普通表同名。","date":"2025-02-23","objectID":"/posts/36.%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D/","tags":["MySQL 实战 45 讲","MySQL"],"title":"36 | 为什么临时表可以重名？","uri":"/posts/36.%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 临时表在 MySQL 中具有独特的特性，适合于复杂查询优化和分库分表系统中的应用。与内存表不同，临时表可以使用各种引擎类型，包括 InnoDB 和 MyISAM 引擎，且可以与普通表同名。由于临时表只能被创建它的 session 访问，对其他线程不可见，并且在 session 结束时会自动删除，因此特别适合于避免表名重复导致建表失败的问题和不需要额外的数据清理操作。临时表经常被用于复杂查询的优化过程中，尤其在分库分表系统的跨库查询中发挥重要作用。 在上一篇文章中优化 join 查询的时候使用到了临时表。当时是这么用的： create temporary table temp_t like t1; alter table temp_t add index(b); insert into temp_t select * from t2 where b\u003e=1 and b\u003c=2000; select * from t1 join temp_t on (t1.b=temp_t.b); 为什么要用临时表呢？直接用普通表是不是也可以呢？ 临时表和内存表的区别： 内存表，指的是使用 Memory 引擎的表，建表语法是 create table … engine=memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。 而临时表，可以使用各种引擎类型。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。当然，临时表也可以使用 Memory 引擎。 1 临时表的特性 先来看下下面这个操作序列： 可以看到，临时表在使用上有以下几个特点： 建表语法是 create temporary table …。 一个临时表只能被创建它的 session 访问，对其他线程不可见。所以，图中 session A 创建的临时表 t，对于 session B 就是不可见的。 临时表可以与普通表同名。 session A 内有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表。 show tables 命令不显示临时表。 由于临时表只能被创建它的 session 访问，所以在这个 session 结束的时候，会自动删除临时表。也正是由于这个特性，临时表就特别适合文章开头的 join 优化这种场景。原因主要包括以下两个方面： 不同 session 的临时表是可以重名的，如果有多个 session 同时执行 join 优化，不需要担心表名重复导致建表失败的问题。 不需要担心数据删除问题。如果使用普通表，在流程执行过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作。 2 临时表的应用 由于不用担心线程之间的重名冲突，临时表经常会被用在复杂查询的优化过程中。其中，分库分表系统的跨库查询就是一个典型的使用场景。 一般分库分表的场景，就是要把一个逻辑上的大表分散到不同的数据库实例上。比如。将一个大表 ht，按照字段 f，拆分成 1024 个分表，然后分布到 32 个数据库实例上。如下图所示： 一般情况下，这种分库分表系统都有一个中间层 proxy。不过，也有一些方案会让客户端直接连接数据库，也就是没有 proxy 这一层。 在这个架构中，分区 key 的选择是以“减少跨库和跨表查询”为依据的。如果大部分的语句都会包含 f 的等值条件，那么就要用 f 做分区键。这样，在 proxy 这一层解析完 SQL 语句以后，就能确定将这条语句路由到哪个分表做查询。比如下面这条语句： select v from ht where f=N; 这时就可以通过分表规则（比如，N%1024) 来确认需要的数据被放在了哪个分表上。这种语句只需要访问一个分表，是分库分表方案最欢迎的语句形式了。但是，如果这个表上还有另外一个索引 k，并且查询语句是这样的： select v from ht where k \u003e= M order by t_modified desc limit 100; 这时候，由于查询条件里面没有用到分区字段 f，只能到所有的分区中去查找满足条件的所有行，然后统一做 order by 的操作。这种情况下，有两种比较常用的思路。 第一种思路是，在 proxy 层的进程代码中实现排序。 这种方式的优势是处理速度快，拿到分库的数据以后，直接在内存中参与计算。不过，这个方案的缺点也比较明显： 需要的开发工作量比较大。举例的这条语句还算是比较简单的，如果涉及到复杂的操作，比如 group by，甚至 join 这样的操作，对中间层的开发能力要求比较高； 对 proxy 端的压力比较大，尤其是很容易出现内存不够用和 CPU 瓶颈的问题。 另一种思路就是，把各个分库拿到的数据，汇总到一个 MySQL 实例的一个表中，然后在这个汇总实例上做逻辑操作。比如上面这条语句，执行流程可以类似这样： 在汇总库上创建一个临时表 temp_ht，表里包含三个字段 v、k、t_modified； 在各个分库上执行 select v,k,t_modified from ht_x where k \u003e= M order by t_modified desc limit 100; 把分库执行的结果插入到 temp_ht 表中； 执行 select v from temp_ht order by t_modified desc limit 100; 得到结果。这个过程对应的流程图如下所示： 在实践中，往往会发现每个分库的计算量都不饱和，所以会直接把临时表 temp_ht 放到 32 个分库中的某一个上。这时的查询逻辑与上图类似，可以自己再思考一下具体的流程。 3 为什么临时表可以重名？ 不同线程可以创建同名的临时表，这是怎么做到的呢？接下来就看一下这个问题。我们在执行 create temporary table temp_t(id int primary key)engine=innodb; 这个语句的时候，MySQL 要给这个 InnoDB 表创建一个 frm 文件保存表结构定义，还要有地方保存表数据。 这个 frm 文件放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程 id}_{线程 id}_ 序列号”。可以使用 select @@tmpdir 命令，来显示实例的临时文件目录。而关于表中数据的存放方式，在不同的 MySQL 版本中有着不同的处理方式： 在 5.6 以及之前的版本里，MySQL 会在临时文件目录下创建一个相同前缀、以.ibd 为后缀的文件，用来存放数据文件； 而从 5.7 版本开始，MySQL 引入了一个临时文件表空间，专门用来存放临时文件的数据。因此，就不需要再创建 ibd 文件了。 从文件名的前缀规则可以看到，其实创建一个叫作 t1 的 InnoDB 临时表，MySQL 在存储上认为创建的表名跟普通表 t1 是不同的，因此同一个库下面已经有普通表 t1 的情况下，还是可以再创建一个临时表 t1 的。为了便于后面讨论，先来举一个例子。 这个进程的进程号是 1234，session A 的线程 id 是 4，session B 的线程 id 是 5。所以看到了，session A 和 session B 创建的临时表，在磁盘上的文件不会重名。 MySQL 维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个 table_def_key。 一个普通表的 table_def_key 的值是由“库名 + 表名”得到的，所以如果要在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现 table_def_key 已经存在了。 而对于临时表，table_def_key 在“库名 + 表名”基础上，又加入了“server_id+thread_id”。 也就是说，session A 和 sessionB 创建的两个临时表 t1，它们的 table_def_key 不同，磁盘文件名也不同，因此可以并存。 在实现上，每个线程都维护了自己的临时表链表。这样每次 session 内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；在 session 结束的时候，对链表里的每个临时表，执行“DROP TEMPORARY TABLE + 表名”操作。 这时候你会发现，binlog 中也记录了 DROP TEMPORARY TABLE 这条命令。你一定会觉得奇怪，临时表只在线程内自己可以访问，为什么需要写到 binlog 里面？这，就需要说到主备复制了。 4 临时表和主备复制 既然写 binlog，就意味着备库需要。可以设想一下，在主库上执行下面这个语句序列： create table t_normal(id int primary key, c int)engine=innodb;/*Q1*/ create temporary table temp_t like t_normal;/*Q2*/ insert into temp_t values(1,1);/*Q3*/ insert into t_normal select * from temp_t;/*Q4*/ 如果关于临时表的操作都不记录，那么在备库就只有 create table t_normal 表和 insert into","date":"2025-02-23","objectID":"/posts/36.%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"36 | 为什么临时表可以重名？","uri":"/posts/36.%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入介绍了如何优化 join 语句，主要包括 Multi-Range Read（MRR）优化和 Batched Key Access（BKA）算法。","date":"2025-02-23","objectID":"/posts/35.join%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96/","tags":["MySQL 实战 45 讲","MySQL"],"title":"35 | join 语句怎么优化？","uri":"/posts/35.join%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入介绍了如何优化 join 语句，主要包括 Multi-Range Read（MRR）优化和 Batched Key Access（BKA）算法。MRR 优化旨在通过范围查询和排序，提升性能，而 BKA 算法则是对 Index Nested-Loop Join（NLJ）算法的优化，通过将驱动表的数据暂存到 join_buffer，一次性传递多个值给被驱动表，以提高效率。文章详细解释了这两种优化方法的原理和执行流程，并指出了使用这些优化方法的注意事项。 在使用 NLJ 算法的时候，其实效果还是不错的，比通过应用层拆分成多个语句然后再拼接查询结果更方便，而且性能也不会差。但是，BNL 算法在大表 join 的时候性能就差多了，比较次数等于两个表参与 join 的行数的乘积，很消耗 CPU 资源。 当然了，这两个算法都还有继续优化的空间，今天就来聊聊这个话题。为了便于分析，还是创建两个表 t1、t2 来展开今天的问题。 create table t1(id int primary key, a int, b int, index(a)); create table t2 like t1; drop procedure idata; delimiter ;; create procedure idata() begin declare i int; set i=1; while(i\u003c=1000)do insert into t1 values(i, 1001-i, i); set i=i+1; end while; set i=1; while(i\u003c=1000000)do insert into t2 values(i, i, i); set i=i+1; end while; end;; delimiter ; call idata(); 为了便于后面量化说明，在表 t1 里，插入了 1000 行数据，每一行的 a=1001-id 的值。也就是说，表 t1 中字段 a 是逆序的。同时，在表 t2 中插入了 100 万行数据。 1 Multi-Range Read 优化 在介绍 join 语句的优化方案之前，先介绍一个知识点，即：Multi-Range Read 优化 (MRR)。这个优化的主要目的是尽量使用顺序读盘。 回表是指，InnoDB 在普通索引 a 上查到主键 id 的值后，再根据一个个主键 id 的值到主键索引上去查整行数据的过程。回表过程是一行行地查数据，还是批量地查数据？先来看看这个问题。假设，执行这个语句： select * from t1 where a\u003e=1 and a\u003c=100; 主键索引是一棵 B+ 树，在这棵树上，每次只能根据一个主键 id 查到一行数据。因此，回表肯定是一行行搜索主键索引的，基本流程如下图所示。 如果随着 a 的值递增顺序查询的话，id 的值就变成随机的，那么就会出现随机访问，性能相对较差。虽然“按行查”这个机制不能改，但是调整查询的顺序，还是能够加速的。 因为大多数的数据都是按照主键递增顺序插入得到的，所以可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。这，就是 MRR 优化的设计思路。此时，语句的执行流程变成了这样： 根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ; 将 read_rnd_buffer 中的 id 进行递增排序； 排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。 这里，read_rnd_buffer 的大小是由 read_rnd_buffer_size 参数控制的。如果步骤 1 中，read_rnd_buffer 放满了，就会先执行完步骤 2 和 3，然后清空 read_rnd_buffer。之后继续找索引 a 的下个记录，并继续循环。 另外需要说明的是，如果想要稳定地使用 MRR 优化的话，需要设置 set optimizer_switch=“mrr_cost_based=off”。（官方文档的说法，是现在的优化器策略，判断消耗的时候，会更倾向于不使用 MRR，把 mrr_cost_based 设置为 off，就是固定使用 MRR 了。）下面两幅图就是使用了 MRR 优化后的执行流程和 explain 结果。 从上图的 explain 结果中，可以看到 Extra 字段多了 Using MRR，表示的是用上了 MRR 优化。而且，由于在 read_rnd_buffer 中按照 id 做了排序，所以最后得到的结果集也是按照主键 id 递增顺序的，也就是与第一幅图结果集中行的顺序相反。到这里小结一下。 MRR 能够提升性能的核心在于，这条查询语句在索引 a 上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键 id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。 2 Batched Key Access 理解了 MRR 性能提升的原理，就能理解 MySQL 在 5.6 版本后开始引入的 Batched Key Access(BKA) 算法了。这个 BKA 算法，其实就是对 NLJ 算法的优化。再来看看上一篇文章中用到的 NLJ 算法的流程图： NLJ 算法执行的逻辑是：从驱动表 t1，一行行地取出 a 的值，再到被驱动表 t2 去做 join。也就是说，对于表 t2 来说，每次都是匹配一个值。这时，MRR 的优势就用不上了。 那怎么才能一次性地多传些值给表 t2 呢？方法就是，从表 t1 里一次性地多拿些行出来，一起传给表 t2。既然如此，就把表 t1 的数据取出来一部分，先放到一个临时内存。这个临时内存不是别人，就是 join_buffer。join_buffer 在 BNL 算法里的作用，是暂存驱动表的数据。但是在 NLJ 算法里并没有用。那么，刚好就可以复用 join_buffer 到 BKA 算法中。如下图所示，是上面的 NLJ 算法优化后的 BKA 算法的流程。 图中，在 join_buffer 中放入的数据是 P1P100，表示的是只会取查询需要的字段。当然，如果 join buffer 放不下 P1P100 的所有数据，就会把这 100 行数据分成多段执行上图的流程。那么，这个 BKA 算法到底要怎么启用呢？ 如果要使用 BKA 优化算法的话，需要在执行 SQL 语句之前，先设置 set optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on'; 其中，前两个参数的作用是要启用 MRR。这么做的原因是，BKA 算法的优化要依赖于 MRR。 3 BNL 算法的性能问题 说完了 NLJ 算法的优化，再来看 BNL 算法的优化。使用 Block Nested-Loop Join(BNL) 算法时，可能会对被驱动表做多次扫描。如果这个被驱动表是一个大的冷数据表，除了会导致 IO 压力大以外，还会对系统有什么影响呢？ 由于 InnoDB 对 Bufffer Pool 的 LRU 算法做了优化，即：第一次从磁盘读入内存的数据页，会先放在 old 区域。如果 1 秒之后这个数据页不再被访问了，就不会被移动到 LRU 链表头部，这样对 Buffer Pool 的命中率影响就不大。 但是，如果一个使用 BNL 算法的 join 语句，多次扫描一个冷表，而且这个语句执行时间超过 1 秒，就会在再次扫描冷表的时候，把冷表的数据页移到 LRU 链表头部。 这种情况对应的，是冷表的数据量小于整个 Buffer Pool 的 3/8，能够完全放入 old 区域的情况。如果这个冷表很大，就会出现另外一种情况：业务正常访问的数据页，没有机会进入 young 区域。 由于优化机制的存在，一个正常访问的数据页，要进入 young 区域，需要隔 1 秒后再次被访问到。但是，由于 join 语句在循环读磁盘和淘汰内存页，进入 old 区域的数据页，很可能在 1 秒之内就被淘汰了。这样，就会导致这个 MySQL 实例的 Buffer Pool 在这段时间内，young 区域的数据页没有被合理地淘汰。也就是说，这两种情况都会影响 Buffer Pool 的正常运作。 大表 join 操作虽然对 IO 有影响，但是在语句执行结束后，对 IO 的影响也就结束了。但是，对 Buffer Pool 的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率。为了减少这种影响，可以考虑增大 join_buffer_size 的值，减少对被驱动表的扫描次数。也就是说，BNL 算法对系统的影响主要包括三个方面： 可能会多次扫描被驱动表，占用磁盘 IO 资源； 判断 join 条件需要执行 M*N 次对比（M、N 分别是两张表的行数），如果是大表就会占用非常多的 CPU 资源； 可能会导致 Buffer Pool 的热数据被淘汰，影响内存命中率。 在执行语句之前，需要通过理论分析和查看 explain 结果的方式，确认是否要使用 BNL 算法。如果确认优化器会使用 BNL 算法，就需要做优化。优化的常见做法是，给被驱动表的 join 字段加上索引，把 BNL 算法转成 BKA 算法。 4 BNL 转 BKA 一些情况下，可以直接在被驱动表上建索引，这时就可以直接转成 BKA 算法了。但是，有时候确实会碰到一些不适合在被驱动表上建索引的情况。比如下面这个语句： select * from t1 join t2 ","date":"2025-02-23","objectID":"/posts/35.join%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"35 | join 语句怎么优化？","uri":"/posts/35.join%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入探讨了在实际生产中使用 join 语句的问题，重点关注了两个问题：DBA 不允许使用 join 的原因以及在大小不同的表做 join 时应该选择哪个表作为驱动表。","date":"2025-02-23","objectID":"/posts/34.%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8join/","tags":["MySQL 实战 45 讲","MySQL"],"title":"34 | 到底可不可以使用 join？","uri":"/posts/34.%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8join/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入探讨了在实际生产中使用 join 语句的问题，重点关注了两个问题：DBA 不允许使用 join 的原因以及在大小不同的表做 join 时应该选择哪个表作为驱动表。文章首先介绍了 join 语句的执行过程，以及使用 straight_join 固定连接方式执行查询的方法。随后详细分析了 Index Nested-Loop Join 算法的执行流程，并通过对比单表查询的方式，得出了使用 join 语句性能更优的结论。 在实际生产中，关于 join 语句使用的问题，一般会集中在以下两类： DBA 不让使用 join，使用 join 有什么问题呢？ 如果有两个大小不同的表做 join，应该用哪个表做驱动表呢？ 为了便于量化分析，还是创建两个表 t1 和 t2 来和你说明。 CREATE TABLE `t2` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `a` (`a`) ) ENGINE=InnoDB; drop procedure idata; delimiter ;; create procedure idata() begin declare i int; set i=1; while(i\u003c=1000)do insert into t2 values(i, i, i); set i=i+1; end while; end;; delimiter ; call idata(); create table t1 like t2; insert into t1 (select * from t2 where id\u003c=100) 可以看到，这两个表都有一个主键索引 id 和一个索引 a，字段 b 上无索引。存储过程 idata() 往表 t2 里插入了 1000 行数据，在表 t1 里插入的是 100 行数据。 1 Index Nested-Loop Join 先来看一下这个语句： select * from t1 straight_join t2 on (t1.a=t2.a); 如果直接使用 join 语句，MySQL 优化器可能会选择表 t1 或 t2 作为驱动表，这样会影响分析 SQL 语句的执行过程。所以，为了便于分析执行过程中的性能问题，改用 straight_join 让 MySQL 使用固定的连接方式执行查询，这样优化器只会按照指定的方式去 join。在这个语句里，t1 是驱动表，t2 是被驱动表。现在，来看一下这条语句的 explain 结果。 可以看到，在这条语句里，被驱动表 t2 的字段 a 上有索引，join 过程用上了这个索引，因此这个语句的执行流程是这样的： 从表 t1 中读入一行数据 R； 从数据行 R 中，取出 a 字段到表 t2 里去查找； 取出表 t2 中满足条件的行，跟 R 组成一行，作为结果集的一部分； 重复执行步骤 1 到 3，直到表 t1 的末尾循环结束。 这个过程是先遍历表 t1，然后根据从表 t1 中取出的每行数据中的 a 值，去表 t2 中查找满足条件的记录。在形式上，这个过程就跟写程序时的嵌套查询类似，并且可以用上被驱动表的索引，所以称之为“Index Nested-Loop Join”，简称 NLJ。 它对应的流程图如下所示： 在这个流程里： 对驱动表 t1 做了全表扫描，这个过程需要扫描 100 行； 而对于每一行 R，根据 a 字段去表 t2 查找，走的是树搜索过程。由于构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描 100 行； 所以，整个执行流程，总扫描行数是 200。 现在知道了这个过程，再试着回答一下文章开头的两个问题。先看第一个问题：能不能使用 join？假设不使用 join，那就只能用单表查询。看看上面这条语句的需求，用单表查询怎么实现。 执行 select * from t1，查出表 t1 的所有数据，这里有 100 行； 循环遍历这 100 行数据： 从每一行 R 取出字段 a 的值 $R.a； 执行 select * from t2 where a=$R.a； 把返回的结果和 R 构成结果集的一行。 可以看到，在这个查询过程，也是扫描了 200 行，但是总共执行了 101 条语句，比直接 join 多了 100 次交互。除此之外，客户端还要自己拼接 SQL 语句和结果。显然，这么做还不如直接 join 好。 再来看看第二个问题：怎么选择驱动表？在这个 join 语句执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索。 假设被驱动表的行数是 M。每次在被驱动表查一行数据，要先搜索索引 a，再搜索主键索引。每次搜索一棵树近似复杂度是以 2 为底的 M 的对数，记为 log2M，所以在被驱动表上查一行的时间复杂度是 2log2M。假设驱动表的行数是 N，执行过程就要扫描驱动表 N 行，然后对于每一行，到被驱动表上匹配一次。因此整个执行过程，近似复杂度是 N + N*2log2M。显然，N 对扫描行数的影响更大，因此应该让小表来做驱动表。 如果没觉得这个影响有那么“显然”，可以这么理解：N 扩大 1000 倍的话，扫描行数就会扩大 1000 倍；而 M 扩大 1000 倍，扫描行数扩大不到 10 倍。 到这里小结一下，通过上面的分析得到了两个结论： 使用 join 语句，性能比强行拆成多个单表执行 SQL 语句的性能要好； 如果使用 join 语句的话，需要让小表做驱动表。 但是，这个结论的前提是“可以使用被驱动表的索引”。 2 Simple Nested-Loop Join 接下来，再看看被驱动表用不上索引的情况。现在，把 SQL 语句改成这样： select * from t1 straight_join t2 on (t1.a=t2.b); 由于表 t2 的字段 b 上没有索引，因此再用上图的执行流程时，每次到 t2 去匹配的时候，就要做一次全表扫描。 可以先设想一下这个问题，继续使用上图的算法，是不是可以得到正确的结果呢？如果只看结果的话，这个算法是正确的，而且这个算法也有一个名字，叫做“Simple Nested-Loop Join”。但是，这样算来，这个 SQL 请求就要扫描表 t2 多达 100 次，总共扫描 100*1000=10 万行。 这还只是两个小表，如果 t1 和 t2 都是 10 万行的表（当然了，这也还是属于小表的范围），就要扫描 100 亿行，这个算法看上去太“笨重”了。当然，MySQL 也没有使用这个 Simple Nested-Loop Join 算法，而是使用了另一个叫作“Block Nested-Loop Join”的算法，简称 BNL。 3 Block Nested-Loop Join 这时候，被驱动表上没有可用的索引，算法的流程是这样的： 把表 t1 的数据读入线程内存 join_buffer 中，由于这个语句中写的是 select *，因此是把整个表 t1 放入了内存； 扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。 这个过程的流程图如下： 对应地，这条 SQL 语句的 explain 结果如下所示： 可以看到，在这个过程中，对表 t1 和 t2 都做了一次全表扫描，因此总的扫描行数是 1100。由于 join_buffer 是以无序数组的方式组织的，因此对表 t2 中的每一行，都要做 100 次判断，总共需要在内存中做的判断次数是：100*1000=10 万次。 前面说过，如果使用 Simple Nested-Loop Join 算法进行查询，扫描行数也是 10 万行。因此，从时间复杂度上来说，这两个算法是一样的。但是，Block Nested-Loop Join 算法的这 10 万次判断是内存操作，速度上会快很多，性能也更好。 接下来来看一下，在这种情况下，应该选择哪个表做驱动表。假设小表的行数是 N，大表的行数是 M，那么在这个算法里： 两个表都做一次全表扫描，所以总的扫描行数是 M+N； 内存中的判断次数是 M*N。 可以看到，调换这两个算式中的 M 和 N 没差别，因此这时候选择大表还是小表做驱动表，执行耗时是一样的。这个例子里表 t1 才 100 行，要是表 t1 是一个大表，join_buffer 放不下怎么办呢？ join_buffer 的大小是由参数 join_buffer_size 设定的，默认值是 256k。如果放不下表 t1 的所有数据话，策略很简单，就是分段放。把 join_buffer_size 改成 1200，再执行： select * from t1 straight_join t2 on (t1.a=t2.b); 执行过程就变成了： 扫描表 t1，顺序读取数据行放入 join_buffer 中，放完第 88 行 join_buffer 满了，继续第 2 步； 扫描表 t2，把 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回； 清空 join_buffer； 继续扫描表 t1，顺序读取最后的 12 行数据放入 join_buffer 中，继续执行第 2 步。 执行流程图也就变成这样： 图中的步骤 4 和 5，表示清空 join_buffer 再复用。这个流程才体现出了这","date":"2025-02-23","objectID":"/posts/34.%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8join/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"34 | 到底可不可以使用 join？","uri":"/posts/34.%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8join/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入分析了全表扫描对数据库内存的影响，重点讨论了全表扫描对 server 层和 InnoDB 引擎的影响，并提出了相应的优化建议。","date":"2025-02-23","objectID":"/posts/33.%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86/","tags":["MySQL 实战 45 讲","MySQL"],"title":"33 | 我查这么多数据，会不会把数据库内存打爆？","uri":"/posts/33.%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入分析了全表扫描对数据库内存的影响，重点讨论了全表扫描对 server 层和 InnoDB 引擎的影响，并提出了相应的优化建议。文章首先解答了全表扫描对内存的影响，指出 MySQL 内部的内存占用不会超过 net_buffer_length 的大小，并介绍了查询结果的发送流程和状态变化。强调了客户端接收速度对 MySQL 服务端执行时间的影响，并建议对于大查询结果，使用 mysql_store_result 接口将结果保存到本地内存。 如果我的主机内存只有 100G，现在要对一个 200G 的大表做全表扫描，会不会把数据库主机的内存用光了？ 这个问题确实值得担心，被系统 OOM（out of memory）可不是闹着玩的。但是，反过来想想，逻辑备份的时候，可不就是做整库扫描吗？如果这样就会把内存吃光，逻辑备份不是早就挂了？ 所以说，对大表做全表扫描，看来应该是没问题的。但是，这个流程到底是怎么样的呢？ 1 全表扫描对 server 层的影响 假设现在要对一个 200G 的 InnoDB 表 db1. t，执行一个全表扫描。当然要把扫描结果保存在客户端，会使用类似这样的命令： mysql -h$host -P$port -u$user -p$pwd -e \"select * from db1.t\" \u003e $target_file 你已经知道了，InnoDB 的数据是保存在主键索引上的，所以全表扫描实际上是直接扫描表 t 的主键索引。这条查询语句由于没有其他的判断条件，所以查到的每一行都可以直接放到结果集里面，然后返回给客户端。那么，这个“结果集”存在哪里呢？实际上，服务端并不需要保存一个完整的结果集。取数据和发数据的流程是这样的： 获取一行，写到 net_buffer 中。这块内存的大小是由参数 net_buffer_length 定义的，默认是 16k。 重复获取行，直到 net_buffer 写满，调用网络接口发出去。 如果发送成功，就清空 net_buffer，然后继续取下一行，并写入 net_buffer。 如果发送函数返回 EAGAIN 或 WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。 这个过程对应的流程图如下所示。 从这个流程中，可以看到： 一个查询在发送过程中，占用的 MySQL 内部的内存最大就是 net_buffer_length 这么大，并不会达到 200G； socket send buffer 也不可能达到 200G（默认定义 /proc/sys/net/core/wmem_default），如果 socket send buffer 被写满，就会暂停读数据的流程。 也就是说，MySQL 是“边读边发的”，这个概念很重要。这就意味着，如果客户端接收得慢，会导致 MySQL 服务端由于结果发不出去，这个事务的执行时间变长。 比如下面这个状态，就是。故意让客户端不去读 socket receive buffer 中的内容，然后在服务端 show processlist 看到的结果。 如果看到 State 的值一直处于“Sending to client”，就表示服务器端的网络栈写满了。如果客户端使用–quick 参数，会使用 mysql_use_result 方法。这个方法是读一行处理一行。可以想象一下，假设有一个业务的逻辑比较复杂，每读一行数据以后要处理的逻辑如果很慢，就会导致客户端要过很久才会去取下一行数据，可能就会出现如上图所示的这种情况。 因此，对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，都建议使用 mysql_store_result 这个接口，直接把查询结果保存到本地内存。 当然前提是查询返回结果不多。如果执行了一个大查询导致客户端占用内存近 20G，这种情况下就需要改用 mysql_use_result 接口了。 另一方面，如果在自己负责维护的 MySQL 里看到很多个线程都处于“Sending to client”这个状态，就意味着要让业务开发同学优化查询结果，并评估这么多的返回结果是否合理。 而如果要快速减少处于这个状态的线程的话，将 net_buffer_length 参数设置为一个更大的值是一个可选方案。 与“Sending to client”长相很类似的一个状态是“Sending data”，这是一个经常被误会的问题。实际上，一个查询语句的状态变化是这样的（注意：这里略去了其他无关的状态）： MySQL 查询语句进入执行阶段后，首先把状态设置成“Sending data”； 然后，发送执行结果的列相关的信息（meta data) 给客户端； 再继续执行语句的流程； 执行完成后，把状态设置成空字符串。 也就是说，“Sending data”并不一定是指“正在发送数据”，而可能是处于执行器过程中的任意阶段。比如，可以构造一个锁等待的场景，就能看到 Sending data 状态。 可以看到，session B 明显是在等锁，状态显示为 Sending data。 也就是说，仅当一个线程处于“等待客户端接收结果”的状态，才会显示\"Sending to client\"；而如果显示成“Sending data”，它的意思只是“正在执行”。 现在你知道了，查询的结果是分段发给客户端的，因此扫描全表，查询返回大量的数据，并不会把内存打爆。在 server 层的处理逻辑都清楚了，在 InnoDB 引擎里面又是怎么处理的呢？扫描全表会不会对引擎系统造成影响呢？ 2 全表扫描对 InnoDB 的影响 InnoDB 内存的一个作用，是保存更新的结果，再配合 redo log，就避免了随机写盘。内存的数据页是在 Buffer Pool (BP) 中管理的，在 WAL 里 Buffer Pool 起到了加速更新的作用。而实际上，Buffer Pool 还有一个更重要的作用，就是加速查询。 由于有 WAL 机制，当事务提交的时候，磁盘上的数据页是旧的，那如果这时候马上有一个查询要来读这个数据页，是不是要马上把 redo log 应用到数据页呢？答案是不需要。因为这时候内存数据页的结果是最新的，直接读内存页就可以了。这时候查询根本不需要读磁盘，直接从内存拿结果，速度是很快的。所以说，Buffer Pool 还有加速查询的作用。 而 Buffer Pool 对查询的加速效果，依赖于一个重要的指标，即：内存命中率。可以在 show engine innodb status 结果中，查看一个系统当前的 BP 命中率。一般情况下，一个稳定服务的线上系统，要保证响应时间符合要求的话，内存命中率要在 99% 以上。 执行 show engine innodb status，可以看到“Buffer pool hit rate”字样，显示的就是当前的命中率。比如下图这个命中率，就是 99.0%。 如果所有查询需要的数据页都能够直接从内存得到，那是最好的，对应的命中率就是 100%。但，这在实际生产上是很难做到的。 InnoDB Buffer Pool 的大小是由参数 innodb_buffer_pool_size 确定的，一般建议设置成可用物理内存的 60%~80%。 在大约十年前，单机的数据量是上百个 G，而物理内存是几个 G；现在虽然很多服务器都能有 128G 甚至更高的内存，但是单机的数据量却达到了 T 级别。 所以，innodb_buffer_pool_size 小于磁盘的数据量是很常见的。如果一个 Buffer Pool 满了，而又要从磁盘读入一个数据页，那肯定是要淘汰一个旧数据页的。 InnoDB 内存管理用的是最近最少使用 (Least Recently Used, LRU) 算法，这个算法的核心就是淘汰最久未使用的数据。下图是一个 LRU 算法的基本模型。 InnoDB 管理 Buffer Pool 的 LRU 算法，是用链表来实现的。 在上图的状态 1 里，链表头部是 P1，表示 P1 是最近刚刚被访问过的数据页；假设内存里只能放下这么多数据页； 这时候有一个读请求访问 P3，因此变成状态 2，P3 被移到最前面； 状态 3 表示，这次访问的数据页是不存在于链表中的，所以需要在 Buffer Pool 中新申请一个数据页 Px，加到链表头部。但是由于内存已经满了，不能申请新的内存。于是，会清空链表末尾 Pm 这个数据页的内存，存入 Px 的内容，然后放到链表头部。 从效果上看，就是最久没有被访问的数据页 Pm，被淘汰了。 这个算法乍一看上去没什么问题，但是如果考虑到要做一个全表扫描，会不会有问题呢？假设按照这个算法，要扫描一个 200G 的表，而这个表是一个历史数据表，平时没有业务访问它。那么，按照这个算法扫描的话，就会把当前的 Buffer Pool 里的数据全部淘汰掉，存入扫描过程中访问到的数据页的内容。也就是说 Buffer Pool 里面主要放的是这个历史数据表的数据。 对于一个正在做业务服务的库，这可不妙。你会看到，Buffer Pool 的内存命中率急剧下降，磁盘压力增加，SQL 语句响应变慢。所以，InnoDB 不能直接使用这个 LRU 算法。实际上，InnoDB 对 LRU 算法做了改进。 在 InnoDB 实现上，按照 5:3 的比例把整个 LRU 链表分成了 young 区域和 old 区域。图中 LRU_old 指向的就是 old 区域的第一个位置，是整个链表的 5/8 处。也就是说，靠近链表","date":"2025-02-23","objectID":"/posts/33.%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"33 | 我查这么多数据，会不会把数据库内存打爆？","uri":"/posts/33.%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"MySQL 中的 kill 命令有两种形式：kill query 和 kill connection，分别用于终止正在执行的语句和断开连接。然而，有时候执行 kill 命令却无法生效，导致语句仍在执行。","date":"2025-02-23","objectID":"/posts/32.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%9C%89kill%E4%B8%8D%E6%8E%89%E7%9A%84%E8%AF%AD%E5%8F%A5/","tags":["MySQL 实战 45 讲","MySQL"],"title":"32 | 为什么还有 kill 不掉的语句？","uri":"/posts/32.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%9C%89kill%E4%B8%8D%E6%8E%89%E7%9A%84%E8%AF%AD%E5%8F%A5/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 MySQL 中的 kill 命令有两种形式：kill query 和 kill connection，分别用于终止正在执行的语句和断开连接。然而，有时候执行 kill 命令却无法生效，导致语句仍在执行。这种情况可能是因为线程没有执行到判断线程状态的逻辑，或者是由于终止逻辑耗时较长。例如，在超大事务执行期间被 kill 时，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长。 在 MySQL 中有两个 kill 命令：一个是 kill query + 线程 id，表示终止这个线程中正在执行的语句；一个是 kill connection + 线程 id，这里 connection 可缺省，表示断开这个线程的连接，当然如果这个线程有语句正在执行，也是要先停止正在执行的语句的。 不知道你在使用 MySQL 的时候，有没有遇到过这样的现象：使用了 kill 命令，却没能断开这个连接。再执行 show processlist 命令，看到这条语句的 Command 列显示的是 Killed。显示为 Killed 是什么意思，不是应该直接在 show processlist 的结果里看不到这个线程了吗？ 其实大多数情况下，kill query/connection 命令是有效的。比如，执行一个查询的过程中，发现执行时间太久，要放弃继续查询，这时就可以用 kill query 命令，终止这条查询语句。 还有一种情况是，语句处于锁等待的时候，直接使用 kill 命令也是有效的。一起来看下这个例子： 可以看到，session C 执行 kill query 以后，session B 几乎同时就提示了语句被中断。这，就是预期的结果。 1 收到 kill 以后，线程做什么？ 这里要停下来想一下：session B 是直接终止掉线程，什么都不管就直接退出吗？显然，这是不行的。当对一个表做增删改查操作时，会在表上加 MDL 读锁。所以，session B 虽然处于 blocked 状态，但还是拿着一个 MDL 读锁的。如果线程被 kill 的时候，就直接终止，那之后这个 MDL 读锁就没机会被释放了。 这样看来，kill 并不是马上停止的意思，而是告诉执行线程说，这条语句已经不需要继续执行了，可以开始“执行停止的逻辑了”。 其实，这跟 Linux 的 kill 命令类似，kill -N pid 并不是让进程直接停止，而是给进程发一个信号，然后进程处理这个信号，进入终止逻辑。只是对于 MySQL 的 kill 命令来说，不需要传信号量参数，就只有“停止”这个命令。 实现上，当用户执行 kill query thread_id_B 时，MySQL 里处理 kill 命令的线程做了两件事： 把 session B 的运行状态改成 THD::KILL_QUERY(将变量 killed 赋值为 THD::KILL_QUERY)； 给 session B 的执行线程发一个信号。 为什么要发信号呢？因为上图的例子里面，session B 处于锁等待状态，如果只是把 session B 的线程状态设置 THD::KILL_QUERY，线程 B 并不知道这个状态变化，还是会继续等待。发一个信号的目的，就是让 session B 退出等待，来处理这个 THD::KILL_QUERY 状态。上面的分析中，隐含了这么三层意思： 一个语句执行过程中有多处“埋点”，在这些“埋点”的地方判断线程状态，如果发现线程状态是 THD::KILL_QUERY，才开始进入语句终止逻辑； 如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处； 语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的。 到这里就知道了原来不是“说停就停的”。接下来，再看一个 kill 不掉的例子，也就是在前面提到的 innodb_thread_concurrency 不够用的例子。首先，执行 set global innodb_thread_concurrency=2，将 InnoDB 的并发线程上限数设置为 2；然后，执行下面的序列： 可以看到： sesssion C 执行的时候被堵住了； 但是 session D 执行的 kill query C 命令却没什么效果， 直到 session E 执行了 kill connection 命令，才断开了 session C 的连接，提示“Lost connection to MySQL server during query”， 但是这时候，如果在 session E 中执行 show processlist，就能看到下面这个图。 这时候，id=12 这个线程的 Commnad 列显示的是 Killed。也就是说，客户端虽然断开了连接，但实际上服务端上这条语句还在执行过程中。 为什么在执行 kill query 命令时，这条语句不像第一个例子的 update 语句一样退出呢？ 在实现上，等行锁时，使用的是 pthread_cond_timedwait 函数，这个等待状态可以被唤醒。但是，在这个例子里，12 号线程的等待逻辑是这样的：每 10 毫秒判断一下是否可以进入 InnoDB 执行，如果不行，就调用 nanosleep 函数进入 sleep 状态。 也就是说，虽然 12 号线程的状态已经被设置成了 KILL_QUERY，但是在这个等待进入 InnoDB 的循环过程中，并没有去判断线程的状态，因此根本不会进入终止逻辑阶段。 而当 session E 执行 kill connection 命令时，是这么做的： 把 12 号线程状态设置为 KILL_CONNECTION； 关掉 12 号线程的网络连接。因为有这个操作，所以会看到，这时候 session C 收到了断开连接的提示。 那为什么执行 show processlist 的时候，会看到 Command 列显示为 killed 呢？其实，这就是因为在执行 show processlist 的时候，有一个特别的逻辑： 如果一个线程的状态是 KILL_CONNECTION，就把 Command 列显示成 Killed。 所以其实，即使是客户端退出了，这个线程的状态仍然是在等待中。那这个线程什么时候会退出呢？答案是，只有等到满足进入 InnoDB 的条件后，session C 的查询语句继续执行，然后才有可能判断到线程状态已经变成了 KILL_QUERY 或者 KILL_CONNECTION，再进入终止逻辑阶段。到这里，来小结一下。 这个例子是 kill 无效的第一类情况，即：线程没有执行到判断线程状态的逻辑。跟这种情况相同的，还有由于 IO 压力过大，读写 IO 的函数一直无法返回，导致不能及时判断线程的状态。 另一类情况是，终止逻辑耗时较长。这时候，从 show processlist 结果上看也是 Command=Killed，需要等到终止逻辑完成，语句才算真正完成。这类情况，比较常见的场景有以下几种： 超大事务执行期间被 kill。这时候，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长。 大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待 IO 资源，导致耗时较长。 DDL 命令执行到最后阶段，如果被 kill，需要删除中间过程的临时文件，也可能受 IO 资源影响耗时较久。 如果直接在客户端通过 Ctrl+C 命令，是不是就可以直接终止线程呢？答案是，不可以。这里有一个误解，其实在客户端的操作只能操作到客户端的线程，客户端和服务端只能通过网络交互，是不可能直接操作服务端线程的。 而由于 MySQL 是停等协议，所以这个线程执行的语句还没有返回的时候，再往这个连接里面继续发命令也是没有用的。实际上，执行 Ctrl+C 的时候，是 MySQL 客户端另外启动一个连接，然后发送一个 kill query 命令。所以，可别以为在客户端执行完 Ctrl+C 就万事大吉了。因为，要 kill 掉一个线程，还涉及到后端的很多操作。 2 另外两个关于客户端的误解 第一个误解是：如果库里面的表特别多，连接就会很慢。 有些线上的库，会包含很多表。这时候就会发现，每次用客户端连接都会卡在下面这个界面上。 而如果 db1 这个库里表很少的话，连接起来就会很快，可以很快进入输入命令的状态。因此，有同学会认为是表的数目影响了连接性能。每个客户端在和服务端建立连接的时候，需要做的事情就是 TCP 握手、用户校验、获取权限。但这几个操作，显然跟库里面表的个数无关。但实际上，正如图中的文字提示所说的，当使用默认参数连接的时候，MySQL 客户端会提供一个本地库名和表名补全的功能。为了实现这个功能，客户端在连接成功后，需要多做一些操作： 执行 show databases； 切到 db1 库，执行 show tables； 把这两个命令的结果用于构建一个本地的哈希表。 在这些操作中，最花时间的就是第三步在本地构建哈希表的操作。所以，当一个库中的表个数非常多的时候，这一步就会花比较长的时间。也就是说，感知到的连接过程慢，其实并不是连接慢，也不是服务端慢，而是客户端慢。 图中的提示也说了，如果在连接命令中加上 -A，就可以关掉这个自动补全的功能，然后客户端就可以快速返回了。这里自动补全的效果就是，在输入库名或者表名的时候，输入前缀，可以使用 Tab 键自动补全表名或者显示提示。实际使用中，如果自动补全功能用得并不多，建议每次使用的时候都默认加 -A。 其实提示","date":"2025-02-23","objectID":"/posts/32.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%9C%89kill%E4%B8%8D%E6%8E%89%E7%9A%84%E8%AF%AD%E5%8F%A5/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"32 | 为什么还有 kill 不掉的语句？","uri":"/posts/32.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%9C%89kill%E4%B8%8D%E6%8E%89%E7%9A%84%E8%AF%AD%E5%8F%A5/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文总结了处理 MySQL 误删数据的方法。","date":"2025-02-23","objectID":"/posts/31.%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E5%90%8E%E9%99%A4%E4%BA%86%E8%B7%91%E8%B7%AF%E8%BF%98%E8%83%BD%E6%80%8E%E4%B9%88%E5%8A%9E/","tags":["MySQL 实战 45 讲","MySQL"],"title":"31 | 误删数据后除了跑路，还能怎么办？","uri":"/posts/31.%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E5%90%8E%E9%99%A4%E4%BA%86%E8%B7%91%E8%B7%AF%E8%BF%98%E8%83%BD%E6%80%8E%E4%B9%88%E5%8A%9E/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文总结了处理 MySQL 误删数据的方法。针对误删数据行，建议使用 Flashback 工具修改 binlog 内容来恢复数据；对于误删表或数据库，建议通过恢复备份或临时库进行数据恢复。 为了找到解决误删数据的更高效的方法，先对和 MySQL 相关的误删数据，做下分类： 使用 delete 语句误删数据行； 使用 drop table 或者 truncate table 语句误删数据表； 使用 drop database 语句误删数据库； 使用 rm 命令误删整个 MySQL 实例。 1 误删行 如果是使用 delete 语句误删了数据行，可以用 Flashback 工具通过闪回把数据恢复回来。Flashback 恢复数据的原理，是修改 binlog 的内容，拿回原库重放。而能够使用这个方案的前提是，需要确保 binlog_format=row 和 binlog_row_image=FULL。具体恢复数据时，对单个事务做如下处理： 对于 insert 语句，对应的 binlog event 类型是 Write_rows event，把它改成 Delete_rows event 即可； 同理，对于 delete 语句，也是将 Delete_rows event 改为 Write_rows event； 而如果是 Update_rows 的话，binlog 里面记录了数据行修改前和修改后的值，对调这两行的位置即可。 如果误操作不是一个，而是多个，会怎么样呢？比如下面三个事务： (A)delete ... (B)insert ... (C)update ... 现在要把数据库恢复回这三个事务操作之前的状态，用 Flashback 工具解析 binlog 后，写回主库的命令是： (reverse C)update ... (reverse B)delete ... (reverse A)insert ... 也就是说，如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行。需要说明的是，不建议直接在主库上执行这些操作。恢复数据比较安全的做法，是恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库。 这是因为，一个在执行线上逻辑的主库，数据状态的变更往往是有关联的。可能由于发现数据问题的时间晚了一点儿，就导致已经在之前误操作的基础上，业务代码逻辑又继续修改了其他数据。所以，如果这时候单独恢复这几行数据，而又未经确认的话，就可能会出现对数据的二次破坏。当然，不止要说误删数据的事后处理办法，更重要是要做到事前预防。有以下两个建议： 把 sql_safe_updates 参数设置为 on。这样一来，如果忘记在 delete 或者 update 语句中写 where 条件，或者 where 条件里面没有包含索引字段的话，这条语句的执行就会报错。 代码上线前，必须经过 SQL 审计。 设置了 sql_safe_updates=on，如果真的要把一个小表的数据全部删掉，应该怎么办呢？如果确定这个删除操作没问题的话，可以在 delete 语句中加上 where 条件，比如 where id\u003e=0。 但是，delete 全表是很慢的，需要生成回滚日志、写 redo、写 binlog。所以，从性能角度考虑，应该优先考虑使用 truncate table 或者 drop table 命令。 使用 delete 命令删除的数据，还可以用 Flashback 来恢复。而使用 truncate /drop table 和 drop database 命令删除的数据，就没办法通过 Flashback 来恢复了。为什么呢？ 因为即使配置了 binlog_format=row，执行这三个命令时，记录的 binlog 还是 statement 格式。binlog 里面就只有一个 truncate/drop 语句，这些信息是恢复不出数据的。 2 误删库 / 表 这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的全量备份，并且实时备份 binlog。在这两个条件都具备的情况下，假如有人中午 12 点误删了一个库，恢复数据的流程如下： 取最近一次全量备份，假设这个库是一天一备，上次备份是当天 0 点； 用备份恢复出一个临时库； 从日志备份里面，取出凌晨 0 点之后的日志； 把这些日志，除了误删除数据的语句外，全部应用到临时库。 这个流程的示意图如下所示： 关于这个过程，需要和你说明如下几点： 为了加速数据恢复，如果这个临时库上有多个数据库，可以在使用 mysqlbinlog 命令时，加上一个–database 参数，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用其他库日志的情况。 在应用日志的时候，需要跳过 12 点误操作的那个语句的 binlog： 如果原实例没有使用 GTID 模式，只能在应用到包含 12 点的 binlog 文件的时候，先用–stop-position 参数执行到误操作之前的日志，然后再用–start-position 从误操作之后的日志继续执行； 如果实例使用了 GTID 模式，就方便多了。假设误操作命令的 GTID 是 gtid1，那么只需要执行 set gtid_next=gtid1;begin;commit; 先把这个 GTID 加到临时实例的 GTID 集合，之后按顺序执行 binlog 的时候，就会自动跳过误操作的语句。 不过，即使这样，使用 mysqlbinlog 方法恢复数据还是不够快，主要原因有两个： 如果是误删表，最好就是只恢复出这张表，也就是只重放这张表的操作，但是 mysqlbinlog 工具并不能指定只解析一个表的日志； 用 mysqlbinlog 解析出日志应用，应用日志的过程就只能是单线程。 一种加速的方法是，在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库，这样： 在 start slave 之前，先通过执行﻿change replication filter replicate_do_table = (tbl_name) 命令，就可以让临时库只同步误操作的表； 这样做也可以用上并行复制技术，来加速整个数据恢复过程。 这个过程的示意图如下所示。 可以看到，图中 binlog 备份系统到线上备库有一条虚线，是指如果由于时间太久，备库上已经删除了临时实例需要的 binlog 的话，可以从 binlog 备份系统中找到需要的 binlog，再放回备库中。 假设发现当前临时实例需要的 binlog 是从 master.000005 开始的，但是在备库上执行 show binlogs 显示的最小的 binlog 文件是 master.000007，意味着少了两个 binlog 文件。这时，就需要去 binlog 备份系统中找到这两个文件。把之前删掉的 binlog 放回备库的操作步骤，是这样的： 从备份系统下载 master.000005 和 master.000006 这两个文件，放到备库的日志目录下； 打开日志目录下的 master.index 文件，在文件开头加入两行，内容分别是“./master.000005”和“./master.000006”; 重启备库，目的是要让备库重新识别这两个日志文件； 现在这个备库上就有了临时库需要的所有 binlog 了，建立主备关系，就可以正常同步了。 不论是把 mysqlbinlog 工具解析出的 binlog 文件应用到临时库，还是把临时库接到备库上，这两个方案的共同点是：误删库或者表后，恢复数据的思路主要就是通过备份，再加上应用 binlog 的方式。 也就是说，这两个方案都要求备份系统定期备份全量日志，而且需要确保 binlog 在被从本地删除之前已经做了备份。 但是，一个系统不可能备份无限的日志，还需要根据成本和磁盘空间资源，设定一个日志保留的天数。如果你的 DBA 团队告诉你，可以保证把某个实例恢复到半个月内的任意时间点，这就表示备份系统保留的日志时间就至少是半个月。 不论使用上述哪种方式，都要把这个数据恢复功能做成自动化工具，并且经常拿出来演练。为什么这么说呢？这里的原因，主要包括两个方面： 虽然“发生这种事，大家都不想的”，但是万一出现了误删事件，能够快速恢复数据，将损失降到最小，也应该不用跑路了。 而如果临时再手忙脚乱地手动操作，最后又误操作了，对业务造成了二次伤害，那就说不过去了。 3 延迟复制备库 虽然可以通过利用并行复制来加速恢复数据的过程，但是这个方案仍然存在“恢复时间不可控”的问题。 如果一个库的备份特别大，或者误操作的时间距离上一个全量备份的时间较长，比如一周一备的实例，在备份之后的第 6 天发生误操作，那就需要恢复 6 天的日志，这个恢复时间可能是要按天来计算的。那么，有什么方法可以缩短恢复数据需要的时间呢？ 如果有非常核心的业务，不允许太长的恢复时间，可以考虑搭建延迟复制的备库。这个功能是 MySQL 5.6 版本引入的。 一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有从库，进而导致所有从库的数据表也都一起被误删了。 延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY = N 命令，可以指定这个备库持续保持跟主库有 N 秒的延迟。 比如你把 N 设置为 3600，这就代表了如果主库上有数据被误删了，并且在 1 小时内发现了这个误操作命令，这个命令就还没有在这","date":"2025-02-23","objectID":"/posts/31.%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E5%90%8E%E9%99%A4%E4%BA%86%E8%B7%91%E8%B7%AF%E8%BF%98%E8%83%BD%E6%80%8E%E4%B9%88%E5%8A%9E/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"31 | 误删数据后除了跑路，还能怎么办？","uri":"/posts/31.%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E5%90%8E%E9%99%A4%E4%BA%86%E8%B7%91%E8%B7%AF%E8%BF%98%E8%83%BD%E6%80%8E%E4%B9%88%E5%8A%9E/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入探讨了 InnoDB 的加锁规则，通过具体案例分析，动态解析了加锁过程。","date":"2025-02-23","objectID":"/posts/30.%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%BA%8C%E7%94%A8%E5%8A%A8%E6%80%81%E7%9A%84%E8%A7%82%E7%82%B9%E7%9C%8B%E5%8A%A0%E9%94%81/","tags":["MySQL 实战 45 讲","MySQL"],"title":"30 | 答疑文章（二）：用动态的观点看加锁","uri":"/posts/30.%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%BA%8C%E7%94%A8%E5%8A%A8%E6%80%81%E7%9A%84%E8%A7%82%E7%82%B9%E7%9C%8B%E5%8A%A0%E9%94%81/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入探讨了 InnoDB 的加锁规则，通过具体案例分析，动态解析了加锁过程。文章首先回顾了加锁规则，包括 next-key lock 作为基本单位、访问对象才会加锁等内容。随后，通过查询案例分析了不等号条件中的等值查询和并发执行可能出现的死锁问题。 复习一下加锁规则。这个规则中，包含了两个“原则”、两个“优化”和一个“bug”： 原则 1：加锁的基本单位是 next-key lock，next-key lock 是前开后闭区间。 原则 2：查找过程中访问到的对象才会加锁。 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。 接下来的讨论基于下面这个表 t： CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`) ) ENGINE=InnoDB; insert into t values(0,0,0),(5,5,5), (10,10,10),(15,15,15),(20,20,20),(25,25,25); 1 不等号条件里的等值查询 先来一起来看下这个例子，分析一下这条查询语句的加锁范围： begin; select * from t where id\u003e9 and id\u003c12 order by id desc for update; 利用上面的加锁规则，我们知道这个语句的加锁范围是主键索引上的 (0,5]、(5,10] 和 (10, 15)。也就是说，id=15 这一行，并没有被加上行锁。为什么呢？ 我们说加锁单位是 next-key lock，都是前开后闭区间，但是这里用到了优化 2，即索引上的等值查询，向右遍历的时候 id=15 不满足条件，所以 next-key lock 退化为了间隙锁 (10, 15)。 但是，查询语句中 where 条件是大于号和小于号，这里的“等值查询”又是从哪里来的呢？要知道，加锁动作是发生在语句执行过程中的，所以分析加锁行为的时候，要从索引上的数据结构开始。这里再把这个过程拆解一下。如下图所示，是这个表的索引 id 的示意图。 首先这个查询语句的语义是 order by id desc，要拿到满足条件的所有行，优化器必须先找到“第一个 id\u003c12 的值”。 这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到 id=12 的这个值，只是最终没找到，但找到了 (10,15) 这个间隙。 然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到 id=5 这一行，所以会加一个 next-key lock (0,5]。 也就是说，在执行过程中，通过树搜索的方式定位记录的时候，用的是“等值查询”的方法。 2 等值查询的过程 与上面这个例子对应的，下面这个语句的加锁范围是什么？ begin; select id from t where c in(5,20,10) lock in share mode; 这条查询语句里用的是 in，先来看这条语句的 explain 结果。 可以看到，这条 in 语句使用了索引 c 并且 rows=3，说明这三个值都是通过 B+ 树搜索定位的。 在查找 c=5 的时候，先锁住了 (0,5]。但是因为 c 不是唯一索引，为了确认还有没有别的记录 c=5，就要向右遍历，找到 c=10 才确认没有了，这个过程满足优化 2，所以加了间隙锁 (5,10)。 同样的，执行 c=10 这个逻辑的时候，加锁的范围是 (5,10] 和 (10,15)；执行 c=20 这个逻辑的时候，加锁的范围是 (15,20] 和 (20,25)。 通过这个分析，可以知道，这条语句在索引 c 上加的三个记录锁的顺序是：先加 c=5 的记录锁，再加 c=10 的记录锁，最后加 c=20 的记录锁。 这个加锁范围，不就是从 (5,25) 中去掉 c=15 的行锁吗？为什么这么麻烦地分段说呢？因为要强调这个过程：这些锁是“在执行过程中一个一个加的”，而不是一次性加上去的。 理解了这个加锁过程之后，就可以来分析下面例子中的死锁问题了。如果同时有另外一个语句，是这么写的： select id from t where c in(5,20,10) order by c desc for update; 此时的加锁范围，又是什么呢？ 现在都知道间隙锁是不互锁的，但是这两条语句都会在索引 c 上的 c=5、10、20 这三行记录上加记录锁。 这里需要注意一下，由于语句里面是 order by c desc，这三个记录锁的加锁顺序，是先锁 c=20，然后 c=10，最后是 c=5。 也就是说，这两条语句要加锁相同的资源，但是加锁顺序相反。当这两条语句并发执行的时候，就可能出现死锁。关于死锁的信息，MySQL 只保留了最后一个死锁的现场，但这个现场还是不完备的。 3 怎么看死锁？ 下图是在出现死锁后，执行 show engine innodb status 命令得到的部分输出。这个命令会输出很多信息，有一节 LATESTDETECTED DEADLOCK，就是记录的最后一次死锁信息。 来看看这图中的几个关键信息。 这个结果分成三部分： (1) TRANSACTION，是第一个事务的信息； (2) TRANSACTION，是第二个事务的信息； WE ROLL BACK TRANSACTION (1)，是最终的处理结果，表示回滚了第一个事务。 第一个事务的信息中： WAITING FOR THIS LOCK TO BE GRANTED，表示的是这个事务在等待的锁信息； index c of table test.t，说明在等的是表 t 的索引 c 上面的锁； lock mode S waiting 表示这个语句要自己加一个读锁，当前的状态是等待中； Record lock 说明这是一个记录锁； n_fields 2 表示这个记录是两列，也就是字段 c 和主键字段 id； 0: len 4; hex 0000000a; asc ;; 是第一个字段，也就是 c。值是十六进制 a，也就是 10； 1: len 4; hex 0000000a; asc ;; 是第二个字段，也就是主键 id，值也是 10； 这两行里面的 asc 表示的是，接下来要打印出值里面的“可打印字符”，但 10 不是可打印字符，因此就显示空格。 第一个事务信息就只显示出了等锁的状态，在等待 (c=10,id=10) 这一行的锁。 当然你是知道的，既然出现死锁了，就表示这个事务也占有别的锁，但是没有显示出来。别着急，从第二个事务的信息中推导出来。 第二个事务显示的信息要多一些： “HOLDS THE LOCK(S)”用来显示这个事务持有哪些锁； index c of table test.t 表示锁是在表 t 的索引 c 上； hex 0000000a 和 hex 00000014 表示这个事务持有 c=10 和 c=20 这两个记录锁； WAITING FOR THIS LOCK TO BE GRANTED，表示在等 (c=5,id=5) 这个记录锁。 从上面这些信息中，就可以知道： “lock in share mode”的这条语句，持有 c=5 的记录锁，在等 c=10 的锁； “for update”这个语句，持有 c=20 和 c=10 的记录锁，在等 c=5 的记录锁。 因此导致了死锁。这里可以得到两个结论： 由于锁是一个个加的，要避免死锁，对同一组资源，要按照尽量相同的顺序访问； 在发生死锁的时刻，for update 这条语句占有的资源更多，回滚成本更大，所以 InnoDB 选择了回滚成本更小的 lock in share mode 语句，来回滚。 4 怎么看锁等待？ 看完死锁，再来看一个锁等待的例子。 可以看到，由于 session A 并没有锁住 c=10 这个记录，所以 session B 删除 id=10 这一行是可以的。但是之后，session B 再想 insert id=10 这一行回去就不行了。 现在来看一下此时 show engine innodb status 的结果，看看能不有一些提示。锁信息是在这个命令输出结果的 TRANSACTIONS 这一节。可以在文稿中看到这张图片。 来看几个关键信息。 index PRIMARY of table test.t ，表示这个语句被锁住是因为表 t 主键上的某个锁。 lock_mode X locks gap before rec insert intention waiting 这里有几个信息： insert intention 表示当前线程准备插入一个记录，这是一个插入意向锁。为了便于理解，可以认为它就是这个插入动作本身。 gap before rec 表示这是一个间隙锁，而不是记录锁。 那么这个 gap 是在哪个记录之前的呢？接下来的 0~4 这 5 行的内容就是这个记录的信息。 n_fields 5 也表示了，这一个记录有 5 列： 0: len 4; hex 0000000f; asc ;; 第一列是主键 id 字段，十六进制 f 就是 id=15。所以，这时我们","date":"2025-02-23","objectID":"/posts/30.%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%BA%8C%E7%94%A8%E5%8A%A8%E6%80%81%E7%9A%84%E8%A7%82%E7%82%B9%E7%9C%8B%E5%8A%A0%E9%94%81/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"30 | 答疑文章（二）：用动态的观点看加锁","uri":"/posts/30.%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%BA%8C%E7%94%A8%E5%8A%A8%E6%80%81%E7%9A%84%E8%A7%82%E7%82%B9%E7%9C%8B%E5%8A%A0%E9%94%81/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"这篇文章介绍了如何判断数据库健康状态以及相应的监控和应对措施。","date":"2025-02-23","objectID":"/posts/29.%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E4%B8%8D%E6%98%AF%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86/","tags":["MySQL 实战 45 讲","MySQL"],"title":"29 | 如何判断一个数据库是不是出问题了？","uri":"/posts/29.%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E4%B8%8D%E6%98%AF%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 这篇文章介绍了如何判断数据库健康状态以及相应的监控和应对措施。首先讲解了主备切换的流程，包括主动切换和被动切换。重点讨论了如何判断主库是否出现问题，指出了简单的 select 1 并不能完全判断主库的正常运行状态。文章详细介绍了 InnoDB 的并发线程控制参数 innodb_thread_concurrency 的作用，以及如何通过设置一个健康检查表来检测并发线程数过多导致的数据库不可用情况。同时，提到了当 binlog 所在磁盘空间满了以后，更新语句和事务提交的影响，以及如何改进监控语句来应对这种情况。 在一主一备的双 M 架构里，主备切换只需要把客户端流量切到备库；而在一主多从架构里，主备切换除了要把客户端流量切到备库外，还需要把从库接到新主库上。 主备切换有两种场景，一种是主动切换，一种是被动切换。而其中被动切换，往往是因为主库出问题了，由 HA 系统发起的。那么怎么判断一个主库出问题了？ 1 select 1 判断 你一定会说，这很简单啊，连上 MySQL，执行个 select 1 就好了。但是 select 1 成功返回了，就表示主库没问题吗？实际上，select 1 成功返回，只能说明这个库的进程还在，并不能说明主库没问题。现在，来看一下这个场景。 set global innodb_thread_concurrency=3; CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB; insert into t values(1,1) 设置 innodb_thread_concurrency 参数的目的是，控制 InnoDB 的并发线程上限。也就是说，一旦并发线程数达到这个值，InnoDB 在接收到新请求的时候，就会进入等待状态，直到有线程退出。这里，把 innodb_thread_concurrency 设置成 3，表示 InnoDB 只允许 3 个线程并行执行。而在例子中，前三个 session 中的 sleep(100)，使得这三个语句都处于“执行”状态，以此来模拟大查询。 可以看到，session D 里面，select 1 是能执行成功的，但是查询表 t 的语句会被堵住。也就是说，如果这时候用 select 1 来检测实例是否正常的话，是检测不出问题的。 在 InnoDB 中，innodb_thread_concurrency 这个参数的默认值是 0，表示不限制并发线程数量。但是，不限制并发线程数肯定是不行的。因为，一个机器的 CPU 核数有限，线程全冲进来，上下文切换的成本就会太高。 所以，通常情况下，建议把 innodb_thread_concurrency 设置为 64~128 之间的值。这时，你一定会有疑问，并发线程上限数设置为 128 够干啥，线上的并发连接数动不动就上千了。产生这个疑问的原因，是搞混了并发连接和并发查询。 并发连接和并发查询，并不是同一个概念。在 show processlist 的结果里，看到的几千个连接，指的就是并发连接。而“当前正在执行”的语句，才是上面所说的并发查询。 并发连接数达到几千个影响并不大，就是多占一些内存而已。应该关注的是并发查询，因为并发查询太高才是 CPU 杀手。这也是为什么需要设置 innodb_thread_concurrency 参数的原因。 如果把 innodb_thread_concurrency 设置为 128 的话，那么出现同一行热点更新的问题时，是不是很快就把 128 消耗完了，这样整个系统是不是就挂了呢？实际上，在线程进入锁等待以后，并发线程的计数会减一，也就是说等行锁（也包括间隙锁）的线程是不算在 128 里面的。 MySQL 这样设计是非常有意义的。因为，进入锁等待的线程已经不吃 CPU 了；更重要的是，必须这么设计，才能避免整个系统锁死。为什么呢？假设处于锁等待的线程也占并发线程的计数，可以设想一下这个场景： 线程 1 执行 begin; update t set c=c+1 where id=1, 启动了事务 trx1，然后保持这个状态。这时候，线程处于空闲状态，不算在并发线程里面。 线程 2 到线程 129 都执行 update t set c=c+1 where id=1; 由于等行锁，进入等待状态。这样就有 128 个线程处于等待状态； 如果处于锁等待状态的线程计数不减一，InnoDB 就会认为线程数用满了，会阻止其他语句进入引擎执行，这样线程 1 不能提交事务。而另外的 128 个线程又处于锁等待状态，整个系统就堵住了。 下图显示的就是这个状态。 这时候 InnoDB 不能响应任何请求，整个系统被锁死。而且，由于所有线程都处于等待状态，此时占用的 CPU 却是 0，而这明显不合理。所以说 InnoDB 在设计时，遇到进程进入锁等待的情况时，将并发线程的计数减 1 的设计，是合理而且是必要的。 虽然说等锁的线程不算在并发线程计数里，但如果它在真正地执行查询，就比如上面例子中前三个事务中的 select sleep(100) from t，还是要算进并发线程的计数的。 在这个例子中，同时在执行的语句超过了设置的 innodb_thread_concurrency 的值，这时候系统其实已经不行了，但是通过 select 1 来检测系统，会认为系统还是正常的。 因此使用 select 1 的判断逻辑要修改一下。 2 查表判断 为了能够检测 InnoDB 并发线程数过多导致的系统不可用情况，需要找一个访问 InnoDB 的场景。一般的做法是，在系统库（mysql 库）里创建一个表，比如命名为 health_check，里面只放一行数据，然后定期执行： mysql\u003e select * from mysql.health_check; 使用这个方法，可以检测出由于并发线程过多导致的数据库不可用的情况。但是马上还会碰到下一个问题，即：空间满了以后，这种方法又会变得不好使。 更新事务要写 binlog，而一旦 binlog 所在磁盘的空间占用率达到 100%，那么所有的更新语句和事务提交的 commit 语句就都会被堵住。但是，系统这时候还是可以正常读数据的。 因此，还是把这条监控语句再改进一下。接下来就看看把查询语句改成更新语句后的效果。 3 更新判断 既然要更新，就要放个有意义的字段，常见做法是放一个 timestamp 字段，用来表示最后一次执行检测的时间。这条更新语句类似于： mysql\u003e update mysql.health_check set t_modified=now(); 节点可用性的检测都应该包含主库和备库。如果用更新来检测主库的话，那么备库也要进行更新检测。 但，备库的检测也是要写 binlog 的。由于一般会把数据库 A 和 B 的主备关系设计为双 M 结构，所以在备库 B 上执行的检测命令，也要发回给主库 A。 但是，如果主库 A 和备库 B 都用相同的更新命令，就可能出现行冲突，也就是可能会导致主备同步停止。所以，现在看来 mysql.health_check 这个表就不能只有一行数据了。 为了让主备之间的更新不产生冲突，可以在 mysql.health_check 表上存入多行数据，并用 A、B 的 server_id 做主键。 mysql\u003e CREATE TABLE `health_check` ( `id` int(11) NOT NULL, `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`) ) ENGINE=InnoDB; /* 检测命令 */ insert into mysql.health_check(id, t_modified) values (@@server_id, now()) on duplicate key update t_modified=now(); 由于 MySQL 规定了主库和备库的 server_id 必须不同（否则创建主备关系的时候就会报错），这样就可以保证主、备库各自的检测命令不会发生冲突。 更新判断是一个相对比较常用的方案了，不过依然存在一些问题。其中，“判定慢”一直是让 DBA 头疼的问题。但是，更新语句，如果失败或者超时，就可以发起主备切换了，为什么还会有判定慢的问题呢？其实，这里涉及到的是服务器 IO 资源分配的问题。 首先，所有的检测逻辑都需要一个超时时间 N。执行一条 update 语句，超过 N 秒后还不返回，就认为系统不可用。可以设想一个日志盘的 IO 利用率已经是 100% 的场景。这时候，整个系统响应非常慢，已经需要做主备切换了。 但是你要知道，IO 利用率 100% 表示系统的 IO 是在工作的，每个请求都有机会获得 IO 资源，执行自己的任务。而检测使用的 update 命令，需要的资源很少，所以可能在拿到 IO 资源的时候就可以提交成功，并且在超时时间 N 秒未到达之前就返回给了检测系统。检测系统一看，update 命令没有超时，于是就得到了“系统正常”的结论。 也就是说，这时候在业务系统上正常的 SQL 语句已经执行得很慢了，但是 DBA 上去一看，HA 系统还在正常工作，并且认为主库现在处于可用状态。之所以会出现这个现象，根本原因是上面说的所有方法，都是基于外部检测的。外部检测天然有一个问题，就是随","date":"2025-02-23","objectID":"/posts/29.%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E4%B8%8D%E6%98%AF%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"29 | 如何判断一个数据库是不是出问题了？","uri":"/posts/29.%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E4%B8%8D%E6%98%AF%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入探讨了数据库架构中的读写分离问题及解决方案。","date":"2025-02-23","objectID":"/posts/28.%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91/","tags":["MySQL 实战 45 讲","MySQL"],"title":"28 | 读写分离有哪些坑？","uri":"/posts/28.%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入探讨了数据库架构中的读写分离问题及解决方案。首先介绍了两种读写分离架构：客户端直连和带 proxy 的架构，并分析了它们的特点和优劣。随后讨论了由于主从延迟导致的“过期读”问题，并提出了多种处理过期读的方案，包括强制走主库、sleep 方案等。文章提出了更准确的方案，如判断主备无延迟方案、配合 semi-sync 方案等。在确保主备无延迟的方法中，通过对比位点和 GTID 的方法更准确。文章还介绍了 semi-sync replication 和等主库位点方案，以解决过期读问题。 读写分离的主要目标就是分摊主库的压力。上图中的结构是客户端（client）主动做负载均衡，这种模式下一般会把数据库的连接信息放在客户端的连接层。也就是说，由客户端来选择后端数据库进行查询。 还有一种架构是，在 MySQL 和客户端之间有一个中间代理层 proxy，客户端只连接 proxy，由 proxy 根据请求类型和上下文决定请求的分发路由。 接下来就来看一下客户端直连和带 proxy 的读写分离架构，各有哪些特点。 客户端直连方案，因为少了一层 proxy 转发，所以查询性能稍微好一点儿，并且整体架构简单，排查问题更方便。但是这种方案，由于要了解后端部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。你可能会觉得这样客户端也太麻烦了，信息大量冗余，架构很丑。其实也未必，一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如 Zookeeper，尽量让业务端只专注于业务逻辑开发。 带 proxy 的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由 proxy 完成的。但这样的话，对后端维护团队的要求会更高。而且，proxy 也需要有高可用架构。因此，带 proxy 架构的整体就相对比较复杂。 理解了这两种方案的优劣，具体选择哪个方案就取决于数据库团队提供的能力了。但目前看，趋势是往带 proxy 的架构方向发展的。但是，不论使用哪种架构，都会碰到今天要讨论的问题：由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。这种“在从库上会读到系统的一个过期状态”的现象，暂且称之为“过期读”。 主从延迟还是不能 100% 避免的。不论哪种结构，客户端都希望查询从库的数据结果，跟查主库的数据结果是一样的。 1 强制走主库方案 强制走主库方案其实就是，将查询请求做分类。通常情况下，可以将查询请求分为这么两类： 对于必须要拿到最新结果的请求，强制将其发到主库上。比如，在一个交易平台上，卖家发布商品以后，马上要返回主页面，看商品是否发布成功。那么，这个请求需要拿到最新的结果，就必须走主库。 对于可以读到旧数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的。那么，这类请求就可以走从库。 你可能会说，这个方案是不是有点畏难和取巧的意思，但其实这个方案是用得最多的。当然，这个方案最大的问题在于，有时候会碰到“所有查询都不能是过期读”的需求，比如一些金融类的业务。这样的话，就要放弃读写分离，所有读写压力都在主库，等同于放弃了扩展性。 2 Sleep 方案 主库更新后，读从库之前先 sleep 一下。具体的方案就是，类似于执行一条 select sleep(1) 命令。这个方案的假设是，大多数情况下主备延迟在 1 秒之内，做一个 sleep 可以有很大概率拿到最新的数据。 这个方案给你的第一感觉，很可能是不靠谱儿，应该不会有人用吧？并且，你还可能会说，直接在发起查询时先执行一条 sleep 语句，用户体验很不友好啊。但，这个思路确实可以在一定程度上解决问题。为了看起来更靠谱儿，可以换一种方式。 以卖家发布商品为例，商品发布后，用 Ajax 直接把客户端输入的内容作为“新的商品”显示在页面上，而不是真正地去数据库做查询。 这样，卖家就可以通过这个显示，来确认产品已经发布成功了。等到卖家再刷新页面，去查看商品的时候，其实已经过了一段时间，也就达到了 sleep 的目的，进而也就解决了过期读的问题。 也就是说，这个 sleep 方案确实解决了类似场景下的过期读问题。但，从严格意义上来说，这个方案存在的问题就是不精确。这个不精确包含了两层意思： 如果这个查询请求本来 0.5 秒就可以在从库上拿到正确结果，也会等 1 秒； 如果延迟超过 1 秒，还是会出现过期读。 看到这里，你是不是有一种“你是不是在逗我”的感觉，这个改进方案虽然可以解决类似 Ajax 场景下的过期读问题，但还是怎么看都不靠谱儿。 3 判断主备无延迟方案 要确保备库无延迟，通常有三种做法。 第一种确保主备无延迟的方法是，每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0，那就必须等到这个参数变为 0 才能执行查询请求。seconds_behind_master 的单位是秒，如果觉得精度不够的话，还可以采用对比位点和 GTID 的方法来确保主备无延迟。如下图所示，是一个 show slave status 结果的部分截图。 现在，就通过这个结果，来看看具体如何通过对比位点和 GTID 来确保主备无延迟。 第二种方法，对比位点确保主备无延迟： Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点； Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。 如果 Master_Log_File 和 Relay_Master_Log_File、Read_Master_Log_Pos 和 Exec_Master_Log_Pos 这两组值完全相同，就表示接收到的日志已经同步完成。 第三种方法，对比 GTID 集合确保主备无延迟： Auto_Position=1，表示这对主备关系使用了 GTID 协议。 Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合； Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。 如果这两个集合相同，也表示备库接收到的日志都已经同步完成。可见，对比位点和对比 GTID 这两种方法，都要比判断 seconds_behind_master 是否为 0 更准确。 在执行查询请求之前，先判断从库是否同步完成的方法，相比于 sleep 方案，准确度确实提升了不少，但还是没有达到“精确”的程度。为什么这么说呢？现在一起来回顾下，一个事务的 binlog 在主备库之间的状态： 主库执行完成，写入 binlog，并反馈给客户端； binlog 被从主库发送给备库，备库收到； 在备库执行 binlog 完成。 上面判断主备无延迟的逻辑，是“备库收到的日志都执行完成了”。但是，从 binlog 在主备之间状态的分析中，不难看出还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态。如下图所示就是这样的一个状态。 这时，主库上执行完成了三个事务 trx1、trx2 和 trx3，其中： trx1 和 trx2 已经传到从库，并且已经执行完成了； trx3 在主库执行完成，并且已经回复给客户端，但是还没有传到从库中。 如果这时候在从库 B 上执行查询请求，按照上面的逻辑，从库认为已经没有同步延迟，但还是查不到 trx3 的。严格地说，就是出现了过期读。 4 配合 semi-sync 要解决上面的问题，就要引入半同步复制，也就是 semi-sync replication。semi-sync 做了这样的设计： 事务提交的时候，主库把 binlog 发给从库； 从库收到 binlog 以后，发回给主库一个 ack，表示收到了； 主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。 也就是说，如果启用了 semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。 如果主库掉电的时候，有些 binlog 还来不及发给从库，会不会导致系统数据丢失？答案是，如果使用的是普通的异步复制模式，就可能会丢失，但 semi-sync 就可以解决这个问题。 这样，semi-sync 配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过期读。但是，semi-sync+ 位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只要等到一个从库的 ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情况： 如果查询是落在这个响应了 ack 的从库上，是能够确保读到最新数据； 但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。 其实，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者 GTID 集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。 实际上，回到我们最初的业务逻辑里，当发起一个查询请求以后，我们要得到准确的结果，其实并不需要等到“主备完全同步”。为什么这么说呢？来看一下这个时序图。 上图所示，就是等待位点方案的一个 bad case。图中备库 B 下的虚线框，分别表示 relaylog 和 binlog 中的事务。可以看到，上图中从状态 1 到状态 4，一直处于延迟一个事务的状态。 备库 B 一直到状态 4","date":"2025-02-23","objectID":"/posts/28.%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"28 | 读写分离有哪些坑？","uri":"/posts/28.%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"在一主多从架构下，主库出现故障后，从库如何处理是一个关键问题。本文深入探讨了基于位点和 GTID 的主备切换方法，并详细介绍了在切换过程中可能出现的数据同步问题及解决方案。","date":"2025-02-23","objectID":"/posts/27.%E4%B8%BB%E5%BA%93%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86%E4%BB%8E%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/","tags":["MySQL 实战 45 讲","MySQL"],"title":"27 | 主库出问题了，从库怎么办？","uri":"/posts/27.%E4%B8%BB%E5%BA%93%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86%E4%BB%8E%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 在一主多从架构下，主库出现故障后，从库如何处理是一个关键问题。本文深入探讨了基于位点和 GTID 的主备切换方法，并详细介绍了在切换过程中可能出现的数据同步问题及解决方案。GTID（全局事务 ID）作为解决主备切换困难的利器被详细介绍，其生成方式和启动模式都得到了清晰的阐述。文章还通过具体的例子展示了 GTID 的基本用法，以及基于 GTID 的主备切换的实现逻辑。通过 GTID 模式，主备切换不再需要手动找位点，而是在实例内部自动完成，极大地简化了操作流程。 如下图所示，就是一个基本的一主多从结构。 图中，虚线箭头表示的是主备关系，也就是 A 和 A’互为主备，从库 B、C、D 指向的是主库 A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。今天要讨论的就是，在一主多从架构下，主库故障后的主备切换问题。 如下图所示，就是主库发生故障，主备切换后的结果。 相比于一主一备的切换流程，一主多从结构在切换完成后，A’会成为新的主库，从库 B、C、D 也要改接到 A’。正是由于多了从库 B、C、D 重新指向的这个过程，所以主备切换的复杂性也相应增加了。 1 基于位点的主备切换 当把节点 B 设置成节点 A’的从库的时候，需要执行一条 change master 命令： CHANGE MASTER TO MASTER_HOST=$host_name MASTER_PORT=$port MASTER_USER=$user_name MASTER_PASSWORD=$password MASTER_LOG_FILE=$master_log_name MASTER_LOG_POS=$master_log_pos 这条命令有这么 6 个参数： MASTER_HOST、MASTER_PORT、MASTER_USER 和 MASTER_PASSWORD 四个参数，分别代表了主库 A’的 IP、端口、用户名和密码。 最后两个参数 MASTER_LOG_FILE 和 MASTER_LOG_POS 表示，要从主库的 master_log_name 文件的 master_log_pos 这个位置的日志继续同步。而这个位置就是同步位点，也就是主库对应的文件名和日志偏移量。 那么，这里就有一个问题了，节点 B 要设置成 A’的从库，就要执行 change master 命令，就不可避免地要设置位点的这两个参数，但是这两个参数到底应该怎么设置呢？ 原来节点 B 是 A 的从库，本地记录的也是 A 的位点。但是相同的日志，A 的位点和 A’的位点是不同的。因此，从库 B 要切换的时候，就需要先经过“找同步位点”这个逻辑。这个位点很难精确取到，只能取一个大概位置。为什么这么说呢？ 考虑到切换过程中不能丢数据，所以找位点的时候，总是要找一个“稍微往前”的，然后再通过判断跳过那些在从库 B 上已经执行过的事务。一种取同步位点的方法是这样的： 等待新主库 A’把中转日志（relay log）全部同步完成； 在 A’上执行 show master status 命令，得到当前 A’上最新的 File 和 Position； 取原主库 A 故障的时刻 T； 用 mysqlbinlog 工具解析 A’的 File，得到 T 时刻的位点。 mysqlbinlog File --stop-datetime=T --start-datetime=T 图中，end_log_pos 后面的值“123”，表示的就是 A’这个实例，在 T 时刻写入新的 binlog 的位置。然后，就可以把 123 这个值作为 $master_log_pos，用在节点 B 的 change master 命令里。当然这个值并不精确。为什么呢？ 你可以设想有这么一种情况，假设在 T 这个时刻，主库 A 已经执行完成了一个 insert 语句插入了一行数据 R，并且已经将 binlog 传给了 A’和 B，然后在传完的瞬间主库 A 的主机就掉电了。那么，这时候系统的状态是这样的： 在从库 B 上，由于同步了 binlog，R 这一行已经存在； 在新主库 A’上，R 这一行也已经存在，日志是写在 123 这个位置之后的； 我们在从库 B 上执行 change master 命令，指向 A’的 File 文件的 123 位置，就会把插入 R 这一行数据的 binlog 又同步到从库 B 去执行。 这时候，从库 B 的同步线程就会报告 Duplicate entry‘id_of_R’for key‘PRIMARY’错误，提示出现了主键冲突，然后停止同步。 所以，通常情况下，在切换任务的时候，要先主动跳过这些错误，有两种常用的方法。 一种做法是，主动跳过一个事务。跳过命令的写法是： set global sql_slave_skip_counter=1; start slave; 因为切换过程中，可能会不止重复执行一个事务，所以需要在从库 B 刚开始接到新主库 A’时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。 另外一种方式是，通过设置 slave_skip_errors 参数，直接设置跳过指定的错误。在执行主备切换时，有这么两类错误，是经常会遇到的： 1062 错误是插入数据时唯一键冲突； 1032 错误是删除数据时找不到行。 因此，可以把 slave_skip_errors 设置为“1032,1062”，这样中间碰到这两个错误时就直接跳过。这里需要注意的是，这种直接跳过指定错误的方法，针对的是主备切换时，由于找不到精确的同步位点，所以只能采用这种方法来创建从库和新主库的主备关系。 这个背景是，我们很清楚在主备切换过程中，直接跳过 1032 和 1062 这两类错误是无损的，所以才可以这么设置 slave_skip_errors 参数。等到主备间的同步关系建立完成，并稳定执行一段时间之后，还需要把这个参数设置为空，以免之后真的出现了主从数据不一致，也跳过了。 2 GTID 通过 sql_slave_skip_counter 跳过事务和通过 slave_skip_errors 忽略错误的方法，虽然都最终可以建立从库 B 和新主库 A’的主备关系，但这两种操作都很复杂，而且容易出错。所以，MySQL 5.6 版本引入了 GTID，彻底解决了这个困难。那么，GTID 到底是什么意思，又是如何解决找同步位点这个问题呢？ GTID 的全称是 Global Transaction Identifier，也就是全局事务 ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是： GTID=server_uuid:gno 其中： server_uuid 是一个实例第一次启动时自动生成的，是一个全局唯一的值； gno 是一个整数，初始值是 1，每次提交事务的时候分配给这个事务，并加 1。 在 MySQL 的官方文档里，GTID 格式是这么定义的： GTID=source_id:transaction_id 这里的 source_id 就是 server_uuid；而后面的这个 transaction_id，容易造成误导，所以改成了 gno。为什么说使用 transaction_id 容易造成误解呢？ 因为，在 MySQL 里面我们说 transaction_id 就是指事务 id，事务 id 是在事务执行过程中分配的，如果这个事务回滚了，事务 id 也会递增，而 gno 是在事务提交的时候才会分配。从效果上看，GTID 往往是连续的，因此用 gno 来表示更容易理解。 GTID 模式的启动也很简单，只需要在启动一个 MySQL 实例的时候，加上参数 gtid_mode=on 和 enforce_gtid_consistency=on 就可以了。 在 GTID 模式下，每个事务都会跟一个 GTID 一一对应。这个 GTID 有两种生成方式，而使用哪种方式取决于 session 变量 gtid_next 的值。 如果 gtid_next=automatic，代表使用默认值。这时，MySQL 就会把 server_uuid:gno 分配给这个事务。 记录 binlog 的时候，先记录一行 SET @@SESSION.GTID_NEXT=‘server_uuid:gno’; 把这个 GTID 加入本实例的 GTID 集合。 如果 gtid_next 是一个指定的 GTID 的值，比如通过 set gtid_next=‘current_gtid’指定为 current_gtid，那么就有两种可能： 如果 current_gtid 已经存在于实例的 GTID 集合中，接下来执行的这个事务会直接被系统忽略； 如果 current_gtid 没有存在于实例的 GTID 集合中，就将这个 current_gtid 分配给接下来要执行的事务，也就是说系统不需要给这个事务生成新的 GTID，因此 gno 也不用加 1。 注意，一个 current_gtid 只能给一个事务使用。这个事务提交后，如果要执行下一个事务，就要执行 set 命令，把 gtid_next 设置成另外一个 gtid 或者 automatic。这样，每个 MySQL 实例都维护了一个 GTID 集合，用来对应“这个实例执行过的所有事务”。这样看上去不太容易理解，接下来用一个简单的例子，来说明 GTID 的基本用法。在实例 X 中创建一个表 t。 CREATE TABLE","date":"2025-02-23","objectID":"/posts/27.%E4%B8%BB%E5%BA%93%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86%E4%BB%8E%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"27 | 主库出问题了，从库怎么办？","uri":"/posts/27.%E4%B8%BB%E5%BA%93%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86%E4%BB%8E%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"MySQL 的并行复制策略是解决备库延迟问题的关键","date":"2025-02-23","objectID":"/posts/26.%E5%A4%87%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BB%B6%E8%BF%9F%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%97%B6/","tags":["MySQL 实战 45 讲","MySQL"],"title":"26 | 备库为什么会延迟好几个小时？","uri":"/posts/26.%E5%A4%87%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BB%B6%E8%BF%9F%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%97%B6/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 MySQL 的并行复制策略是解决备库延迟问题的关键。在 MySQL 5.5 版本中，通过按表和按行分发策略实现多线程复制，但存在一些限制。随着版本的演进，MySQL 5.6 和 5.7 版本新增了按库并行和基于 WRITESET 的并行复制策略，提高了备库的同步速度。这些策略的实现原理和优缺点都得到了详细介绍，包括对大事务的影响和参数调整的建议。此外，文章还提到了 MariaDB 的并行复制策略，以及备库主备延迟表现为 45 度线段的原因。 不论是偶发性的查询压力，还是备份，对备库延迟的影响一般是分钟级的，而且在备库恢复正常以后都能够追上来。 但是，如果备库执行日志的速度持续低于主库生成日志的速度，那这个延迟就有可能成了小时级别。而且对于一个压力持续比较高的主库来说，备库很可能永远都追不上主库的节奏。这就涉及到今天要学习的话题：备库并行复制能力。 谈到主备的并行复制能力，要关注的是上图中黑色的两个箭头。一个箭头代表了客户端写入主库，另一箭头代表的是备库上 sql_thread 执行中转日志（relay log）。如果用箭头的粗细来代表并行度的话，那么真实情况就如上图所示，第一个箭头要明显粗于第二个箭头。 在主库上，影响并发度的原因就是各种锁了。由于 InnoDB 引擎支持行锁，除了所有并发事务都在更新同一行（热点行）这种极端场景外，它对业务并发度的支持还是很友好的。所以，在性能测试的时候会发现，并发压测线程 32 就比单线程时，总体吞吐量高。 而日志在备库上的执行，就是图中备库上 sql_thread 更新数据 (DATA) 的逻辑。如果是用单线程的话，就会导致备库应用日志不够快，造成主备延迟。 在官方的 5.6 版本之前，MySQL 只支持单线程复制，由此在主库并发高、TPS 高时就会出现严重的主备延迟问题。从单线程复制到最新版本的多线程复制，中间的演化经历了好几个版本。 其实说到底，所有的多线程复制机制，都是要把上图中只有一个线程的 sql_thread，拆成多个线程，也就是都符合下面的这个模型： 上图中，coordinator 就是原来的 sql_thread, 不过现在它不再直接更新数据了，只负责读取中转日志和分发事务。真正更新日志的，变成了 worker 线程。而 work 线程的个数，就是由参数 slave_parallel_workers 决定的。根据经验，把这个值设置为 8~16 之间最好（32 核物理机的情况），毕竟备库还有可能要提供读查询，不能把 CPU 都吃光了。 接下来，需要先思考一个问题：事务能不能按照轮询的方式分发给各个 worker，也就是第一个事务分给 worker_1，第二个事务发给 worker_2 呢？ 其实是不行的。因为，事务被分发给 worker 以后，不同的 worker 就独立执行了。但是，由于 CPU 的调度策略，很可能第二个事务最终比第一个事务先执行。而如果这时候刚好这两个事务更新的是同一行，也就意味着，同一行上的两个事务，在主库和备库上的执行顺序相反，会导致主备不一致的问题。 接下来，请再设想一下另外一个问题：同一个事务的多个更新语句，能不能分给不同的 worker 来执行呢？ 答案是，也不行。举个例子，一个事务更新了表 t1 和表 t2 中的各一行，如果这两条更新语句被分到不同 worker 的话，虽然最终的结果是主备一致的，但如果表 t1 执行完成的瞬间，备库上有一个查询，就会看到这个事务“更新了一半的结果”，破坏了事务逻辑的隔离性。 所以，coordinator 在分发的时候，需要满足以下这两个基本要求： 不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个 worker 中。 同一个事务不能被拆开，必须放到同一个 worker 中。 1 MySQL 5.5 版本的并行复制策略 官方 MySQL 5.5 版本是不支持并行复制的。但是可以自定义实现并行策略，比如说可以实现按表分发策略和按行分发策略。 1.1 按表分发策略 按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个 worker 不会更新同一行。 当然，如果有跨表的事务，还是要把两张表放在一起考虑的。如下图所示，就是按表分发的规则。 可以看到，每个 worker 线程对应一个 hash 表，用于保存当前正在这个 worker 的“执行队列”里的事务所涉及的表。hash 表的 key 是“库名。表名”，value 是一个数字，表示队列中有多少个事务修改这个表。 在有事务分配给 worker 时，事务里面涉及的表会被加到对应的 hash 表中。worker 执行完成后，这个表会被从 hash 表中去掉。 上图中，hash_table_1 表示，现在 worker_1 的“待执行事务队列”里，有 4 个事务涉及到 db1.t1 表，有 1 个事务涉及到 db2.t2 表；hash_table_2 表示，现在 worker_2 中有一个事务会更新到表 t3 的数据。 假设在图中的情况下，coordinator 从中转日志中读入一个新事务 T，这个事务修改的行涉及到表 t1 和 t3。现在用事务 T 的分配流程，来看一下分配规则。 由于事务 T 中涉及修改表 t1，而 worker_1 队列中有事务在修改表 t1，事务 T 和队列中的某个事务要修改同一个表的数据，这种情况我们说事务 T 和 worker_1 是冲突的。 按照这个逻辑，顺序判断事务 T 和每个 worker 队列的冲突关系，会发现事务 T 跟 worker_2 也冲突。 事务 T 跟多于一个 worker 冲突，coordinator 线程就进入等待。 每个 worker 继续执行，同时修改 hash_table。假设 hash_table_2 里面涉及到修改表 t3 的事务先执行完成，就会从 hash_table_2 中把 db1.t3 这一项去掉。 这样 coordinator 会发现跟事务 T 冲突的 worker 只有 worker_1 了，因此就把它分配给 worker_1。 coordinator 继续读下一个中转日志，继续分配事务。 也就是说，每个事务在分发的时候，跟所有 worker 的冲突关系包括以下三种情况： 如果跟所有 worker 都不冲突，coordinator 线程就会把这个事务分配给最空闲的 woker; 如果跟多于一个 worker 冲突，coordinator 线程就进入等待状态，直到和这个事务存在冲突关系的 worker 只剩下 1 个； 如果只跟一个 worker 冲突，coordinator 线程就会把这个事务分配给这个存在冲突关系的 worker。 这个按表分发的方案，在多个表负载均匀的场景里应用效果很好。但是，如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个 worker 中，就变成单线程复制了。 1.2 按行分发策略 要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求 binlog 格式必须是 row。 这时候，判断一个事务 T 和 worker 是否冲突，用的就规则就不是“修改同一个表”，而是“修改同一行”。 按行复制和按表复制的数据结构差不多，也是为每个 worker，分配一个 hash 表。只是要实现按行分发，这时候的 key，就必须是“库名 + 表名 + 唯一键的值”。 但是，这个“唯一键”只有主键 id 还是不够的，还需要考虑下面这种场景，表 t1 中除了主键，还有唯一索引 a： CREATE TABLE `t1` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `a` (`a`) ) ENGINE=InnoDB; insert into t1 values(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5); 假设，接下来要在主库执行这两个事务： 可以看到，这两个事务要更新的行的主键值不同，但是如果它们被分到不同的 worker，就有可能 session B 的语句先执行。这时候 id=1 的行的 a 的值还是 1，就会报唯一键冲突。 因此，基于行的策略，事务 hash 表中还需要考虑唯一键，即 key 应该是“库名 + 表名 + 索引 a 的名字 +a 的值”。 比如，在上面这个例子中，要在表 t1 上执行 update t1 set a=1 where id=2 语句，在 binlog 里面记录了整行的数据修改前各个字段的值，和修改后各个字段的值。因此，coordinator 在解析这个语句的 binlog 的时候，这个事务的 hash 表就有三个项： key=hash_func(db1+t1+“PRIMARY”+2), value=2; 这里 value=2 是因为修改前后的行 id 值不变，出现了两次。 key=hash_func(db1+t1+“a”+2), value=1，表示会影响到这个表 a=2 的行。 key=hash_func(db1+t1+“a”+1), value=1，表示会影响到这个表 a=1 的行。 可见，相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计","date":"2025-02-23","objectID":"/posts/26.%E5%A4%87%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BB%B6%E8%BF%9F%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%97%B6/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"26 | 备库为什么会延迟好几个小时？","uri":"/posts/26.%E5%A4%87%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BB%B6%E8%BF%9F%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%97%B6/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入探讨了 MySQL 高可用性保障的技术细节和应对策略。","date":"2025-02-16","objectID":"/posts/25.mysql%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84/","tags":["MySQL 实战 45 讲","MySQL"],"title":"25 | MySQL 是怎么保证高可用的？","uri":"/posts/25.mysql%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入探讨了 MySQL 高可用性保障的技术细节和应对策略。主要围绕主备库之间的数据同步和切换展开讨论，重点介绍了主备延迟的概念及可能的来源，包括备库性能差、备库压力大、大事务和备库的并行复制能力。针对主备切换过程中的不可用时间，文章提出了可靠性优先策略，并详细描述了切换流程。 正常情况下，只要主库执行更新生成的所有 binlog，都可以传到备库并被正确地执行，备库就能达到跟主库一致的状态，这就是最终一致性。但是，MySQL 要提供高可用能力，只有最终一致性是不够的。这里，再放一次上一篇文章中讲到的双 M 结构的主备切换流程图。 1 主备延迟 主备切换可能是一个主动运维动作，比如软件升级、主库所在机器按计划下线等，也可能是被动操作，比如主库所在机器掉电。接下来，先一起看看主动切换的场景。 在介绍主动切换流程的详细步骤之前，先跟你说明一个概念，即“同步延迟”。与数据同步有关的时间点主要包括以下三个： 主库 A 执行完成一个事务，写入 binlog，把这个时刻记为 T1; 之后传给备库 B，把备库 B 接收完这个 binlog 的时刻记为 T2; 备库 B 执行完成这个事务，把这个时刻记为 T3。 所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是 T3-T1。 你可以在备库上执行 show slave status 命令，它的返回结果里面会显示 seconds_behind_master，用于表示当前备库延迟了多少秒。seconds_behind_master 的计算方法是这样的： 每个事务的 binlog 里面都有一个时间字段，用于记录主库上写入的时间； 备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到 seconds_behind_master。 可以看到，其实 seconds_behind_master 这个参数计算的就是 T3-T1。所以，可以用 seconds_behind_master 来作为主备延迟的值，这个值的时间精度是秒。如果主备库机器的系统时间设置不一致，会不会导致主备延迟的值不准？ 其实不会的。因为，备库连接到主库的时候，会通过执行 SELECT UNIX_TIMESTAMP() 函数来获得当前主库的系统时间。如果这时候发现主库的系统时间与自己不一致，备库在执行 seconds_behind_master 计算的时候会自动扣掉这个差值。 需要说明的是，在网络正常的时候，日志从主库传给备库所需的时间是很短的，即 T2-T1 的值是非常小的。也就是说，网络正常情况下，主备延迟的主要来源是备库接收完 binlog 和执行完这个事务之间的时间差。 所以说，主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产 binlog 的速度要慢。接下来就一起分析下，这可能是由哪些原因导致的。 2 主备延迟的来源 首先，有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。 一般情况下，有人这么部署时的想法是，反正备库没有请求，所以可以用差一点儿的机器。或者，他们会把 20 个主库放在 4 台机器上，而把备库集中在一台机器上。 其实我们都知道，更新请求对 IOPS 的压力，在主库和备库上是无差别的。所以，做这种部署时，一般都会将备库设置为“非双 1”的模式。 但实际上，更新过程中也会触发大量的读操作。所以，当备库主机上的多个备库都在争抢资源的时候，就可能会导致主备延迟了。 当然，这种部署现在比较少了。因为主备可能发生切换，备库随时可能变成主库，所以主备库选用相同规格的机器，并且做对称部署，是现在比较常见的情况。 追问 1：但是，做了对称部署以后，还可能会有延迟。这是为什么呢？ 这就是第二种常见的可能了，即备库的压力大。一般的想法是，主库既然提供了写能力，那么备库可以提供一些读能力。或者一些运营后台需要的分析语句，不能影响正常业务，所以只能在备库上跑。由于主库直接影响业务，大家使用起来会比较克制，反而忽视了备库的压力控制。结果就是，备库上的查询耗费了大量的 CPU 资源，影响了同步速度，造成主备延迟。这种情况，一般可以这么处理： 一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力。 通过 binlog 输出到外部系统，比如 Hadoop 这类系统，让外部系统提供统计类查询的能力。 其中，一主多从的方式大都会被采用。因为作为数据库系统，还必须保证有定期全量备份的能力。而从库，就很适合用来做备份。 从库和备库在概念上其实差不多。为了方便描述，把会在 HA 过程中被选成新主库的，称为备库，其他的称为从库。 追问 2：采用了一主多从，保证备库的压力不会超过主库，还有什么情况可能导致主备延迟吗？ 这就是第三种可能了，即大事务。 大事务这种情况很好理解。因为主库上必须等事务执行完成才会写入 binlog，再传给备库。所以，如果一个主库上的语句执行 10 分钟，那这个事务很可能就会导致从库延迟 10 分钟。 你可能听说过：不要一次性地用 delete 语句删除太多数据。其实，这就是一个典型的大事务场景。 比如，一些归档类的数据，平时没有注意删除历史数据，等到空间快满了，业务开发人员要一次性地删掉大量历史数据。同时，又因为要避免在高峰期操作会影响业务（至少有这个意识还是很不错的），所以会在晚上执行这些大量数据的删除操作。 结果，负责的 DBA 同学半夜就会收到延迟报警。然后，DBA 团队就要求你后续再删除数据的时候，要控制每个事务删除的数据量，分成多次删除。 另一种典型的大事务场景，就是大表 DDL。这个场景的处理方案就是，计划内的 DDL，建议使用 gh-ost 方案。 追问 3：如果主库上也不做大事务了，还有什么原因会导致主备延迟吗？ 造成主备延迟还有一个大方向的原因，就是备库的并行复制能力。 由于主备延迟的存在，所以在主备切换的时候，就相应的有不同的策略。 3 可靠性优先策略 在上图的双 M 结构下，从状态 1 到状态 2 切换的详细过程是这样的： 判断备库 B 现在的 seconds_behind_master，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步； 把主库 A 改成只读状态，即把 readonly 设置为 true； 判断备库 B 的 seconds_behind_master 的值，直到这个值变成 0 为止； 把备库 B 改成可读写状态，也就是把 readonly 设置为 false； 把业务请求切到备库 B。 这个切换流程，一般是由专门的 HA 系统来完成的，暂时称之为可靠性优先流程。 备注：图中的 SBM，是 seconds_behind_master 参数的简写。 可以看到，这个切换流程中是有不可用时间的。因为在步骤 2 之后，主库 A 和备库 B 都处于 readonly 状态，也就是说这时系统处于不可写状态，直到步骤 5 完成后才能恢复。 在这个不可用状态中，比较耗费时间的是步骤 3，可能需要耗费好几秒的时间。这也是为什么需要在步骤 1 先做判断，确保 seconds_behind_master 的值足够小。 试想如果一开始主备延迟就长达 30 分钟，而不先做判断直接切换的话，系统的不可用时间就会长达 30 分钟，这种情况一般业务都是不可接受的。 当然，系统的不可用时间，是由这个数据可靠性优先的策略决定的。也可以选择可用性优先的策略，来把这个不可用时间几乎降为 0。 4 可用性优先策略 如果强行把步骤 4、5 调整到最开始执行，也就是说不等主备数据同步，直接把连接切到备库 B，并且让备库 B 可以读写，那么系统几乎就没有不可用时间了。把这个切换流程，暂时称作可用性优先流程。这个切换流程的代价，就是可能出现数据不一致的情况。接下来，就来分享一个可用性优先流程产生数据不一致的例子。假设有一个表 t： mysql\u003e CREATE TABLE `t` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `c` int(11) unsigned DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB; insert into t(c) values(1),(2),(3); 这个表定义了一个自增主键 id，初始化数据后，主库和备库上都是 3 行数据。接下来，业务人员要继续在表 t 上执行两条插入语句的命令，依次是： insert into t(c) values(4); insert into t(c) values(5); 假设，现在主库上其他的数据表有大量的更新，导致主备延迟达到 5 秒。在插入一条 c=4 的语句后，发起了主备切换。 下图是可用性优先策略，且 binlog_format=mixed 时的切换流程和数据结果。 现在，一起分析下这个切换流程： 步骤 2 中，主库 A 执行完 insert 语句，插入了一行数据（4,4），之后开始进行主备切换。 步骤 3 中，由于主备之间有 5 秒的延迟，所以备库 B 还没来得及应用“插入 c=4”这个中转日志，就开始接收客户端“插入 c=5”的命令。 步骤 4 中，备库 B 插入了一行数据（4,5），并且把这个 binlog 发给主库 A。 步骤 5 中，备库 B 执行“插入 c=4”这个中转日志，插入了一行数据（5,4）。而直接在备库 B 执行的“插入 c=5”这个语句，传到主库 A，就插入了一行新数据（5,5）。 最后的结果就是，主库 A 和备库 B 上出现了两行不一致的数","date":"2025-02-16","objectID":"/posts/25.mysql%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"25 | MySQL 是怎么保证高可用的？","uri":"/posts/25.mysql%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入介绍了 MySQL 主备同步的基本原理和技术细节，重点围绕 binlog 内容、备库执行 binlog 与主库保持一致的原理展开。","date":"2025-02-16","objectID":"/posts/24.mysql%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84/","tags":["MySQL 实战 45 讲","MySQL"],"title":"24 | MySQL 是怎么保证主备一致的？","uri":"/posts/24.mysql%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入介绍了 MySQL 主备同步的基本原理和技术细节，重点围绕 binlog 内容、备库执行 binlog 与主库保持一致的原理展开。详细解释了主备切换流程、节点间的同步更新流程以及 binlog 的三种格式的特点和应用场景。 1 MySQL 主备的基本原理 如下图所示就是基本的主备切换流程。 在状态 1 中，客户端的读写都直接访问节点 A，而节点 B 是 A 的备库，只是将 A 的更新都同步过来，到本地执行。这样可以保持节点 B 和 A 的数据是相同的。 当需要切换的时候，就切成状态 2。这时候客户端读写访问的都是节点 B，而节点 A 是 B 的备库。 在状态 1 中，虽然节点 B 没有被直接访问，但是依然建议你把节点 B（也就是备库）设置成只读（readonly）模式。这样做，有以下几个考虑： 有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作； 防止切换逻辑有 bug，比如切换过程中出现双写，造成主备不一致； 可以用 readonly 状态，来判断节点的角色。 把备库设置成只读了，还怎么跟主库保持同步更新呢？这个问题不用担心。因为 readonly 设置对超级 (super) 权限用户是无效的，而用于同步更新的线程，就拥有超级权限。 接下来，再看看节点 A 到 B 这条线的内部流程是什么样的。下图中画出的就是一个 update 语句在节点 A 执行，然后同步到节点 B 的完整流程图。 上图中，包含了上一篇文章中讲到的 binlog 和 redo log 的写入机制相关的内容，可以看到：主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写 binlog。 备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。一个事务日志同步的完整过程是这样的： 在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。 在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。 主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。 备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。 sql_thread 读取中转日志，解析出日志里的命令，并执行。 这里需要说明，后来由于多线程复制方案的引入，sql_thread 演化成为了多个线程。 2 binlog 的三种格式对比 binlog 有三种格式，一种是 statement，一种是 row，第三种格式，叫作 mixed，其实它就是前两种格式的混合。为了便于描述 binlog 的这三种格式间的区别，创建了一个表，并初始化几行数据。 mysql\u003e CREATE TABLE `t` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`), KEY `a` (`a`), KEY `t_modified`(`t_modified`) ) ENGINE=InnoDB; insert into t values(1,1,'2018-11-13'); insert into t values(2,2,'2018-11-12'); insert into t values(3,3,'2018-11-11'); insert into t values(4,4,'2018-11-10'); insert into t values(5,5,'2018-11-09'); 如果要在表中删除一行数据的话，来看看这个 delete 语句的 binlog 是怎么记录的。注意，下面这个语句包含注释，如果用 MySQL 客户端来做这个实验的话，要记得加 -c 参数，否则客户端会自动去掉注释。 mysql\u003e delete from t /*comment*/ where a\u003e=4 and t_modified\u003c='2018-11-10' limit 1; 当 binlog_format=statement 时，binlog 里面记录的就是 SQL 语句的原文。可以用 mysql\u003e show binlog events in 'master.000001'; 命令看 binlog 中的内容。 现在，来看一下上图的输出结果。 第一行 SET @@SESSION.GTID_NEXT=‘ANONYMOUS’可以先忽略； 第二行是一个 BEGIN，跟第四行的 commit 对应，表示中间是一个事务； 第三行就是真实执行的语句了。可以看到，在真实执行的 delete 命令之前，还有一个“use‘test’”命令。这条命令不是主动执行的，而是 MySQL 根据当前要操作的表所在的数据库，自行添加的。这样做可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库里，都能够正确地更新到 test 库的表 t。use ’test’命令之后的 delete 语句，就是输入的 SQL 原文了。可以看到，binlog“忠实”地记录了 SQL 命令，甚至连注释也一并记录了。 最后一行是一个 COMMIT。你可以看到里面写着 xid=61。 为了说明 statement 和 row 格式的区别，再来看一下这条 delete 命令的执行效果图： 可以看到，运行这条 delete 命令产生了一个 warning，原因是当前 binlog 设置的是 statement 格式，并且语句中有 limit，所以这个命令可能是 unsafe 的。 为什么这么说呢？这是因为 delete 带 limit，很可能会出现主备数据不一致的情况。比如上面这个例子： 如果 delete 语句使用的是索引 a，那么会根据索引 a 找到第一个满足条件的行，也就是说删除的是 a=4 这一行； 但如果使用的是索引 t_modified，那么删除的就是 t_modified=‘2018-11-09’也就是 a=5 这一行。 由于 statement 格式下，记录到 binlog 里的是语句原文，因此可能会出现这样一种情况：在主库执行这条 SQL 语句的时候，用的是索引 a；而在备库执行这条 SQL 语句的时候，却使用了索引 t_modified。因此，MySQL 认为这样写是有风险的。 那么，如果把 binlog 的格式改为 binlog_format=‘row’，是不是就没有这个问题了呢？再来看看这时候 binog 中的内容吧。 可以看到，与 statement 格式的 binlog 相比，前后的 BEGIN 和 COMMIT 是一样的。但是，row 格式的 binlog 里没有了 SQL 语句的原文，而是替换成了两个 event：Table_map 和 Delete_rows。 Table_map event，用于说明接下来要操作的表是 test 库的表 t; Delete_rows event，用于定义删除的行为。 其实，我们通过上图是看不到详细信息的，还需要借助 mysqlbinlog 工具，用下面这个命令解析和查看 binlog 中的内容。因为上图中的信息显示，这个事务的 binlog 是从 8900 这个位置开始的，所以可以用 start-position 参数来指定从这个位置的日志开始解析。 mysqlbinlog -vv data/master.000001 --start-position=8900; 从这个图中，可以看到以下几个信息： server id 1，表示这个事务是在 server_id=1 的这个库上执行的。 每个 event 都有 CRC32 的值，这是因为把参数 binlog_checksum 设置成了 CRC32。 Table_map event 跟在上图中看到的相同，显示了接下来要打开的表，map 到数字 226。现在这条 SQL 语句只操作了一张表，如果要操作多张表呢？每个表都有一个对应的 Table_map event、都会 map 到一个单独的数字，用于区分对不同表的操作。 在 mysqlbinlog 的命令中，使用了 -vv 参数是为了把内容都解析出来，所以从结果里面可以看到各个字段的值（比如，@1=4、 @2=4 这些值）。 binlog_row_image 的默认配置是 FULL，因此 Delete_event 里面，包含了删掉的行的所有字段的值。如果把 binlog_row_image 设置为 MINIMAL，则只会记录必要的信息，在这个例子里，就是只会记录 id=4 这个信息。 最后的 Xid event，用于表示事务被正确地提交了。 可以看到，当 binlog_format 使用 row 格式的时候，binlog 里面记录了真实删除行的主键 id，这样 binlog 传到备库去的时候，就肯定会删除 id=4 的行，不会有主备删除不同行的问题。 3 为什么会有 mixed 格式的 binlog？ 为什么会有 mixed 这种 binlog 格式的存在场景？推论过程是这样的： 因为有些 statement 格式的 binlog 可能会导致主备不一致，所以要使用 ","date":"2025-02-16","objectID":"/posts/24.mysql%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"24 | MySQL 是怎么保证主备一致的？","uri":"/posts/24.mysql%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入介绍了 MySQL 数据保证机制的技术特点，主要围绕 binlog 的写入流程和相关参数的设置展开。","date":"2025-02-16","objectID":"/posts/23.mysql%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84/","tags":["MySQL 实战 45 讲","MySQL"],"title":"23 | MySQL 是怎么保证数据不丢的？","uri":"/posts/23.mysql%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 MySQL 数据保证机制的技术特点主要围绕 binlog 的写入流程和相关参数的设置展开。在 binlog 的写入机制中，事务执行过程中先将日志写入 binlog cache，事务提交时再将 binlog cache 写入 binlog 文件中。每个线程有自己的 binlog cache，但共用同一份 binlog 文件。 1 binlog 的写入机制 binlog 的写入逻辑比较简单：事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。 一个事务的 binlog 是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到了 binlog cache 的保存问题。 系统给 binlog cache 分配了一片内存，每个线程一个，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。 事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache。状态下图所示。 可以看到，每个线程有自己 binlog cache，但是共用同一份 binlog 文件。 图中的 write，指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快。 图中的 fsync，才是将数据持久化到磁盘的操作。一般情况下，认为 fsync 才占磁盘的 IOPS。 write 和 fsync 的时机，是由参数 sync_binlog 控制的： sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync； sync_binlog=1 的时候，表示每次提交事务都会执行 fsync； sync_binlog=N(N\u003e1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。 因此，在出现 IO 瓶颈的场景里，将 sync_binlog 设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成 0，比较常见的是将其设置为 100~1000 中的某个数值。 但是，将 sync_binlog 设置为 N，对应的风险是：如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。 2 redo log 的写入机制 事务在执行过程中，生成的 redo log 是要先写到 redo log buffer 的。redo log buffer 里面的内容，是不是每次生成后都要直接持久化到磁盘呢？答案是，不需要。 如果事务执行期间 MySQL 发生异常重启，那这部分日志就丢了。由于事务并没有提交，所以这时日志丢了也不会有损失。 那么，另外一个问题是，事务还没提交的时候，redo log buffer 中的部分日志有没有可能被持久化到磁盘呢？答案是，确实会有。 这个问题，要从 redo log 可能存在的三种状态说起。这三种状态，对应的就是下图中的三个颜色块。 这三种状态分别是： 存在 redo log buffer 中，物理上是在 MySQL 进程内存中，就是图中的红色部分； 写到磁盘 (write)，但是没有持久化（fsync)，物理上是在文件系统的 page cache 里面，也就是图中的黄色部分； 持久化到磁盘，对应的是 hard disk，也就是图中的绿色部分。 日志写到 redo log buffer 是很快的，wirte 到 page cache 也差不多，但是持久化到磁盘的速度就慢多了。 为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，它有三种可能取值： 设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ; 设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘； 设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。 InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。 注意，事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些 redo log 也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的 redo log，也是可能已经持久化到磁盘的。 实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的 redo log 写入到磁盘中。 一种是，redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。 另一种是，并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。假设一个事务 A 执行到一半，已经写了一些 redo log 到 buffer 中，这时候有另外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是 1，那么按照这个参数的逻辑，事务 B 要把 redo log buffer 里的日志全部持久化到磁盘。这时候，就会带上事务 A 在 redo log buffer 里的日志一起持久化到磁盘。 这里需要说明的是，介绍两阶段提交的时候说过，时序上 redo log 先 prepare，再写 binlog，最后再把 redo log commit。 如果把 innodb_flush_log_at_trx_commit 设置成 1，那么 redo log 在 prepare 阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖于 prepare 的 redo log，再加上 binlog 来恢复的。 每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB 就认为 redo log 在 commit 的时候就不需要 fsync 了，只会 write 到文件系统的 page cache 中就够了。 通常我们说 MySQL 的“双 1”配置，指的就是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。 这时候，你可能有一个疑问，这意味着从 MySQL 看到的 TPS 是每秒两万的话，每秒就会写四万次磁盘。但是，用工具测试出来，磁盘能力也就两万左右，怎么能实现两万的 TPS？解释这个问题，就要用到组提交（group commit）机制了。 这里，需要先介绍日志逻辑序列号（log sequence number，LSN）的概念。LSN 是单调递增的，用来对应 redo log 的一个个写入点。每次写入长度为 length 的 redo log，LSN 的值就会加上 length。LSN 也会写到 InnoDB 的数据页中，来确保数据页不会被多次执行重复的 redo log。 如下图所示，是三个并发事务 (trx1, trx2, trx3) 在 prepare 阶段，都写完 redo log buffer，持久化到磁盘的过程，对应的 LSN 分别是 50、120 和 160。 从图中可以看到， trx1 是第一个到达的，会被选为这组的 leader； 等 trx1 要开始写盘的时候，这个组里面已经有了三个事务，这时候 LSN 也变成了 160； trx1 去写盘的时候，带的就是 LSN=160，因此等 trx1 返回时，所有 LSN 小于等于 160 的 redo log，都已经被持久化到磁盘； 这时候 trx2 和 trx3 就可以直接返回了。 所以，一次组提交里面，组员越多，节约磁盘 IOPS 的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。 在并发更新场景下，第一个事务写完 redo log buffer 以后，接下来这个 fsync 越晚调用，组员可能越多，节约 IOPS 的效果就越好。为了让一次 fsync 带的组员更多，MySQL 有一个很有趣的优化：拖时间。 图中，把“写 binlog”当成一个动作。但实际上，写 binlog 是分成两步的： 先把 binlog 从 binlog cache 中写到磁盘上的 binlog 文件； 调用 fsync 持久化。 MySQL 为了让组提交的效果更好，把 redo log 做 fsync 的时间拖到了步骤 1 之后。也就是说，上面的图变成了这样： 这么一来，binlog 也可以组提交了。在执行上图中第 4 步把 binlog fsync 到磁盘时，如果有多个事务的 binlog 已经写完了，也是一起持久化的，这样也可以减少 IOPS 的消耗。 不过通常情况下第 3 步执行得会很快，所以 binlog 的 write 和 fsync 间的间隔时间短，导致能集合到一起持久化的 binlog 比较少，因此 binlog 的组提交的效果通常不如 redo log 的","date":"2025-02-16","objectID":"/posts/23.mysql%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"23 | MySQL 是怎么保证数据不丢的？","uri":"/posts/23.mysql%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入探讨了 MySQL 性能问题的解决方案，针对短连接风暴和查询更新语句导致的性能问题提出了解决方法。","date":"2025-02-16","objectID":"/posts/22.mysql%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/","tags":["MySQL 实战 45 讲","MySQL"],"title":"22 | MySQL 有哪些“饮鸩止渴”提高性能的方法？","uri":"/posts/22.mysql%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入探讨了 MySQL 性能问题的解决方案，针对短连接风暴和查询更新语句导致的性能问题提出了解决方法。对于短连接风暴可能导致的连接数暴涨问题，提出了通过 kill connection 命令断开不工作的线程或者重启数据库并使用–skip-grant-tables 参数跳过权限验证阶段的方法，但强调了这些方法可能存在的风险和损失。针对查询和更新语句导致的性能问题，文章提出了通过创建索引、改写 SQL 语句以及使用 force index 等方法来解决。 在实际运维过程中可能会碰到这样的情景：业务高峰期，生产环境的 MySQL 压力太大，没法正常响应，需要短期内、临时性地提升一些性能。 但，如果是无损方案的话，肯定不需要等到这个时候才上场。今天就来聊聊这些临时方案，并着重说一说它们可能存在的风险。 1 短连接风暴 正常的短连接模式就是连接到数据库后，执行很少的 SQL 语句就断开，下次需要的时候再重连。如果使用的是短连接，在业务高峰期的时候，就可能出现连接数突然暴涨的情况。 MySQL 建立连接的过程，成本是很高的。除了正常的网络连接三次握手外，还需要做登录权限判断和获得这个连接的数据读写权限。在数据库压力比较小的时候，这些额外的成本并不明显。 但是，短连接模型存在一个风险，就是一旦数据库处理得慢一些，连接数就会暴涨。max_connections 参数，用来控制一个 MySQL 实例同时存在的连接数的上限，超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。对于被拒绝连接的请求来说，从业务角度看就是数据库不可用。 在机器负载比较高的时候，处理现有请求的时间变长，每个连接保持的时间也更长。这时，再有新建连接的话，就可能会超过 max_connections 的限制。 碰到这种情况时，一个比较自然的想法，就是调高 max_connections 的值。但这样做是有风险的。因为设计 max_connections 这个参数的目的是想保护 MySQL，如果把它改得太大，让更多的连接都可以进来，那么系统的负载可能会进一步加大，大量的资源耗费在权限验证等逻辑上，结果可能是适得其反，已经连接的线程拿不到 CPU 资源去执行业务的 SQL 请求。 那么这种情况下还有没有别的建议呢？这里还有两种方法，但要注意，这些方法都是有损的。 第一种方法：先处理掉那些占着连接但是不工作的线程。 max_connections 的计算，不是看谁在 running，是只要连着就占用一个计数位置。对于那些不需要保持的连接，可以通过 kill connection 主动踢掉。这个行为跟事先设置 wait_timeout 的效果是一样的。设置 wait_timeout 参数表示的是，一个线程空闲 wait_timeout 这么多秒之后，就会被 MySQL 直接断开连接。 但是需要注意，在 show processlist 的结果里，踢掉显示为 sleep 的线程，可能是有损的。来看下面这个例子。 在上面这个例子里，如果断开 session A 的连接，因为这时候 session A 还没有提交，所以 MySQL 只能按照回滚事务来处理；而断开 session B 的连接，就没什么大影响。所以，如果按照优先级来说，应该优先断开像 session B 这样的事务外空闲的连接。 但是，怎么判断哪些是事务外空闲的呢？session C 在 T 时刻之后的 30 秒执行 show processlist，看到的结果是这样的。 图中 id=4 和 id=5 的两个会话都是 Sleep 状态。而要看事务具体状态的话，可以查 information_schema 库的 innodb_trx 表。 这个结果里，trx_mysql_thread_id=4，表示 id=4 的线程还处在事务中。因此，如果是连接数过多，可以优先断开事务外空闲太久的连接；如果这样还不够，再考虑断开事务内空闲太久的连接。 从服务端断开连接使用的是 kill connection + id 的命令，一个客户端处于 sleep 状态时，它的连接被服务端主动断开后，这个客户端并不会马上知道。直到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。 从数据库端主动断开连接可能是有损的，尤其是有的应用端收到这个错误后，不重新连接，而是直接用这个已经不能用的句柄重试查询。这会导致从应用端看上去，“MySQL 一直没恢复”。 第二种方法：减少连接过程的消耗。 有的业务代码会在短时间内先大量申请数据库连接做备用，如果现在数据库确认是被连接行为打挂了，那么一种可能的做法，是让数据库跳过权限验证阶段。 跳过权限验证的方法是：重启数据库，并使用–skip-grant-tables 参数启动。这样，整个 MySQL 会跳过所有的权限验证阶段，包括连接过程和语句执行过程在内。 但是，这种方法特别符合标题里说的“饮鸩止渴”，风险极高，是特别不建议使用的方案。尤其库外网可访问的话，就更不能这么做了。 在 MySQL 8.0 版本里，如果启用–skip-grant-tables 参数，MySQL 会默认把 –skip-networking 参数打开，表示这时候数据库只能被本地的客户端连接。可见，MySQL 官方对 skip-grant-tables 这个参数的安全问题也很重视。 2 慢查询性能问题 在 MySQL 中，会引发性能问题的慢查询，大体有以下三种可能： 索引没有设计好； SQL 语句没有写好。 MySQL 选错索引。 导致慢查询的第一种可能是，索引没有设计好。 这种场景一般就是通过紧急创建索引来解决。MySQL 5.6 版本以后，创建索引都支持 Online DDL 了，对于那种高峰期数据库已经被这个语句打挂了的情况，最高效的做法就是直接执行 alter table 语句。比较理想的是能够在备库先执行。假设现在的服务是一主一备，主库 A、备库 B，这个方案的大致流程是这样的： 在备库 B 上执行 set sql_log_bin=off，也就是不写 binlog，然后执行 alter table 语句加上索引； 执行主备切换； 这时候主库是 B，备库是 A。在 A 上执行 set sql_log_bin=off，然后执行 alter table 语句加上索引。 这是一个“古老”的 DDL 方案。平时在做变更的时候，应该考虑类似 gh-ost 这样的方案，更加稳妥。但是在需要紧急处理时，上面这个方案的效率是最高的。 导致慢查询的第二种可能是，语句没写好。 这时，可以通过改写 SQL 语句来处理。MySQL 5.7 提供了 query_rewrite 功能，可以把输入的一种语句改写成另外一种模式。比如，语句被错误地写成了 select * from t where id + 1 = 10000，可以通过下面的方式，增加一个语句改写规则。 mysql\u003e insert into query_rewrite.rewrite_rules(pattern, replacement, pattern_database) values (\"select * from t where id + 1 = ?\", \"select * from t where id = ? - 1\", \"db1\"); call query_rewrite.flush_rewrite_rules(); 这里，call query_rewrite.flush_rewrite_rules() 这个存储过程，是让插入的新规则生效，也就是我们说的“查询重写”。可以用下图中的方法来确认改写规则是否生效。 导致慢查询的第三种可能，就是碰上 MySQL 选错了索引。这时候，应急方案就是给这个语句加上 force index。同样地，使用查询重写功能，给原来的语句加上 force index，也可以解决这个问题。 上面讨论的由慢查询导致性能问题的三种可能情况，实际上出现最多的是前两种，即：索引没设计好和语句没写好。而这两种情况，恰恰是完全可以避免的。比如，通过下面这个过程就可以预先发现问题。 上线前，在测试环境，把慢查询日志（slow log）打开，并且把 long_query_time 设置成 0，确保每个语句都会被记录入慢查询日志； 在测试表里插入模拟线上的数据，做一遍回归测试； 观察慢查询日志里每类语句的输出，特别留意 Rows_examined 字段是否与预期一致。 3 QPS 突增问题 有时候由于业务突然出现高峰，或者应用程序 bug，导致某个语句的 QPS 突然暴涨，也可能导致 MySQL 压力过大，影响服务。最理想的情况是让业务把这个功能下掉，服务自然就会恢复。 而下掉一个功能，如果从数据库端处理的话，对应于不同的背景，有不同的方法可用。这里再展开说明一下。 一种是由全新业务的 bug 导致的。假设 DB 运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接把白名单去掉。 如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的 QPS 就会变成 0。 如果这个新增的功能跟主体功能是部署在一起的，那么只能通过处理语句来限制。这时，可以使用上面提到的查询重写功能，把","date":"2025-02-16","objectID":"/posts/22.mysql%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"22 | MySQL 有哪些“饮鸩止渴”提高性能的方法？","uri":"/posts/22.mysql%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入探讨了 MySQL 加锁规则，通过详细解释加锁规则的原则、优化和 bug，以及介绍了间隙锁和 next-key lock 的概念。","date":"2025-02-16","objectID":"/posts/21.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%94%B9%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E9%94%81%E8%BF%99%E4%B9%88%E5%A4%9A/","tags":["MySQL 实战 45 讲","MySQL"],"title":"21 | 为什么我只改一行的语句，锁这么多？","uri":"/posts/21.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%94%B9%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E9%94%81%E8%BF%99%E4%B9%88%E5%A4%9A/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入探讨了 MySQL 加锁规则，通过详细解释加锁规则的原则、优化和 bug，以及介绍了间隙锁和 next-key lock 的概念。通过案例分析，读者可以了解 MySQL 在不同情况下的加锁方式，以及加锁规则对并发操作的影响。 下面的加锁规则有以下前提说明：MySQL 后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即 5.x 系列 \u003c=5.7.24，8.0 系列 \u003c=8.0.13。 总结的加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。 原则 1：加锁的基本单位是 next-key lock，next-key lock 是前开后闭区间。 原则 2：查找过程中访问到的对象才会加锁。 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。 还是以上篇文章的表 t 为例解释一下这些规则。表 t 的建表语句和初始化语句如下。 CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`) ) ENGINE=InnoDB; insert into t values(0,0,0),(5,5,5), (10,10,10),(15,15,15),(20,20,20),(25,25,25); 1 案例一：等值查询间隙锁 第一个例子是关于等值条件操作间隙： 由于表 t 中没有 id=7 的记录，所以用上面提到的加锁规则判断一下的话： 根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 (5,10]； 同时根据优化 2，这是一个等值查询 (id=7)，而 id=10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。 所以，session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 session C 修改 id=10 这行是可以的。 2 案例二：非唯一索引等值锁 第二个例子是关于覆盖索引上的锁： 看到这个例子，你是不是有一种“该锁的不锁，不该锁的乱锁”的感觉？我们来分析一下吧。这里 session A 要给索引 c 上 c=5 的这一行加上读锁。 根据原则 1，加锁单位是 next-key lock，因此会给 (0,5] 加上 next-key lock。 要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的，需要向右遍历，查到 c=10 才放弃。根据原则 2，访问到的都要加锁，因此要给 (5,10] 加 next-key lock。 但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c=5 这个等值条件，因此退化成间隙锁 (5,10)。 根据原则 2，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。 但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住。 需要注意，在这个例子中，lock in share mode 只锁覆盖索引，但是如果是 for update 就不一样了。执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。 这个例子说明，锁是加在索引上的；同时，如果要用 lock in share mode 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将 session A 的查询语句改成 select d from t where c=5 lock in share mode。你可以自己验证一下效果。 3 案例三：主键索引范围锁 第三个例子是关于范围查询的。可以先思考一下这个问题：对于表 t，下面这两条查询语句，加锁范围相同吗？ mysql\u003e select * from t where id=10 for update; mysql\u003e select * from t where id\u003e=10 and id\u003c11 for update; 你可能会想，id 定义为 int 类型，这两个语句就是等价的吧？其实，它们并不完全等价。在逻辑上，这两条查语句肯定是等价的，但是它们的加锁规则不太一样。现在就让 session A 执行第二个查询语句，来看看加锁效果。 现在就用前面提到的加锁规则，来分析一下 session A 会加什么锁呢？ 开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10]。根据优化 1，主键 id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁。 范围查找就往后继续找，找到 id=15 这一行停下来，因此需要加 next-key lock(10,15]。 所以，session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-key lock(10,15]。这样，session B 和 session C 的结果就能理解了。 这里需要注意一点，首次 session A 定位查找 id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，用的是范围查询判断。 4 案例四：非唯一索引范围锁 接下来，再看两个范围查询加锁的例子，可以对照着案例三来看。需要注意的是，与案例三不同的是，案例四中查询语句的 where 部分用的是字段 c。 这次 session A 用字段 c 来判断，加锁规则跟案例三唯一的不同是：在第一次用 c=10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 c 是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-key lock。 所以从结果上来看，sesson B 要插入（8,8,8) 的这个 insert 语句时就被堵住了。这里需要扫描到 c=15 才停止扫描，是合理的，因为 InnoDB 要扫到 c=15，才知道不需要继续往后找了。 5 案例五：唯一索引范围锁 bug 前面的四个案例，已经用到了加锁规则中的两个原则和两个优化，接下来再看一个关于加锁规则中 bug 的案例。 session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] 这个 next-key lock，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了。 但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。 所以可以看到，session B 要更新 id=20 这一行，是会被锁住的。同样地，session C 要插入 id=16 的一行，也会被锁住。 照理说，这里锁住 id=20 这一行的行为，其实是没有必要的。因为扫描到 id=15，就可以确定不用往后再找了。但实现上还是这么做了，因此认为这是个 bug。 6 案例六：非唯一索引上存在\"等值\"的例子 接下来的例子，是为了更好地说明“间隙”这个概念。这里给表 t 插入一条新记录。 mysql\u003e insert into t values(30,10,30); 新插入的这一行 c=10，也就是说现在表里有两个 c=10 的行。那么，这时候索引 c 上的间隙是什么状态了呢？你要知道，由于非唯一索引上包含主键的值，所以是不可能存在“相同”的两行的。 可以看到，虽然有两个 c=10，但是它们的主键值 id 是不同的（分别是 10 和 30），因此这两个 c=10 的记录之间，也是有间隙的。 图中画出了索引 c 上的主键 id。为了跟间隙锁的开区间形式进行区别，用 (c=10,id=30) 这样的形式，来表示索引上的一行。现在再来看一下案例六。 这次用 delete 语句来验证。注意，delete 语句加锁的逻辑，其实跟 select … for update 是类似的，也就是在文章开始总结的两个“原则”、两个“优化”和一个“bug”。 这时，session A 在遍历的时候，先访问第一个 c=10 的记录。同样地，根据原则 1，这里加的是 (c=5,id=5) 到 (c=10,id=10) 这个 next-key lock。 然后，session A 向右查找，直到碰到 (c=15,id=15) 这一行，循环才结束。根据优化 2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成 (c=10,id=10) 到 (c=15,id=15) 的间隙锁。 也就是说，这个 delete 语句在索引 c 上的加锁范围，就是下图中蓝色区域覆盖的部分。 这个蓝色区域左右两边都是虚线，表示开区间，即 (c=5,id=5) 和 (c=15,id=15) 这两行上都没有锁。 7 案例七：limit 语句加锁 例子 6 也有一个对","date":"2025-02-16","objectID":"/posts/21.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%94%B9%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E9%94%81%E8%BF%99%E4%B9%88%E5%A4%9A/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"21 | 为什么我只改一行的语句，锁这么多？","uri":"/posts/21.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%94%B9%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E9%94%81%E8%BF%99%E4%B9%88%E5%A4%9A/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入探讨了数据库中的幻读问题及其解决方案。","date":"2025-02-16","objectID":"/posts/20.%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/","tags":["MySQL 实战 45 讲","MySQL"],"title":"20 | 幻读是什么，幻读有什么问题？","uri":"/posts/20.%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入探讨了数据库中的幻读问题及其解决方案。以一个小表为例，通过对加锁规则的讨论引出了幻读问题，并分析了在可重复读隔离级别下可能导致的幻读现象。通过具体的例子和图示，生动地展示了幻读的产生和影响。 为了便于说明问题，这一篇文章先使用一个小一点儿的表。建表和初始化语句如下： CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`) ) ENGINE=InnoDB; insert into t values(0,0,0),(5,5,5), (10,10,10),(15,15,15),(20,20,20),(25,25,25); 这个表除了主键 id 外，还有一个索引 c，初始化语句在表中插入了 6 行数据。下面的语句序列，是怎么加锁的，加的锁又是什么时候释放的呢？ begin; select * from t where d=5 for update; commit; 比较好理解的是，这个语句会命中 d=5 的这一行，对应的主键 id=5，因此在 select 语句执行完成后，id=5 这一行会加一个写锁，而且由于两阶段锁协议，这个写锁会在执行 commit 语句的时候释放。 由于字段 d 上没有索引，因此这条查询语句会做全表扫描。那么，其他被扫描到的，但是不满足条件的 5 行记录上，会不会被加锁呢？ InnoDB 的默认事务隔离级别是可重复读，所以本文接下来没有特殊说明的部分，都是设定在可重复读隔离级别下。 1 幻读是什么？ 现在就来分析一下，如果只在 id=5 这一行加锁，而其他行的不加锁的话，会怎么样。下面先来看一下这个假设的场景： 可以看到，session A 里执行了三次查询，分别是 Q1、Q2 和 Q3。它们的 SQL 语句相同，都是 select * from t where d=5 for update。这个语句的意思你应该很清楚了，查所有 d=5 的行，而且使用的是当前读，并且加上写锁。现在，来看一下这三条 SQL 语句，分别会返回什么结果。 Q1 只返回 id=5 这一行； 在 T2 时刻，session B 把 id=0 这一行的 d 值改成了 5，因此 T3 时刻 Q2 查出来的是 id=0 和 id=5 这两行； 在 T4 时刻，session C 又插入一行（1,1,5），因此 T5 时刻 Q3 查出来的是 id=0、id=1 和 id=5 的这三行。 其中，Q3 读到 id=1 这一行的现象，被称为“幻读”。也就是说，幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。这里，对“幻读”做一个说明： 在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。 上面 session B 的修改结果，被 session A 之后的 select 语句用“当前读”看到，不能称为幻读。幻读仅专指“新插入的行”。 如果从之前学到的事务可见性规则来分析的话，上面这三条 SQL 语句的返回结果都没有问题。因为这三个查询都是加了 for update，都是当前读。而当前读的规则，就是要能读到所有已经提交的记录的最新值。并且，session B 和 sessionC 的两条语句，执行后就会提交，所以 Q2 和 Q3 就是应该看到这两个事务的操作效果，而且也看到了，这跟事务的可见性规则并不矛盾。但是，这是不是真的没问题呢？不，这里还真就有问题。 2 幻读有什么问题？ 首先是语义上的。session A 在 T1 时刻就声明了，“我要把所有 d=5 的行锁住，不准别的事务进行读写操作”。而实际上，这个语义被破坏了。 如果现在这样看感觉还不明显的话，再往 session B 和 session C 里面分别加一条 SQL 语句，再看看会出现什么现象。 session B 的第二条语句 update t set c=5 where id=0，语义是“我把 id=0、d=5 这一行的 c 值，改成了 5”。 由于在 T1 时刻，session A 还只是给 id=5 这一行加了行锁，并没有给 id=0 这行加上锁。因此，session B 在 T2 时刻，是可以执行这两条 update 语句的。这样，就破坏了 session A 里 Q1 语句要锁住所有 d=5 的行的加锁声明。session C 也是一样的道理，对 id=1 这一行的修改，也是破坏了 Q1 的加锁声明。 其次，是数据一致性的问题。 锁的设计是为了保证数据的一致性。而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。为了说明这个问题，给 session A 在 T1 时刻再加一个更新语句，即：update t set d=100 where d=5。 update 的加锁语义和 select …for update 是一致的，所以这时候加上这条 update 语句也很合理。session A 声明说“要给 d=5 的语句加上锁”，就是为了要更新数据，新加的这条 update 语句就是把它认为加上了锁的这一行的 d 值修改成了 100。 现在，我们来分析一下上图的流程执行完成后，数据库里会是什么结果。 经过 T1 时刻，id=5 这一行变成 (5,5,100)，当然这个结果最终是在 T6 时刻正式提交的 ; 经过 T2 时刻，id=0 这一行变成 (0,5,5); 经过 T4 时刻，表里面多了一行 (1,5,5); 其他行跟这个执行序列无关，保持不变。 这样看，这些数据也没啥问题，但是我们再来看看这时候 binlog 里面的内容。 T2 时刻，session B 事务提交，写入了两条语句； T4 时刻，session C 事务提交，写入了两条语句； T6 时刻，session A 事务提交，写入了 update t set d=100 where d=5 这条语句。 统一放到一起的话，就是这样的： update t set d=5 where id=0; /*(0,0,5)*/ update t set c=5 where id=0; /*(0,5,5)*/ insert into t values(1,1,5); /*(1,1,5)*/ update t set c=5 where id=1; /*(1,5,5)*/ update t set d=100 where d=5;/*所有 d=5 的行，d 改成 100*/ 你应该看出问题了。这个语句序列，不论是拿到备库去执行，还是以后用 binlog 来克隆一个库，这三行的结果，都变成了 (0,5,100)、(1,5,100) 和 (5,5,100)。也就是说，id=0 和 id=1 这两行，发生了数据不一致。这个问题很严重，是不行的。到这里，再回顾一下，这个数据不一致到底是怎么引入的？ 分析一下可以知道，这是我们假设“select * from t where d=5 for update 这条语句只给 d=5 这一行，也就是 id=5 的这一行加锁”导致的。所以我们认为，上面的设定不合理，要改。那怎么改呢？可以把扫描过程中碰到的行，也都加上写锁，再来看看执行效果。 由于 session A 把所有的行都加了写锁，所以 session B 在执行第一个 update 语句的时候就被锁住了。需要等到 T6 时刻 session A 提交以后，session B 才能继续执行。 这样对于 id=0 这一行，在数据库里的最终结果还是 (0,5,5)。在 binlog 里面，执行序列是这样的： insert into t values(1,1,5); /*(1,1,5)*/ update t set c=5 where id=1; /*(1,5,5)*/ update t set d=100 where d=5;/*所有 d=5 的行，d 改成 100*/ update t set d=5 where id=0; /*(0,0,5)*/ update t set c=5 where id=0; /*(0,5,5)*/ 可以看到，按照日志顺序执行，id=0 这一行的最终结果也是 (0,5,5)。所以，id=0 这一行的问题解决了。 但同时你也可以看到，id=1 这一行，在数据库里面的结果是 (1,5,5)，而根据 binlog 的执行结果是 (1,5,100)，也就是说幻读的问题还是没有解决。为什么已经这么“凶残”地，把所有的记录都上了锁，还是阻止不了 id=1 这一行的插入和更新呢？ 原因很简单。在 T3 时刻，给所有行加锁的时候，id=1 这一行还不存在，不存在也就加不上锁。也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录，这也是为什么“幻读”会被单独拿出来解决的原因。接下来，再看看 InnoDB 怎么解决幻读的问题。 3 如何解决幻读？ 产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。 顾名思义，间隙锁，锁的就是两个值之间的空隙。比如文章开头的表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。 这样，当你执行 select * from t where d=5 fo","date":"2025-02-16","objectID":"/posts/20.%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"20 | 幻读是什么，幻读有什么问题？","uri":"/posts/20.%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入探讨了查询性能优化中可能出现的问题及解决方法。","date":"2025-02-16","objectID":"/posts/19.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%9F%A5%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E4%B9%9F%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B9%88%E6%85%A2/","tags":["MySQL 实战 45 讲","MySQL"],"title":"19 | 为什么我只查一行的语句，也执行这么慢？","uri":"/posts/19.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%9F%A5%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E4%B9%9F%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B9%88%E6%85%A2/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入探讨了查询性能优化中可能出现的问题及解决方法。通过构造一个包含 10 万行记录的表，展示了即使是查询单行数据，也可能出现执行缓慢的情况。文章详细分析了表被锁住的情况，包括等 MDL 锁、等 flush 或等行锁导致的情况，并提供了相应的处理方法。 一般情况下，如果说查询性能优化，你首先会想到一些复杂的语句，想到查询需要返回大量的数据。但有些情况下，“查一行”，也会执行得特别慢。 需要说明的是，如果 MySQL 数据库本身就有很大的压力，导致数据库服务器 CPU 占用率很高或 ioutil（IO 利用率）很高，这种情况下所有语句的执行都有可能变慢，不属于今天的讨论范围。 为了便于描述，还是构造一个表，基于这个表来说明今天的问题。这个表有两个字段 id 和 c，并且在里面插入了 10 万行记录。 mysql\u003e CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB; delimiter ;; create procedure idata() begin declare i int; set i=1; while(i\u003c=100000) do insert into t values(i,i); set i=i+1; end while; end;; delimiter ; call idata(); 1 第一类：查询长时间不返回 如下图所示，在表 t 执行下面的 SQL 语句： mysql\u003e select * from t where id=1; 查询结果长时间不返回。 一般碰到这种情况的话，大概率是表 t 被锁住了。接下来分析原因的时候，一般都是首先执行一下 show processlist 命令，看看当前语句处于什么状态。 然后再针对每种状态，去分析它们产生的原因、如何复现，以及如何处理。 2 等 MDL 锁 如下图所示，就是使用 show processlist 命令查看 Waiting for table metadata lock 的示意图。 出现这个状态表示的是，现在有一个线程正在表 t 上请求或者持有 MDL 写锁，把 select 语句堵住了。 下面来复现一下这个场景，下图就是一个简单的人复现步骤。 session A 通过 lock table 命令持有表 t 的 MDL 写锁，而 session B 的查询需要获取 MDL 读锁。所以，session B 进入等待状态。这类问题的处理方式，就是找到谁持有 MDL 写锁，然后把它 kill 掉。 但是，由于在 show processlist 的结果里面，session A 的 Command 列是“Sleep”，导致查找起来很不方便。不过有了 performance_schema 和 sys 系统库以后，就方便多了。（MySQL 启动时需要设置 performance_schema=on，相比于设置为 off 会有 10% 左右的性能损失) 通过查询 sys.schema_table_lock_waits 这张表，就可以直接找出造成阻塞的 process id，把这个连接用 kill 命令断开即可。 3 等 flush 接下来说一下另外一种查询被堵住的情况。在表 t 上，执行下面的 SQL 语句： mysql\u003e select * from information_schema.processlist where id=1; 可以看一下下图。查出来这个线程的状态是 Waiting for table flush，可以设想一下这是什么原因。 这个状态表示的是，现在有一个线程正要对表 t 做 flush 操作。MySQL 里面对表做 flush 操作的用法，一般有以下两个： flush tables t with read lock; flush tables with read lock; 这两个 flush 语句，如果指定表 t 的话，代表的是只关闭表 t；如果没有指定具体的表名，则表示关闭 MySQL 里所有打开的表。但是正常这两个语句执行起来都很快，除非它们也被别的线程堵住了。 所以，出现 Waiting for table flush 状态的可能情况是：有一个 flush tables 命令被别的语句堵住了，然后它又堵住了我们的 select 语句。现在一起来复现一下这种情况，复现步骤如下图所示： 在 session A 中，故意每行都调用一次 sleep(1)，这样这个语句默认要执行 10 万秒，在这期间表 t 一直是被 session A“打开”着。然后，session B 的 flush tables t 命令再要去关闭表 t，就需要等 session A 的查询结束。这样，session C 要再次查询的话，就会被 flush 命令堵住了。 下图是这个复现步骤的 show processlist 结果。这个例子的排查也很简单，看到这个 show processlist 的结果，肯定就知道应该怎么做了。 4 等行锁 现在，经过了表级锁的考验，我们的 select 语句终于来到引擎里了。 mysql\u003e select * from t where id=1 lock in share mode; 由于访问 id=1 这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我们的 select 语句就会被堵住。复现步骤和现场如下： 显然，session A 启动了事务，占有写锁，还不提交，是导致 session B 被堵住的原因。 这个问题并不难分析，但问题是怎么查出是谁占着这个写锁。如果你用的是 MySQL 5.7 版本，可以通过 sys.innodb_lock_waits 表查到。查询方法是： mysql\u003e select * from t sys.innodb_lock_waits where locked_table='`test`.`t`'\\G 可以看到，这个信息很全，4 号线程是造成堵塞的罪魁祸首。而干掉这个罪魁祸首的方式，就是 KILL QUERY 4 或 KILL 4。 不过，这里不应该显示“KILL QUERY 4”。这个命令表示停止 4 号线程当前正在执行的语句，而这个方法其实是没有用的。因为占有行锁的是 update 语句，这个语句已经是之前执行完成了的，现在执行 KILL QUERY，无法让这个事务去掉 id=1 上的行锁。 实际上，KILL 4 才有效，也就是说直接断开这个连接。这里隐含的一个逻辑就是，连接被断开的时候，会自动回滚这个连接里面正在执行的线程，也就释放了 id=1 上的行锁。 5 第二类：查询慢 经过了重重封“锁”，再来看看一些查询慢的例子。先来看一条你一定知道原因的 SQL 语句： mysql\u003e select * from t where c=50000 limit 1; 由于字段 c 上没有索引，这个语句只能走 id 主键顺序扫描，因此需要扫描 5 万行。作为确认，可以看一下慢查询日志。注意，这里为了把所有语句记录到 slow log 里，在连接后先执行了 set long_query_time=0，将慢查询日志的时间阈值设置为 0。 Rows_examined 显示扫描了 50000 行。你可能会说，不是很慢呀，11.5 毫秒就返回了，线上一般都配置超过 1 秒才算慢查询。但你要记住：坏查询不一定是慢查询。这个例子里面只有 10 万行记录，数据量大起来的话，执行时间就线性涨上去了。扫描行数多，所以执行慢，这个很好理解。 但是接下来，再看一个只扫描一行，但是执行很慢的语句。如下图所示，是这个例子的 slow log。可以看到，执行的语句是 mysql\u003e select * from t where id=1； 虽然扫描行数是 1，但执行时间却长达 800 毫秒。 是不是有点奇怪呢，这些时间都花在哪里了？如果把这个 slow log 的截图再往下拉一点，可以看到下一个语句，select * from t where id=1 lock in share mode，执行时扫描行数也是 1 行，执行时间是 0.2 毫秒。 看上去是不是更奇怪了？按理说 lock in share mode 还要加锁，时间应该更长才对啊。下图是这两个语句的执行输出结果。 第一个语句的查询结果里 c=1，带 lock in share mode 的语句返回的是 c=1000001。下图是复现步骤。 可以看到，session A 先用 start transaction with consistent snapshot 命令启动了一个事务，之后 session B 才开始执行 update 语句。 session B 执行完 100 万次 update 语句后，id=1 这一行处于什么状态呢？可以从下图中找到答案。 session B 更新完 100 万次，生成了 100 万个回滚日志 (undo log)。 带 lock in share mode 的 SQL 语句，是当前读，因此会直接读到 1000001 这个结果，所以速度很快；而 select * from t where id=1 这个语句，是一致性读，因此需要从 1000001 开始，依次执行 undo log，执行了 100 万次以后，才将 1 这个结果返回。 注意，undo log 里记录的其实是“把 2 改成 1”，“把 3 改","date":"2025-02-16","objectID":"/posts/19.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%9F%A5%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E4%B9%9F%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B9%88%E6%85%A2/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"19 | 为什么我只查一行的语句，也执行这么慢？","uri":"/posts/19.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%9F%A5%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E4%B9%9F%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B9%88%E6%85%A2/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入探讨了 MySQL 中相似逻辑的 SQL 语句却存在巨大性能差异的原因。","date":"2025-02-16","objectID":"/posts/18.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BA%9Bsql%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C%E6%80%A7%E8%83%BD%E5%8D%B4%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7/","tags":["MySQL 实战 45 讲","MySQL"],"title":"18 | 为什么这些 SQL 语句逻辑相同，性能却差异巨大？","uri":"/posts/18.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BA%9Bsql%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C%E6%80%A7%E8%83%BD%E5%8D%B4%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入探讨了 MySQL 中相似逻辑的 SQL 语句却存在巨大性能差异的原因。通过具体案例分析和图示，解释了对索引字段进行函数操作可能导致性能下降的情况，以及隐式类型转换对性能的影响。 在 MySQL 中，有很多看上去逻辑相同，但性能却差异巨大的 SQL 语句。对这些语句使用不当的话，就会不经意间导致整个数据库的压力变大。 1 案例一：条件字段函数操作 假设你现在维护了一个交易系统，其中交易记录表 tradelog 包含交易流水号（tradeid）、交易员 id（operator）、交易时间（t_modified）等字段。为了便于描述，先忽略其他字段。这个表的建表语句如下： mysql\u003e CREATE TABLE `tradelog` ( `id` int(11) NOT NULL, `tradeid` varchar(32) DEFAULT NULL, `operator` int(11) DEFAULT NULL, `t_modified` datetime DEFAULT NULL, PRIMARY KEY (`id`), KEY `tradeid` (`tradeid`), KEY `t_modified` (`t_modified`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 假设，现在已经记录了从 2016 年初到 2018 年底的所有数据，运营部门有一个需求是，要统计发生在所有年份中 7 月份的交易记录总数。这个逻辑看上去并不复杂，SQL 语句可能会这么写： mysql\u003e select count(*) from tradelog where month(t_modified)=7; 由于 t_modified 字段上有索引，于是就很放心地在生产库中执行了这条语句，但却发现执行了特别久，才返回了结果。 如果你问 DBA 同事为什么会出现这样的情况，他大概会告诉你：如果对字段做了函数计算，就用不上索引了，这是 MySQL 的规定。为什么条件是 where t_modified=‘2018-7-1’的时候可以用上索引，而改成 where month(t_modified)=7 的时候就不行了？ 下面是这个 t_modified 索引的示意图。方框上面的数字就是 month() 函数对应的值。 如果 SQL 语句条件用的是 where t_modified=‘2018-7-1’的话，引擎就会按照上面绿色箭头的路线，快速定位到 t_modified=‘2018-7-1’需要的结果。 实际上，B+ 树提供的这个快速定位能力，来源于同一层兄弟节点的有序性。 但是，如果计算 month() 函数的话，你会看到传入 7 的时候，在树的第一层就不知道该怎么办了。 也就是说，对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。 需要注意的是，优化器并不是要放弃使用这个索引。 在这个例子里，放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引 t_modified，优化器对比索引大小后发现，索引 t_modified 更小，遍历这个索引比遍历主键索引来得更快。因此最终还是会选择索引 t_modified。 接下来，使用 explain 命令，查看一下这条 SQL 语句的执行结果。 key=“t_modified\"表示的是，使用了 t_modified 这个索引；在测试表数据中插入了 10 万行数据，rows=100335，说明这条语句扫描了整个索引的所有值；Extra 字段的 Using index，表示的是使用了覆盖索引。 也就是说，由于在 t_modified 字段加了 month() 函数操作，导致了全索引扫描。为了能够用上索引的快速定位能力，就要把 SQL 语句改成基于字段本身的范围查询。按照下面这个写法，优化器就能按照预期，用上 t_modified 索引的快速定位能力了。 mysql\u003e select count(*) from tradelog where -\u003e (t_modified \u003e= '2016-7-1' and t_modified\u003c'2016-8-1') or -\u003e (t_modified \u003e= '2017-7-1' and t_modified\u003c'2017-8-1') or -\u003e (t_modified \u003e= '2018-7-1' and t_modified\u003c'2018-8-1'); 当然，如果你的系统上线时间更早，或者后面又插入了之后年份的数据的话，你就需要再把其他年份补齐。到这里我给你说明了，由于加了 month() 函数操作，MySQL 无法再使用索引快速定位功能，而只能使用全索引扫描。 不过优化器在个问题上确实有“偷懒”行为，即使是对于不改变有序性的函数，也不会考虑使用索引。比如，对于 select * from tradelog where id + 1 = 10000 这个 SQL 语句，这个加 1 操作并不会改变有序性，但是 MySQL 优化器还是不能用 id 索引快速定位到 9999 这一行。所以，需要你在写 SQL 语句的时候，手动改写成 where id = 10000 -1 才可以。 2 案例二：隐式类型转换 再一起看一下下面的这条 SQL 语句： mysql\u003e select * from tradelog where tradeid=110717; 交易编号 tradeid 这个字段上，本来就有索引，但是 explain 的结果却显示，这条语句需要走全表扫描。你可能也发现了，tradeid 的字段类型是 varchar(32)，而输入的参数却是整型，所以需要做类型转换。那么，现在这里就有两个问题： 数据类型转换的规则是什么？ 为什么有数据类型转换，就需要走全索引扫描？ 数据库里面类型这么多，这种数据类型转换规则更多，记不住，应该怎么办呢？这里有一个简单的方法，看 select“10” \u003e 9 的结果： 如果规则是“将字符串转成数字”，那么就是做数字比较，结果应该是 1； 如果规则是“将数字转成字符串”，那么就是做字符串比较，结果应该是 0。 验证结果如下图所示。 从图中可知，select“10” \u003e 9 返回的是 1，所以就能确认 MySQL 里的转换规则了：在 MySQL 中，字符串和数字做比较的话，是将字符串转换成数字。这时，再看这个全表扫描的语句： mysql\u003e select * from tradelog where tradeid=110717; 就知道对于优化器来说，这个语句相当于： mysql\u003e select * from tradelog where CAST(tradid AS signed int) = 110717; 那么如果 id 的类型是 int，执行下面这个语句，是否会导致全表扫描呢？ select * from tradelog where id=\"83126\"; 上面的 SQL 会使用到 id 这个索引的，因为字符串和数字在进行比较的时候，是将字符串转换为数字。 3 案例三：隐式字符编码转换 假设系统里还有另外一个表 trade_detail，用于记录交易的操作细节。为了便于量化分析和复现，往交易日志表 tradelog 和交易详情表 trade_detail 这两个表里插入一些数据。 mysql\u003e CREATE TABLE `trade_detail` ( `id` int(11) NOT NULL, `tradeid` varchar(32) DEFAULT NULL, `trade_step` int(11) DEFAULT NULL, /*操作步骤*/ `step_info` varchar(32) DEFAULT NULL, /*步骤信息*/ PRIMARY KEY (`id`), KEY `tradeid` (`tradeid`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; insert into tradelog values(1, 'aaaaaaaa', 1000, now()); insert into tradelog values(2, 'aaaaaaab', 1000, now()); insert into tradelog values(3, 'aaaaaaac', 1000, now()); insert into trade_detail values(1, 'aaaaaaaa', 1, 'add'); insert into trade_detail values(2, 'aaaaaaaa', 2, 'update'); insert into trade_detail values(3, 'aaaaaaaa', 3, 'commit'); insert into trade_detail values(4, 'aaaaaaab', 1, 'add'); insert into trade_detail values(5, 'aaaaaaab', 2, 'update'); insert into trade_detail values(6, 'aaaaaaab', 3, 'update again'); insert into trade_detail values(7, 'aaaaaaab', 4, 'commit'); insert into trade_detail values(8, 'aaaaaaac', ","date":"2025-02-16","objectID":"/posts/18.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BA%9Bsql%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C%E6%80%A7%E8%83%BD%E5%8D%B4%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"18 | 为什么这些 SQL 语句逻辑相同，性能却差异巨大？","uri":"/posts/18.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BA%9Bsql%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C%E6%80%A7%E8%83%BD%E5%8D%B4%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入介绍了在 MySQL 中实现随机消息显示的技术特点和优化方法。","date":"2025-02-16","objectID":"/posts/17.%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF/","tags":["MySQL 实战 45 讲","MySQL"],"title":"17 | 如何正确地显示随机消息？","uri":"/posts/17.%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入介绍了在 MySQL 中实现随机消息显示的技术特点和优化方法。以一个英语学习 App 的性能问题为例，详细讲解了随机选择单词的 SQL 语句设计、执行流程和优化方法。文章首先介绍了内存临时表排序方法，并分析了其执行流程和扫描行数。作者还解释了内存临时表排序使用的 rowid 排序方法和 rowid 的概念。 假设现在让你做一个英语学习的 APP，这个英语学习 App 首页有一个随机显示单词的功能，也就是根据每个用户的级别有一个单词表，然后这个用户每次访问首页的时候，都会随机滚动显示三个单词。你会发现随着单词表变大，选单词这个逻辑变得越来越慢，甚至影响到了首页的打开速度。现在，如果让你来设计这个 SQL 语句，你会怎么写呢？ 为了便于理解，对这个例子进行了简化：去掉每个级别的用户都有一个对应的单词表这个逻辑，直接就是从一个单词表中随机选出三个单词。这个表的建表语句和初始数据的命令如下： mysql\u003e CREATE TABLE `words` ( `id` int(11) NOT NULL AUTO_INCREMENT, `word` varchar(64) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB; delimiter ;; create procedure idata() begin declare i int; set i=0; while i\u003c10000 do insert into words(word) values(concat(char(97+(i div 1000)), char(97+(i % 1000 div 100)), char(97+(i % 100 div 10)), char(97+(i % 10)))); set i=i+1; end while; end;; delimiter ; call idata(); 为了便于量化说明，在这个表里面插入了 10000 行记录。接下来我们来看看要随机选择 3 个单词，有什么方法实现，存在什么问题以及如何改进。 1 内存临时表 首先，你会想到用 order by rand() 来实现这个逻辑。 mysql\u003e select word from words order by rand() limit 3; 这个语句的意思很直白，随机排序取前 3 个。虽然这个 SQL 语句写法很简单，但执行流程却有点复杂的。先用 explain 命令来看看这个语句的执行情况。 Extra 字段显示 Using temporary，表示的是需要使用临时表；Using filesort，表示的是需要执行排序操作。因此这个 Extra 的意思就是，需要临时表，并且需要在临时表上排序。你觉得对于临时内存表的排序来说，它会选择哪一种算法呢？对于 InnoDB 表来说，执行全字段排序会减少磁盘访问，因此会被优先选择。 这里强调了“InnoDB 表”，你肯定想到了，对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘。优化器没有了这一层顾虑，那么它会优先考虑的，就是用于排序的行越小越好了，所以，MySQL 这时就会选择 rowid 排序。 理解了这个算法选择的逻辑，再来看看语句的执行流程。同时，通过今天的这个例子来尝试分析一下语句的扫描行数。这条语句的执行流程是这样的： 创建一个临时表。这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段是 double 类型，记为字段 R，第二个字段是 varchar(64) 类型，记为字段 W。并且，这个表没有建索引。 从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word 分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000。 现在临时表有 10000 行数据了，接下来你要在这个没有索引的内存临时表上，按照字段 R 排序。 初始化 sort_buffer。sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。 从内存临时表中一行一行地取出 R 值和位置信息，分别存入 sort_buffer 中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加 10000，变成了 20000。 在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。 排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出 word 值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003。 接下来，通过慢查询日志（slow log）来验证一下我们分析得到的扫描行数是否正确。 # Query_time: 0.900376 Lock_time: 0.000347 Rows_sent: 3 Rows_examined: 20003 SET timestamp=1541402277; select word from words order by rand() limit 3; 其中，Rows_examined：20003 就表示这个语句执行过程中扫描了 20003 行，也就验证了分析得出的结论。现在，我们来把完整的排序执行流程图画出来。 图中的 pos 就是位置信息，你可能会觉得奇怪，这里的“位置信息”是个什么概念？在上一篇文章中，我们对 InnoDB 表排序的时候，明明用的还是 ID 字段。这时候，就要回到一个基本概念：MySQL 的表是用什么方法来定位“一行数据”的。 如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法回表了？其实不是的。如果创建的表没有主键，或者把一个表的主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 来作为主键。这也就是排序模式里面，rowid 名字的来历。实际上它表示的是：每个引擎用来唯一标识数据行的信息。 对于有主键的 InnoDB 表来说，这个 rowid 就是主键 ID； 对于没有主键的 InnoDB 表来说，这个 rowid 就是由系统生成的； MEMORY 引擎不是索引组织表。在这个例子里面，可以认为它就是一个数组。因此，这个 rowid 其实就是数组的下标。 到这里，稍微小结一下：order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。 2 磁盘临时表 那么，是不是所有的临时表都是内存表呢？其实不是的。tmp_table_size 这个配置限制了内存临时表的大小，默认值是 16M。如果临时表大小超过了 tmp_table_size，那么内存临时表就会转成磁盘临时表。磁盘临时表使用的引擎默认是 InnoDB，是由参数 internal_tmp_disk_storage_engine 控制的。当使用磁盘临时表的时候，对应的就是一个没有显式索引的 InnoDB 表的排序过程。 为了复现这个过程，可以把 tmp_table_size 设置成 1024，把 sort_buffer_size 设置成 32768, 把 max_length_for_sort_data 设置成 16。 set tmp_table_size=1024; set sort_buffer_size=32768; set max_length_for_sort_data=16; /* 打开 optimizer_trace，只对本线程有效 */ SET optimizer_trace='enabled=on'; /* 执行语句 */ select word from words order by rand() limit 3; /* 查看 OPTIMIZER_TRACE 输出 */ SELECT * FROM `information_schema`.`OPTIMIZER_TRACE`\\G 然后，来看一下这次 OPTIMIZER_TRACE 的结果。 因为将 max_length_for_sort_data 设置成 16，小于 word 字段的长度定义，所以可以看到 sort_mode 里面显示的是 rowid 排序，这个是符合预期的，参与排序的是随机值 R 字段和 rowid 字段组成的行。 你可能会发现不对。R 字段存放的随机值就 8 个字节，rowid 是 6 个字节，数据总行数是 10000，这样算出来就有 140000 字节，超过了 sort_buffer_size 定义的 32768 字节了。但是，number_of_tmp_files 的值居然是 0，难道不需要用临时文件吗？ 这个 SQL 语句的排序确实没有用到临时文件，采用是 MySQL 5.6 版本引入的一个新的排序算法，即：优先队列排序算法。接下来，就看看为什么没有使用临时文件的算法，也就是归并排序算法，而是采用了优先队列排序算法。 其实，现在的 SQL 语句，只需要取 R 值最小的 3 个 rowid。但是，如果使用归并排序算法的话，虽然最终也能得到前 3 个值，但是这个算法结束后，已经将 10000 行数据都排好序了。 也就是说，后面的 9997 行也是有序的了。但，我们的查询并不需要这些数据是有序的。所以，想一下就明白了，这浪费了非常多的计算量。而优先队列算法，就可以精确地只得到三个最小值，执行流程如下： 对于这 10000 个准备排序的 (R,rowid)，先取前三行，构造成一","date":"2025-02-16","objectID":"/posts/17.%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"17 | 如何正确地显示随机消息？","uri":"/posts/17.%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入探讨了在开发应用中常见的根据指定字段排序来显示结果的需求，以及针对这种需求的 SQL 语句“order by”是如何执行的。","date":"2025-02-16","objectID":"/posts/16.order-by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/","tags":["MySQL 实战 45 讲","MySQL"],"title":"16 | “order by”是怎么工作的？","uri":"/posts/16.order-by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入探讨了在开发应用中常见的根据指定字段排序来显示结果的需求，以及针对这种需求的 SQL 语句“order by”是如何执行的。文章首先介绍了全字段排序的执行流程，包括使用 explain 命令查看语句的执行情况、sort_buffer 的内存排序和临时文件排序等细节。接着讨论了当排序的单行长度较大时，MySQL 采用的另一种算法——rowid 排序，详细解释了其执行流程和优化效果。通过对比两种排序算法的执行过程和优化效果，可以更好地理解“order by”语句的执行原理和影响因素。 在你开发应用的时候，一定会经常碰到需要根据指定的字段排序来显示结果的需求。还是以前面举例用过的市民表为例，假设要查询城市是“杭州”的所有人名字，并且按照姓名排序返回前 1000 个人的姓名、年龄。假设这个表的部分定义是这样的： CREATE TABLE `t` ( `id` int(11) NOT NULL, `city` varchar(16) NOT NULL, `name` varchar(16) NOT NULL, `age` int(11) NOT NULL, `addr` varchar(128) DEFAULT NULL, PRIMARY KEY (`id`), KEY `city` (`city`) ) ENGINE=InnoDB; 这时，你的 SQL 语句可以这么写： select city,name,age from t where city='杭州' order by name limit 1000; 那么这个语句是怎么执行的呢？以及有什么参数会影响执行的行为？ 1 全字段排序 为避免全表扫描，需要在 city 字段加上索引。在 city 字段上创建索引之后，用 explain 命令来看看这个语句的执行情况。 Extra 这个字段中的“Using filesort”表示的就是需要排序，MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。为了说明这个 SQL 查询语句的执行过程，先来看一下 city 这个索引的示意图。 从图中可以看到，满足 city=‘杭州’条件的行，是从 ID_X 到 ID_(X+N) 的这些记录。通常情况下，这个语句执行流程如下所示： 初始化 sort_buffer，确定放入 name、city、age 这三个字段； 从索引 city 找到第一个满足 city=‘杭州’条件的主键 id，也就是图中的 ID_X； 到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中； 从索引 city 取下一个记录的主键 id； 重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y； 对 sort_buffer 中的数据按照字段 name 做快速排序； 按照排序结果取前 1000 行返回给客户端。 暂且把这个排序过程，称为全字段排序，执行流程的示意图如下所示。 图中“按 name 排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 sort_buffer_size。 sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。可以用下面介绍的方法，来确定一个排序语句是否使用了临时文件。 /* 打开 optimizer_trace，只对本线程有效 */ SET optimizer_trace='enabled=on'; /* @a 保存 Innodb_rows_read 的初始值 */ select VARIABLE_VALUE into @a from performance_schema.session_status where variable_name = 'Innodb_rows_read'; /* 执行语句 */ select city, name,age from t where city='杭州' order by name limit 1000; /* 查看 OPTIMIZER_TRACE 输出 */ SELECT * FROM `information_schema`.`OPTIMIZER_TRACE`\\G /* @b 保存 Innodb_rows_read 的当前值 */ select VARIABLE_VALUE into @b from performance_schema.session_status where variable_name = 'Innodb_rows_read'; /* 计算 Innodb_rows_read 差值 */ select @b-@a; 这个方法是通过查看 OPTIMIZER_TRACE 的结果来确认的，可以从 number_of_tmp_files 中看到是否使用了临时文件。 number_of_tmp_files 表示的是，排序过程中使用的临时文件数。你一定奇怪，为什么需要 12 个文件？内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法。可以这么简单理解，MySQL 将需要排序的数据分成 12 份，每一份单独排序后存在这些临时文件中。然后把这 12 个有序文件再合并成一个有序的大文件。 如果 sort_buffer_size 超过了需要排序的数据量的大小，number_of_tmp_files 就是 0，表示排序可以直接在内存中完成。否则就需要放在临时文件中排序。sort_buffer_size 越小，需要分成的份数越多，number_of_tmp_files 的值就越大。 接下来，再来解释一下上图中其他两个值的意思。 示例表中有 4000 条满足 city=‘杭州’的记录，所以可以看到 examined_rows=4000，表示参与排序的行数是 4000 行。 sort_mode 里面的 packed_additional_fields 的意思是，排序过程对字符串做了“紧凑”处理。即使 name 字段的定义是 varchar(16)，在排序过程中还是要按照实际长度来分配空间的。 同时，最后一个查询语句 select @b-@a 的返回结果是 4000，表示整个执行过程只扫描了 4000 行。 这里需要注意的是，为了避免对结论造成干扰，把 internal_tmp_disk_storage_engine 设置成 MyISAM。否则，select @b-@a 的结果会显示为 4001。 这是因为查询 OPTIMIZER_TRACE 这个表时，需要用到临时表，而 internal_tmp_disk_storage_engine 的默认值是 InnoDB。如果使用的是 InnoDB 引擎的话，把数据从临时表取出来的时候，会让 Innodb_rows_read 的值加 1。 2 rowid 排序 在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在 sort_buffer 和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。所以如果单行很大，这个方法效率不够好。那么，如果 MySQL 认为排序的单行长度太大会怎么做呢？接下来，修改一个参数，让 MySQL 采用另外一种算法。 SET max_length_for_sort_data = 16; max_length_for_sort_data，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。 city、name、age 这三个字段的定义总长度是 36，把 max_length_for_sort_data 设置为 16，再来看看计算过程有什么改变。新的算法放入 sort_buffer 的字段，只有要排序的列（即 name 字段）和主键 id。 但这时，排序的结果就因为少了 city 和 age 字段的值，不能直接返回了，整个执行流程就变成如下所示的样子： 初始化 sort_buffer，确定放入两个字段，即 name 和 id； 从索引 city 找到第一个满足 city=‘杭州’条件的主键 id，也就是图中的 ID_X； 到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中； 从索引 city 取下一个记录的主键 id； 重复步骤 3、4 直到不满足 city=‘杭州’条件为止，也就是图中的 ID_Y； 对 sort_buffer 中的数据按照字段 name 进行排序； 遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。 这个执行流程的示意图如下，可以把它称为 rowid 排序。 对比第三幅图的全字段排序流程图你会发现，rowid 排序多访问了一次表 t 的主键索引，就是步骤 7。 需要说明的是，最后的“结果集”是一个逻辑概念，实际上 MySQL 服务端从排序后的 sort_buffer 中依次取出 id，然后到原表查到 city、name 和 age 这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给","date":"2025-02-16","objectID":"/posts/16.order-by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"16 | “order by”是怎么工作的？","uri":"/posts/16.order-by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"答疑文章。","date":"2025-02-12","objectID":"/posts/15.%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%80%E6%97%A5%E5%BF%97%E5%92%8C%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","tags":["MySQL 实战 45 讲","MySQL"],"title":"15 | 答疑文章（一）：日志和索引相关问题","uri":"/posts/15.%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%80%E6%97%A5%E5%BF%97%E5%92%8C%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文是 MySQL 实战专栏的答疑文章。 1 日志相关问题 在两阶段提交的不同瞬间，MySQL 如果发生异常重启，是怎么保证数据完整性的？ 这里，先和你解释一个误会式的问题。这个图不是一个 update 语句的执行流程吗，怎么还会调用 commit 语句？这是因为把两个“commit”的概念混淆了： “commit 语句”，是指 MySQL 语法中，用于提交一个事务的命令。一般跟 begin/start transaction 配对使用。 图中用到的这个“commit 步骤”，指的是事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，这个事务就提交完成了。 “commit 语句”执行的时候，会包含“commit 步骤”。 而我们这个例子里面，没有显式地开启事务，因此这个 update 语句自己就是一个事务，在执行完成后提交事务时，就会用到这个“commit 步骤“。接下来分析一下在两阶段提交的不同时刻，MySQL 异常重启会出现什么现象。 如果在图中时刻 A 的地方，也就是写入 redo log 处于 prepare 阶段之后、写 binlog 之前，发生了崩溃（crash），由于此时 binlog 还没写，redo log 也还没提交，所以崩溃恢复的时候，这个事务会回滚。这时候，binlog 还没写，所以也不会传到备库。 那时刻 B，binlog 写完，redo log 还没 commit 前发生 crash，那崩溃恢复的时候 MySQL 会怎么处理？先来看一下崩溃恢复时的判断规则。 如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交； 如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整： a. 如果是，则提交事务； b. 否则，回滚事务。 这里，时刻 B 发生 crash 对应的就是 2(a) 的情况，崩溃恢复过程中事务会被提交。 2 追问 1：MySQL 怎么知道 binlog 是完整的？ 一个事务的 binlog 是有完整格式的： statement 格式的 binlog，最后会有 COMMIT； row 格式的 binlog，最后会有一个 XID event。 另外，在 MySQL 5.6.2 版本以后，还引入了 binlog-checksum 参数，用来验证 binlog 内容的正确性。对于 binlog 日志由于磁盘原因，可能会在日志中间出错的情况，MySQL 可以通过校验 checksum 的结果来发现。所以，MySQL 还是有办法验证事务 binlog 的完整性的。 3 追问 2：redo log 和 binlog 是怎么关联起来的？ 它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log： 如果碰到既有 prepare、又有 commit 的 redo log，就直接提交； 如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。 4 追问 3：处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计？ 其实，这个问题还是跟反证法中说到的数据与备份的一致性有关。在时刻 B，也就是 binlog 写完以后 MySQL 发生崩溃，这时候 binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。 所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。 5 追问 4：如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？ 其实，两阶段提交是经典的分布式系统问题，并不是 MySQL 独有的。如果必须要举一个场景，来说明这么做的必要性的话，那就是事务的持久性问题。 对于 InnoDB 引擎来说，如果 redo log 提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。而如果 redo log 直接提交，然后 binlog 写入的时候失败，InnoDB 又回滚不了，数据和 binlog 日志又不一致了。 两阶段提交就是为了给所有人一个机会，当每个人都说“我 ok”的时候，再一起提交。 6 追问 5：不引入两个日志，也就没有两阶段提交的必要了。只用 binlog 来支持崩溃恢复，又能支持归档，不就可以了？ 只保留 binlog，然后可以把提交流程改成这样：… -\u003e “数据更新到内存” -\u003e “写 binlog” -\u003e “提交事务”，是不是也可以提供崩溃恢复的能力？答案是不可以。 如果说历史原因的话，那就是 InnoDB 并不是 MySQL 的原生存储引擎。MySQL 的原生引擎是 MyISAM，设计之初就有没有支持崩溃恢复。 InnoDB 在作为 MySQL 的插件加入 MySQL 引擎家族之前，就已经是一个提供了崩溃恢复和事务支持的引擎了。 InnoDB 接入了 MySQL 后，发现既然 binlog 没有崩溃恢复的能力，那就用 InnoDB 原有的 redo log 好了。 而如果说实现上的原因的话，就有很多了。就按照问题中说的，只用 binlog 来实现崩溃恢复的流程，画了一张示意图，这里就没有 redo log 了。 这样的流程下，binlog 还是不能支持崩溃恢复的。先 说一个不支持的点吧：binlog 没有能力恢复“数据页”。如果在图中标的位置，也就是 binlog2 写完了，但是整个事务还没有 commit 的时候，MySQL 发生了 crash。 重启后，引擎内部事务 2 会回滚，然后应用 binlog2 可以补回来；但是对于事务 1 来说，系统已经认为提交完成了，不会再应用一次 binlog1。 但是，InnoDB 引擎使用的是 WAL 技术，执行事务的时候，写完内存和日志，事务就算完成了。如果之后崩溃，要依赖于日志来恢复数据页。 也就是说在图中这个位置发生崩溃的话，事务 1 也是可能丢失了的，而且是数据页级的丢失。此时，binlog 里面并没有记录数据页的更新细节，是补不回来的。 你如果要说，那优化一下 binlog 的内容，让它来记录数据页的更改可以吗？但，这其实就是又做了一个 redo log 出来。所以，至少现在的 binlog 能力，还不能支持崩溃恢复。 7 追问 6：那能不能反过来，只用 redo log，不要 binlog？ 如果只从崩溃恢复的角度来讲是可以的。可以把 binlog 关掉，这样就没有两阶段提交了，但系统依然是 crash-safe 的。 但是，如果你了解一下业界各个公司的使用场景的话，就会发现在正式的生产库上，binlog 都是开着的。因为 binlog 有着 redo log 无法替代的功能。 一个是归档。redo log 是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log 也就起不到归档的作用。 一个就是 MySQL 系统依赖于 binlog。binlog 作为 MySQL 一开始就有的功能，被用在了很多地方。其中，MySQL 系统高可用的基础，就是 binlog 复制。 还有很多公司有异构系统（比如一些数据分析系统），这些系统就靠消费 MySQL 的 binlog 来更新自己的数据。关掉 binlog 的话，这些下游系统就没法输入了。 总之，由于现在包括 MySQL 高可用在内的很多系统机制都依赖于 binlog，所以“鸠占鹊巢”redo log 还做不到。 8 追问 7：redo log 一般设置多大？ redo log 太小的话，会导致很快就被写满，然后不得不强行刷 redo log，这样 WAL 机制的能力就发挥不出来了。 所以，如果是现在常见的几个 TB 的磁盘的话，就不要太小气了，直接将 redo log 设置为 4 个文件、每个文件 1GB 吧。 9 追问 8：正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？ 这个问题其实问得非常好。这里涉及到了，“redo log 里面到底是什么”的问题。实际上，redo log 并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在“数据最终落盘，是由 redo log 更新过去”的情况。 如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与 redo log 毫无关系。 在崩溃恢复场景中，InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让 redo log 更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。 10 追问 9：redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？ 在一个事务的更新过程中，日志是要写多次的。比如下面这个事务： begin; insert into t1 ... insert into t2 ... commit; 这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没 commit 的时候就直接写到 redo log 文件里。 所以，redo log buffer 就是一块内存，用来先存 redo 日志的。也就是说，在执行第一个 insert ","date":"2025-02-12","objectID":"/posts/15.%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%80%E6%97%A5%E5%BF%97%E5%92%8C%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"15 | 答疑文章（一）：日志和索引相关问题","uri":"/posts/15.%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%E4%B8%80%E6%97%A5%E5%BF%97%E5%92%8C%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入探讨了 MySQL 中 InnoDB 引擎下的数据库表空间回收问题，特别是在删除数据后表文件大小未发生变化的情况。","date":"2025-02-12","objectID":"/posts/13.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E6%8E%89%E4%B8%80%E5%8D%8A%E8%A1%A8%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98/","tags":["MySQL 实战 45 讲","MySQL"],"title":"13 | 为什么表数据删掉一半，表文件大小不变？","uri":"/posts/13.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E6%8E%89%E4%B8%80%E5%8D%8A%E8%A1%A8%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入探讨了 MySQL 中 InnoDB 引擎下的数据库表空间回收问题，特别是在删除数据后表文件大小未发生变化的情况。首先介绍了 InnoDB 表的组成结构和参数 innodb_file_per_table 的作用，建议将该参数设置为 ON 以便更好地管理表空间。随后详细说明了数据删除流程，包括记录和数据页的复用，以及删除和插入数据可能导致的空洞问题。最后，介绍了通过重建表来收缩表空间的方法，包括使用 alter table 命令和优化流程。 当数据库占用空间太大，把一个最大的表删掉了一半的数据，怎么表文件的大小还是没变？ 这里，还是针对 MySQL 中应用最广泛的 InnoDB 引擎展开讨论。一个 InnoDB 表包含两部分，即：表结构定义和数据。在 MySQL 8.0 版本以前，表结构是存在以.frm 为后缀的文件里。而 MySQL 8.0 版本，则已经允许把表结构定义放在系统数据表中了。因为表结构定义占用的空间很小。 1 参数 innodb_file_per_table 表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 innodb_file_per_table 控制的： 这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起； 这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。 从 MySQL 5.6.6 版本开始，它的默认值就是 ON 了。建议你不论使用 MySQL 的哪个版本，都将这个值设置为 ON。因为，一个表单独存储为一个文件更容易管理，而且在不需要这个表的时候，通过 drop table 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。所以，将 innodb_file_per_table 设置为 ON，是推荐做法，接下来的讨论都是基于这个设置展开的。 在删除整个表的时候，可以使用 drop table 命令回收表空间。但是，遇到的更多的删除数据的场景是删除某些行，这时就遇到了文章开头的问题：表中的数据被删除了，但是表空间却没有被回收。要彻底搞明白这个问题的话，就要从数据删除流程说起了。 2 数据删除流程 先再来看一下 InnoDB 中一个索引的示意图。InnoDB 里的数据都是用 B+ 树的结构组织的。 假设，要删掉 R4 这个记录，InnoDB 引擎只会把 R4 这个记录标记为删除。如果之后要再插入一个 ID 在 300 和 600 之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。 现在，你已经知道了 InnoDB 的数据是按页存储的，那么如果删掉了一个数据页上的所有记录，会怎么样？答案是，整个数据页就可以被复用了。但是，数据页的复用跟记录的复用是不同的。 记录的复用，只限于符合范围条件的数据。比如上面的这个例子，R4 这条记录被删除后，如果插入一个 ID 是 400 的行，可以直接复用这个空间。但如果插入的是一个 ID 是 800 的行，就不能复用这个位置了。 而当整个页从 B+ 树里面摘掉以后，可以复用到任何位置。以上图为例，如果将数据页 page A 上的所有记录删除以后，page A 会被标记为可复用。这时候如果要插入一条 ID=50 的记录需要使用新页的时候，page A 是可以被复用的。 如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。 进一步地，如果用 delete 命令把整个表的数据删除呢？结果就是，所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。 所以 delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过 delete 命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。实际上，不止是删除数据会造成空洞，插入数据也会。 如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。假设上图中 page A 已经满了，这时要再插入一行数据，会怎样呢？ 可以看到，由于 page A 满了，再插入一个 ID 是 550 的数据时，就不得不再申请一个新的页面 page B 来保存数据了。页分裂完成后，page A 的末尾就留下了空洞（注意：实际上，可能不止 1 个记录的位置是空洞）。另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造成空洞的。 也就是说，经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。而重建表，就可以达到这样的目的。 3 重建表 如果现在有一个表 A，需要做空间收缩，为了把表中存在的空洞去掉，可以怎么做呢？ 可以新建一个与表 A 结构相同的表 B，然后按照主键 ID 递增的顺序，把数据一行一行地从表 A 里读出来再插入到表 B 中。 由于表 B 是新建的表，所以表 A 主键索引上的空洞，在表 B 中就都不存在了。显然地，表 B 的主键索引更紧凑，数据页的利用率也更高。如果把表 B 作为临时表，数据从表 A 导入表 B 的操作完成后，用表 B 替换 A，从效果上看，就起到了收缩表 A 空间的作用。 这里，可以使用 alter table A engine=InnoDB 命令来重建表。在 MySQL 5.5 版本之前，这个命令的执行流程跟前面描述的差不多，区别只是这个临时表 B 不需要自己创建，MySQL 会自动完成转存数据、交换表名、删除旧表的操作。 显然，花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表 A 的话，就会造成数据丢失。因此，在整个 DDL 过程中，表 A 中不能有更新。也就是说，这个 DDL 不是 Online 的。 而在 MySQL 5.6 版本开始引入的 Online DDL，对这个操作流程做了优化。简单描述一下引入了 Online DDL 之后，重建表的流程： 建立一个临时文件，扫描表 A 主键的所有数据页； 用数据页中表 A 的记录生成 B+ 树，存储到临时文件中； 生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态； 临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3 的状态； 用临时文件替换表 A 的数据文件。 可以看到，两幅图的不同之处在于，由于日志文件记录和重放操作这个功能的存在，这个方案在重建表的过程中，允许对表 A 做增删改操作。这也就是 Online DDL 名字的来源。 上图的流程中，alter 语句在启动的时候需要获取 MDL 写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。为什么要退化呢？为了实现 Online，MDL 读锁不会阻塞增删改操作。那为什么不干脆直接解锁呢？为了保护自己，禁止其他线程对这个表同时做 DDL。 而对于一个大表来说，Online DDL 最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。所以，相对于整个 DDL 过程来说，锁的时间非常短。对业务来说，就可以认为是 Online 的。 需要补充说明的是，上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来说，这个操作是很消耗 IO 和 CPU 资源的。因此，如果是线上服务，要很小心地控制操作时间。如果想要比较安全的操作的话，推荐你使用 GitHub 开源的 gh-ost 来做。 4 Online 和 inplace 在第三幅图中，把表 A 中的数据导出来的存放位置叫作 tmp_table。这是一个临时表，是在 server 层创建的。 在第四幅图中，根据表 A 重建出来的数据是放在“tmp_file”里的，这个临时文件是 InnoDB 在内部创建出来的。整个 DDL 过程都在 InnoDB 内部完成。对于 server 层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“inplace”名称的来源。 如果你有一个 1TB 的表，现在磁盘间是 1.2TB，能不能做一个 inplace 的 DDL 呢？答案是不能。因为，tmp_file 也是要占用临时空间的。重建表的这个语句 alter table t engine=InnoDB，其实隐含的意思是： alter table t engine=innodb,ALGORITHM=inplace; 跟 inplace 对应的就是拷贝表的方式了，用法是： alter table t engine=innodb,ALGORITHM=copy; 当使用 ALGORITHM=copy 的时候，表示的是强制拷贝表，对应的流程就是第三幅图的操作过程。你可能会觉得，inplace 跟 Online 是不是就是一个意思？其实不是的，只是在重建表这个逻辑中刚好是这样而已。比如，如果要给 InnoDB 表的一个字段加全文索引，写法是： alter table t add FULLTEXT(field_name); 这个过程是 inplace 的，但会阻塞增删改操作，是非 Online 的。如果说这两个逻辑之间的关系是什么的话，可以概括为： DDL 过程如果是 Online 的，就一定是 inplace 的； 反过来未必，也就是说 inplace 的 DDL，有可能不是 Online 的。截止到 MySQ","date":"2025-02-12","objectID":"/posts/13.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E6%8E%89%E4%B8%80%E5%8D%8A%E8%A1%A8%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"13 | 为什么表数据删掉一半，表文件大小不变？","uri":"/posts/13.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E6%8E%89%E4%B8%80%E5%8D%8A%E8%A1%A8%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文讲解了 MySQL 中的 count(*) 语句在不同引擎中有不同的实现方式。","date":"2025-02-12","objectID":"/posts/14.count%E8%BF%99%E4%B9%88%E6%85%A2%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/","tags":["MySQL 实战 45 讲","MySQL"],"title":"14 | count(*) 这么慢，我该怎么办？","uri":"/posts/14.count%E8%BF%99%E4%B9%88%E6%85%A2%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 MySQL 中的 count(*) 语句在不同引擎中有不同的实现方式。MyISAM 引擎直接返回存储在磁盘上的总行数，效率高；而 InnoDB 引擎需要逐行读取数据并累积计数，导致执行速度变慢。针对频繁统计表行数的需求，建议自行计数或使用缓存系统保存计数，如 Redis 服务，但存在数据不一致和丢失更新的问题。 在开发系统的时候，可能经常需要计算一个表的行数，比如一个交易系统的所有变更记录总数。这时候你可能会想，一条 select count(*) from t 语句不就解决了吗？但是，你会发现随着系统中记录数越来越多，这条语句执行得也会越来越慢。count(*) 语句到底是怎样实现的呢？以及 MySQL 为什么会这么实现呢？ 1 count(*) 的实现方式 首先要明确的是，在不同的 MySQL 引擎中，count(*) 有不同的实现方式。 MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。 这里需要注意的是，这篇文章里讨论的是没有过滤条件的 count(*)，如果加了 where 条件的话，MyISAM 表也是不能返回得这么快的。 因为不论是在事务支持、并发能力还是在数据安全方面，InnoDB 都优于 MyISAM。你的表也一定是用了 InnoDB 引擎。这就是当你的记录数越来越多的时候，计算一个表的总行数会越来越慢的原因。那为什么 InnoDB 不跟 MyISAM 一样，也把数字存起来呢？ 这是因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。这里，用一个算 count(*) 的例子来解释一下。 假设表 t 中现在有 10000 条记录，设计了三个用户并行的会话。 会话 A 先启动事务并查询一次表的总行数； 会话 B 启动事务，插入一行后记录后，查询表的总行数； 会话 C 先启动一个单独的语句，插入一行记录后，查询表的总行数。 假设从上到下是按照时间顺序执行的，同一行语句是在同一时刻执行的。 你会看到，在最后一个时刻，三个会话 A、B、C 会同时查询表 t 的总行数，但拿到的结果却不同。这和 InnoDB 的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是 MVCC 来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于 count(*) 请求来说，InnoDB 只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。 当然，现在这个看上去笨笨的 MySQL，在执行 count(*) 操作的时候还是做了优化的。 InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 count(*) 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。 如果你用过 show table status 命令的话，就会发现这个命令的输出结果里面也有一个 TABLE_ROWS 用于显示这个表当前有多少行，这个命令执行挺快的，那这个 TABLE_ROWS 能代替 count(*) 吗？ 索引统计的值是通过采样来估算的。实际上，TABLE_ROWS 就是从这个采样估算得来的，因此它也很不准。有多不准呢，官方文档说误差可能达到 40% 到 50%。所以，show table status 命令显示的行数也不能直接使用。到这里我们小结一下： MyISAM 表虽然 count(*) 很快，但是不支持事务； show table status 命令虽然返回很快，但是不准确； InnoDB 表直接 count(*) 会遍历全表，虽然结果准确，但会导致性能问题。 那么如果你现在有一个页面经常要显示交易系统的操作记录总数，到底应该怎么办呢？答案是，只能自己计数。这些方法的基本思路就是：需要自己找一个地方，把操作记录表的行数存起来。 2 用缓存系统保存计数 对于更新很频繁的库来说，你可能会第一时间想到，用缓存系统来支持。可以用一个 Redis 服务来保存这个表的总行数。这个表每被插入一行 Redis 计数就加 1，每被删除一行 Redis 计数就减 1。这种方式下，读和更新操作都很快，但这种方式存在什么问题吗？没错，缓存系统可能会丢失更新。 Redis 的数据不能永久地留在内存里，所以你会找一个地方把这个值定期地持久化存储起来。但即使这样，仍然可能丢失更新。试想如果刚刚在数据表中插入了一行，Redis 中保存的值也加了 1，然后 Redis 异常重启了，重启后要从存储 redis 数据的地方把这个值读回来，而刚刚加 1 的这个计数操作却丢失了。 当然了，这还是有解的。比如，Redis 异常重启以后，到数据库里面单独执行一次 count(*) 获取真实的行数，再把这个值写回到 Redis 里就可以了。异常重启毕竟不是经常出现的情况，这一次全表扫描的成本，还是可以接受的。 但实际上，将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使 Redis 正常工作，这个值还是逻辑上不精确的。 你可以设想一下有这么一个页面，要显示操作记录的总数，同时还要显示最近操作的 100 条记录。那么，这个页面的逻辑就需要先到 Redis 里面取出计数，再到数据表里面取数据记录。是这么定义不精确的： 一种是，查到的 100 行结果里面有最新插入记录，而 Redis 的计数里还没加 1； 另一种是，查到的 100 行结果里没有最新插入的记录，而 Redis 的计数里已经加了 1。 这两种情况，都是逻辑不一致的。我们一起来看看这个时序图。 上图中，会话 A 是一个插入交易记录的逻辑，往数据表里插入一行 R，然后 Redis 计数加 1；会话 B 就是查询页面显示时需要的数据。 在上图的这个时序里，在 T3 时刻会话 B 来查询的时候，会显示出新插入的 R 这个记录，但是 Redis 的计数还没加 1。这时候，就会出现数据不一致。 你一定会说，这是因为执行新增记录逻辑时候，是先写数据表，再改 Redis 计数。而读的时候是先读 Redis，再读数据表，这个顺序是相反的。那么，如果保持顺序一样的话，是不是就没问题了？现在把会话 A 的更新顺序换一下，再看看执行结果。 这时候反过来了，会话 B 在 T3 时刻查询的时候，Redis 计数加了 1 了，但还查不到新插入的 R 这一行，也是数据不一致的情况。 在并发系统里面，无法精确控制不同线程的执行时刻的，因为存在图中的这种操作序列，所以，即使 Redis 正常工作，这个计数值还是逻辑上不精确的。 3 在数据库保存计数 根据上面的分析，用缓存系统保存计数有丢失数据和计数不精确的问题。那么，如果把这个计数直接放到数据库里单独的一张计数表 C 中，又会怎么样呢？首先，这解决了崩溃丢失的问题，InnoDB 是支持崩溃恢复不丢数据的。然后，再看看能不能解决计数不精确的问题。 由于 InnoDB 要支持事务，从而导致 InnoDB 表不能把 count(*) 直接存起来，然后查询的时候直接返回形成的。所谓以子之矛攻子之盾，现在就利用“事务”这个特性，把问题解决掉。 我们来看下现在的执行结果。虽然会话 B 的读操作仍然是在 T3 执行的，但是因为这时候更新事务还没有提交，所以计数值加 1 这个操作对会话 B 还不可见。因此，会话 B 看到的结果里，查计数值和“最近 100 条记录”看到的结果，逻辑上就是一致的。 4 不同的 count 用法 在 select count(?) from t 这样的查询语句里面，count(*)、count(主键 id)、count(字段) 和 count(1) 等不同用法的性能，有哪些差别。需要注意的是，下面的讨论还是基于 InnoDB 引擎的。 这里，首先你要弄清楚 count() 的语义。count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。 所以，count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。至于分析性能差别的时候，可以记住这么几个原则： server 层要什么就给什么； InnoDB 只给必要的值； 现在的优化器只优化了 count(*) 的语义为“取行数”，其他“显而易见”的优化并没有做。 对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。 对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。 单看这两个用法的差别的话，能对比出来，count(1) 执行得要比 count(主键 id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。 对于 count(字段) 来说： 如果这个“字段”是定义为 not null ","date":"2025-02-12","objectID":"/posts/14.count%E8%BF%99%E4%B9%88%E6%85%A2%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"14 | count(*) 这么慢，我该怎么办？","uri":"/posts/14.count%E8%BF%99%E4%B9%88%E6%85%A2%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文通过对 InnoDB 的工作机制进行比喻，解释了数据库“抖动”现象的原因。","date":"2025-02-12","objectID":"/posts/12.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84mysql%E4%BC%9A%E6%8A%96%E4%B8%80%E4%B8%8B/","tags":["MySQL 实战 45 讲","MySQL"],"title":"12 | 为什么我的 MySQL 会“抖”一下？","uri":"/posts/12.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84mysql%E4%BC%9A%E6%8A%96%E4%B8%80%E4%B8%8B/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文通过对 InnoDB 的工作机制进行比喻，解释了数据库“抖动”现象的原因。首先介绍了 InnoDB 的 WAL 机制，即写日志和内存数据页的刷新过程，分析了导致数据库刷新过程的几种情况，如 redo log 写满、系统内存不足等。指出这些情况会明显影响数据库性能，尤其是当查询需要淘汰大量脏页或者日志写满时，会导致查询响应时间明显变长甚至更新操作完全堵塞。最后，提到 InnoDB 需要有控制脏页比例的机制来尽量避免性能问题的发生。 平时的工作中，你可能遇到过这样的场景，一条 SQL 语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。看上去，这就像是数据库“抖”了一下。 1 你的 SQL 语句为什么变“慢”了 InnoDB 在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志叫作 redo log（重做日志），在更新内存写完 redo log 后，就返回给客户端，本次更新成功。 做下类比的话，掌柜记账的账本是数据文件，记账用的粉板是日志文件（redo log），掌柜的记忆就是内存。 掌柜总要找时间把账本更新一下，这对应的就是把内存里的数据写入磁盘的过程，术语就是 flush。在这个 flush 操作执行之前，孔乙己的赊账总额，其实跟掌柜手中账本里面的记录是不一致的。因为孔乙己今天的赊账金额还只在粉板上，而账本里的记录是老的，还没把今天的赊账算进去。 当内存数据页跟磁盘数据页内容不一致的时候，称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。不论是脏页还是干净页，都在内存中。在这个例子里，内存对应的就是掌柜的记忆。 接下来，用一个示意图来展示一下“孔乙己赊账”的整个操作过程。假设原来孔乙己欠账 10 文，这次又要赊 9 文。 回到文章开头的问题，平时执行很快的更新操作，其实就是在写内存和日志，而 MySQL 偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。那么，什么情况会引发数据库的 flush 过程呢？ 还是继续用咸亨酒店掌柜的这个例子，想一想：掌柜在什么情况下会把粉板上的赊账记录改到账本上？ 第一种场景是，粉板满了，记不下了。这时候如果再有人来赊账，掌柜就只得放下手里的活儿，将粉板上的记录擦掉一些，留出空位以便继续记账。当然在擦掉之前，他必须先将正确的账目记录到账本中才行。这个场景，对应的就是 InnoDB 的 redo log 写满了。这时候系统会停止所有更新操作，把 checkpoint 往前推进，redo log 留出空间可以继续写。checkpoint 可不是随便往前修改一下位置就可以的。比如下图中，把 checkpoint 位置从 CP 推进到 CP’，就需要将两个点之间的日志（浅绿色部分），对应的所有脏页都 flush 到磁盘上。之后，图中从 write pos 到 CP’之间就是可以再写入的 redo log 的区域。 第二种场景是，这一天生意太好，要记住的事情太多，掌柜发现自己快记不住了，赶紧找出账本把孔乙己这笔账先加进去。这种场景，对应的就是系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。这时候难道不能直接把内存淘汰掉，下次需要请求的时候，从磁盘读入数据页，然后拿 redo log 出来应用不就行了？这里其实是从性能考虑的。如果刷脏页一定会写盘，就保证了每个数据页有两种状态： 一种是内存里存在，内存里就肯定是正确的结果，直接返回； 另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。这样的效率最高。 第三种场景是，生意不忙的时候，或者打烊之后。这时候柜台没事，掌柜闲着也是闲着，不如更新账本。这种场景，对应的就是 MySQL 认为系统“空闲”的时候。当然，MySQL“这家酒店”的生意好起来可是会很快就能把粉板记满的，所以“掌柜”要合理地安排时间，即使是“生意好”的时候，也要见缝插针地找时间，只要有机会就刷一点“脏页”。 第四种场景是，年底了咸亨酒店要关门几天，需要把账结清一下。这时候掌柜要把所有账都记到账本上，这样过完年重新开张的时候，就能就着账本明确账目情况了。这种场景，对应的就是 MySQL 正常关闭的情况。这时候，MySQL 会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。 接下来可以分析一下上面四种场景对性能的影响。 其中，第三种情况是属于 MySQL 空闲时的操作，这时系统没什么压力，而第四种场景是数据库本来就要关闭了。这两种情况下也不会太关注“性能”问题。所以这里，主要来分析一下前两种场景下的性能问题。 第一种是“redo log 写满了，要 flush 脏页”，这种情况是 InnoDB 要尽量避免的。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果从监控上看，这时候更新数会跌为 0。 第二种是“内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态： 第一种是，还没有使用的； 第二种是，使用了并且是干净页； 第三种是，使用了并且是脏页。 InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的： 一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长； 日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的。 所以，InnoDB 需要有控制脏页比例的机制，来尽量避免上面的这两种情况。 2 InnoDB 刷脏页的控制策略 首先，你要正确地告诉 InnoDB 所在主机的 IO 能力，这样 InnoDB 才能知道需要全力刷脏页的时候，可以刷多快。 这就要用到 innodb_io_capacity 这个参数了，它会告诉 InnoDB 你的磁盘能力。这个值建议设置成磁盘的 IOPS。磁盘的 IOPS 可以通过 fio 这个工具来测试，下面的语句是用来测试磁盘随机读写的命令： fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest 其实，因为没能正确地设置 innodb_io_capacity 参数，而导致的性能问题也比比皆是。如果说你的 MySQL 的写入速度很慢，TPS 很低，但是数据库主机的 IO 压力并不大。很可能罪魁祸首就是这个参数的设置出了问题。 假如你的主机磁盘用的是 SSD，但是 innodb_io_capacity 的值设置的是 300。于是，InnoDB 认为这个系统的能力就这么差，所以刷脏页刷得特别慢，甚至比脏页生成的速度还慢，这样就造成了脏页累积，影响了查询和更新性能。 虽然现在已经定义了“全力刷脏页”的行为，但平时总不能一直是全力刷吧？毕竟磁盘能力不能只用来刷脏页，还需要服务用户请求。所以接下来，我们看看 InnoDB 怎么控制引擎按照“全力”的百分比来刷脏页。试想一下，如果你来设计策略控制刷脏页的速度，会参考哪些因素呢？ 这个问题可以这么想，如果刷太慢，会出现什么情况？首先是内存脏页太多，其次是 redo log 写满。所以，InnoDB 的刷盘速度就是要参考这两个因素：一个是脏页比例，一个是 redo log 写盘速度。InnoDB 会根据这两个因素先单独算出两个数字。 参数 innodb_max_dirty_pages_pct 是脏页比例上限，默认值是 75%。InnoDB 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字，计算这个数字的伪代码类似这样： F1(M) { if M\u003e=innodb_max_dirty_pages_pct then return 100; return 100*M/innodb_max_dirty_pages_pct; } InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，假设为 N。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公式可以记为 F2(N)。F2(N) 算法比较复杂，你只要知道 N 越大，算出来的值越大就好了。 然后，根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R，之后引擎就可以按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度。上述的计算流程比较抽象，不容易理解，下面是一个简单的流程图。图中的 F1、F2 就是上面通过脏页比例和 redo log 写入速度算出来的两个值。 InnoDB 会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用 IO 资源并可能影响","date":"2025-02-12","objectID":"/posts/12.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84mysql%E4%BC%9A%E6%8A%96%E4%B8%80%E4%B8%8B/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"12 | 为什么我的 MySQL 会“抖”一下？","uri":"/posts/12.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84mysql%E4%BC%9A%E6%8A%96%E4%B8%80%E4%B8%8B/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文介绍了如何给字符串字段加索引以及前缀索引对查询性能的影响。","date":"2025-02-12","objectID":"/posts/11.%E6%80%8E%E4%B9%88%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95/","tags":["MySQL 实战 45 讲","MySQL"],"title":"11 | 怎么给字符串字段加索引？","uri":"/posts/11.%E6%80%8E%E4%B9%88%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文介绍了如何给字符串字段加索引以及前缀索引对查询性能的影响。首先，文章讨论了在支持邮箱登录的系统中，如何在邮箱字段上建立合理的索引。通过对比全字段索引和前缀索引的执行过程，阐述了前缀索引可能增加查询成本的情况。接着，文章提出了确定前缀长度的方法，即通过统计索引上不同值的数量来选择合适的前缀长度。 现在，几乎所有的系统都支持邮箱登录，那如何在邮箱这样的字段上建立合理的索引呢？假设，你现在维护一个支持邮箱登录的系统，用户表是这么定义的： mysql\u003e create table SUser( ID bigint unsigned primary key, email varchar(64), ... )engine=innodb; 由于要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句： mysql\u003e select f1, f2 from SUser where email='xxx'; 如果 email 这个字段上没有索引，那么这个语句就只能做全表扫描。同时，MySQL 是支持前缀索引的，也就是说，可以定义字符串的一部分作为索引。默认地，如果创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。比如，这两个在 email 字段上创建索引的语句： mysql\u003e alter table SUser add index index1(email); 或 mysql\u003e alter table SUser add index index2(email(6)); 第一个语句创建的 index1 索引里面，包含了每个记录的整个字符串；而第二个语句创建的 index2 索引里面，对于每个记录都是只取前 6 个字节。那么，这两种不同的定义在数据结构和存储上有什么区别呢？如下面两幅图所示，就是这两个索引的示意图。 从图中可以看到，由于 email(6) 这个索引结构中每个邮箱字段都只取前 6 个字节（即：zhangs），所以占用的空间会更小，这就是使用前缀索引的优势。但，这同时带来的损失是，可能会增加额外的记录扫描次数。接下来，再看看下面这个语句，在这两个索引定义下分别是怎么执行的。 select id,name,email from SUser where email='zhangssxyz@xxx.com'; 如果使用的是 index1（即 email 整个字符串的索引结构），执行顺序是这样的： 从 index1 索引树找到满足索引值是’zhangssxyz@xxx.com’的这条记录，取得 ID2 的值； 到主键上查到主键值是 ID2 的行，判断 email 的值是正确的，将这行记录加入结果集； 取 index1 索引树上刚刚查到的位置的下一条记录，发现已经不满足 email='zhangssxyz@xxx.com’的条件了，循环结束。 这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。 如果使用的是 index2（即 email(6) 索引结构），执行顺序是这样的： 从 index2 索引树找到满足索引值是’zhangs’的记录，找到的第一个是 ID1； 到主键上查到主键值是 ID1 的行，判断出 email 的值不是’zhangssxyz@xxx.com’，这行记录丢弃； 取 index2 上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出 ID2，再到 ID 索引上取整行然后判断，这次值对了，将这行记录加入结果集； 重复上一步，直到在 idxe2 上取到的值不是’zhangs’时，循环结束。 在这个过程中，要回主键索引取 4 次数据，也就是扫描了 4 行。通过这个对比，很容易就可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变多。 但是，对于这个查询语句来说，如果定义的 index2 不是 email(6) 而是 email(7），也就是说取 email 字段的前 7 个字节来构建索引的话，即满足前缀’zhangss’的记录只有一个，也能够直接查到 ID2，只扫描一行就结束了。 也就是说使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。于是，就有个问题：当要给字符串创建前缀索引时，有什么方法能够确定应该使用多长的前缀呢？ 实际上，在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。首先，可以使用下面这个语句，算出这个列上有多少个不同的值： mysql\u003e select count(distinct email) as L from SUser; 然后，依次选取不同长度的前缀来看这个值，比如要看一下 4~7 个字节的前缀索引，可以用这个语句： mysql\u003e select count(distinct left(email,4)）as L4, count(distinct left(email,5)）as L5, count(distinct left(email,6)）as L6, count(distinct left(email,7)）as L7, from SUser; 当然，使用前缀索引很可能会损失区分度，所以需要预先设定一个可以接受的损失比例，比如 5%。然后，在返回的 L4~L7 中，找出不小于 L * 95% 的值，假设这里 L6、L7 都满足，就可以选择前缀长度为 6。 1 前缀索引对覆盖索引的影响 前面说了使用前缀索引可能会增加扫描行数，这会影响到性能。其实，前缀索引的影响不止如此，再看一下另外一个场景。先来看看这个 SQL 语句： select id,email from SUser where email='zhangssxyz@xxx.com'; 与前面例子中的 SQL 语句 select id,name,email from SUser where email='zhangssxyz@xxx.com'; 相比，这个语句只要求返回 id 和 email 字段。 所以，如果使用 index1（即 email 整个字符串的索引结构）的话，可以利用覆盖索引，从 index1 查到结果后直接就返回了，不需要回到 ID 索引再去查一次。而如果使用 index2（即 email(6) 索引结构）的话，就不得不回到 ID 索引再去判断 email 字段的值。 即使你将 index2 的定义修改为 email(18) 的前缀索引，这时候虽然 index2 已经包含了所有的信息，但 InnoDB 还是要回到 id 索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。 也就是说，使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是在选择是否使用前缀索引时需要考虑的一个因素。 2 其他方式 对于类似于邮箱这样的字段来说，使用前缀索引的效果可能还不错。但是，遇到前缀的区分度不够好的情况时，要怎么办呢？ 比如，我们国家的身份证号，一共 18 位，其中前 6 位是地址码，所以同一个县的人的身份证号前 6 位一般会是相同的。假设维护的数据库是一个市的公民信息系统，这时候如果对身份证号做长度为 6 的前缀索引的话，这个索引的区分度就非常低了。 按照前面说的方法，可能需要创建长度为 12 以上的前缀索引，才能够满足区分度要求。但是，索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。 那么，如果能够确定业务需求里面只有按照身份证进行等值查询的需求，还有没有别的处理方法呢？这种方法，既可以占用更小的空间，也能达到相同的查询效率。答案是，有的。 第一种方式是使用倒序存储。如果存储身份证号的时候把它倒过来存，每次查询的时候，可以这么写： mysql\u003e select field_list from t where id_card = reverse('input_id_card_string'); 由于身份证号的最后 6 位没有地址码这样的重复逻辑，所以最后这 6 位很可能就提供了足够的区分度。当然了，实践中不要忘记使用 count(distinct) 方法去做个验证。 第二种方式是使用 hash 字段。可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。 mysql\u003e alter table t add id_card_crc int unsigned, add index(id_card_crc); 然后每次插入新记录的时候，都同时用 crc32() 这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过 crc32() 函数得到的结果可能是相同的，所以查询语句 where 部分要判断 id_card 的值是否精确相同。 mysql\u003e select field_list from t where id_card_crc=crc32('input_id_card_string') and id_card='input_id_card_string' 这样，索引的长度变成了 4 个字节，比原来小了很多。接下来，再一起看看使用倒序存储和使用 hash 字段这两种方法的异同点。 首先，它们的相同点是，都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X, ID_Y]的所有市民了。同样地，hash 字段的方式也只能支持等值查询。 它们的区别，主要体现在以下三个方面： 从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的","date":"2025-02-12","objectID":"/posts/11.%E6%80%8E%E4%B9%88%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"11 | 怎么给字符串字段加索引？","uri":"/posts/11.%E6%80%8E%E4%B9%88%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入探讨了 MySQL 索引选择问题，通过一个案例展示了错误的索引选择可能导致查询性能下降的情况。","date":"2025-02-12","objectID":"/posts/10.mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95/","tags":["MySQL 实战 45 讲","MySQL"],"title":"10 | MySQL 为什么有时候会选错索引？","uri":"/posts/10.mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入探讨了 MySQL 索引选择问题，通过一个案例展示了错误的索引选择可能导致查询性能下降的情况。首先介绍了一个简单的表结构和插入数据的存储过程，然后展示了一条查询语句的执行情况。通过对表进行数据操作后再次执行相同的查询语句，发现 MySQL 选择了错误的索引，导致了性能下降。 在 MySQL 中一张表其实是可以支持多个索引的。但是写 SQL 语句的时候，并没有主动指定使用哪个索引。也就是说，使用哪个索引是由 MySQL 来确定的。你有没有碰到过这种情况，一条本来可以执行得很快的语句，却由于 MySQL 选错了索引，而导致执行速度变得很慢？ 举个例子，先建一个简单的表，表里有 a、b 两个字段，并分别建上索引： CREATE TABLE `t` ( `id` int(11) NOT NULL AUTO_INCREMENT, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `a` (`a`), KEY `b` (`b`) ) ENGINE=InnoDB; 然后，往表 t 中插入 10 万行记录，取值按整数递增，即：(1,1,1)，(2,2,2)，(3,3,3) 直到 (100000,100000,100000)。用存储过程来插入数据的。 delimiter ;; create procedure idata() begin declare i int; set i=1; while(i\u003c=100000)do insert into t values(i, i, i); set i=i+1; end while; end;; delimiter ; call idata(); 接下来，我们分析一条 SQL 语句： mysql\u003e select * from t where a between 10000 and 20000; 你一定会说，这个语句还用分析吗，很简单呀，a 上有索引，肯定是要使用索引 a 的。下图显示的就是使用 explain 命令看到的这条语句的执行情况。 从上图看上去，这条查询语句的执行也确实符合预期，key 这个字段值是’a’，表示优化器选择了索引 a。不过别急，这个案例不会这么简单。在已经准备好的包含了 10 万行数据的表上，再做如下操作。 这里，session A 的操作就是开启了一个事务。随后，session B 把数据都删除后，又调用了 idata 这个存储过程，插入了 10 万行数据。 这时候，session B 的查询语句 select * from t where a between 10000 and 20000 就不会再选择索引 a 了。可以通过慢查询日志（slow log）来查看一下具体的执行情况。 为了说明优化器选择的结果是否正确，增加了一个对照，即：使用 force index(a) 来让优化器强制使用索引 a。下面的三条 SQL 语句，就是这个实验过程。 set long_query_time=0; select * from t where a between 10000 and 20000; /*Q1*/ select * from t force index(a) where a between 10000 and 20000;/*Q2*/ 第一句，是将慢查询日志的阈值设置为 0，表示这个线程接下来的语句都会被记录入慢查询日志中； 第二句，Q1 是 session B 原来的查询； 第三句，Q2 是加了 force index(a) 来和 session B 原来的查询语句执行情况对比。 如下图所示是这三条 SQL 语句执行完成后的慢查询日志。 可以看到，Q1 扫描了 10 万行，显然是走了全表扫描，执行时间是 40 毫秒。Q2 扫描了 10001 行，执行了 21 毫秒。也就是说，在没有使用 force index 的时候，MySQL 用错了索引，导致了更长的执行时间。这个例子对应的是平常不断地删除历史数据和新增数据的场景。这时，MySQL 就会选错索引。 1 优化器的逻辑 选择索引是优化器的工作。而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。 当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。这个简单的查询语句并没有涉及到临时表和排序，所以 MySQL 选错索引肯定是在判断扫描行数的时候出问题了。那么，问题就是：扫描行数是怎么判断的？ MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。 这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。 可以使用 show index 方法，看到一个索引的基数。如下图所示，就是表 t 的 show index 的结果。虽然这个表的每一行的三个字段值都是一样的，但是在统计信息中，这三个索引的基数值并不同，而且其实都不准确。 那么，MySQL 是怎样得到索引的基数的呢？这里简单介绍一下 MySQL 采样统计的方法。为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。 采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。 而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。 在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数 innodb_stats_persistent 的值来选择： 设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。 设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。 由于是采样统计，所以不管 N 是 20 还是 8，这个基数都是很容易不准的。但，这还不是全部。可以从上图中看到，这次的索引统计值（cardinality 列）虽然不够精确，但大体上还是差不多的，选错索引一定还有别的原因。 其实索引统计只是一个输入，对于一个具体的语句来说，优化器还要判断，执行这个语句本身要扫描多少行。接下来，再看看优化器预估的，这两个语句的扫描行数是多少。 rows 这个字段表示的是预计扫描行数。 其中，Q1 的结果还是符合预期的，rows 的值是 104620；但是 Q2 的 rows 值是 37116，偏差就大了。而图 1 中我们用 explain 命令看到的 rows 是只有 10001 行，是这个偏差误导了优化器的判断。 到这里，可能你的第一个疑问不是为什么不准，而是优化器为什么放着扫描 37000 行的执行计划不用，却选择了扫描行数是 100000 的执行计划呢？ 这是因为，如果使用索引 a，每次从索引 a 上拿到一个值，都要回到主键索引上查出整行数据，这个代价优化器也要算进去的。而如果选择扫描 10 万行，是直接在主键索引上扫描的，没有额外的代价。 优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执行时间看来，这个选择并不是最优的。 使用普通索引需要把回表的代价算进去，在第一幅图中执行 explain 的时候，也考虑了这个策略的代价，但第一幅图中的选择是对的。也就是说，这个策略并没有问题。 所以冤有头债有主，MySQL 选错索引，这件事儿还得归咎到没能准确地判断出扫描行数。至于为什么会得到错误的扫描行数。既然是统计信息不对，那就修正。analyze table t 命令，可以用来重新统计索引信息。 这回对了。所以在实践中，如果发现 explain 的结果预估的 rows 值跟实际情况差距比较大，可以采用这个方法来处理。其实，如果只是索引统计不准确，通过 analyze 命令可以解决很多问题，但是优化器可不止是看扫描行数。依然是基于这个表 t，看看另外一个语句： mysql\u003e select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 1; 从条件上看，这个查询没有符合条件的记录，因此会返回空集合。在开始执行这条语句之前，可以先设想一下，如果你来选择索引，会选择哪一个呢？为了便于分析，先来看一下 a、b 这两个索引的结构图。 如果使用索引 a 进行查询，那么就是扫描索引 a 的前 1000 个值，然后取到对应的 id，再到主键索引上去查出每一行，然后根据字段 b 来过滤。显然这样需要扫描 1000 行。 如果使用索引 b 进行查询，那么就是扫描索引 b 的最后 50001 个值，与上面的执行过程相同，也是需要回到主键索引上取值再判断，所以需要扫描 50001 行。 所以你一定会想，如果使用索引 a 的话，执行速度明显会快很多。那么，下面就来看看到底是不是这么一回事儿。下图是执行 explain 的结果。 mysql\u003e explain select * from t wh","date":"2025-02-12","objectID":"/posts/10.mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"10 | MySQL 为什么有时候会选错索引？","uri":"/posts/10.mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95/"},{"categories":["Golang"],"content":"了解下 Go 语言中如何访问私有成员。","date":"2025-02-12","objectID":"/posts/1.go%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98/","tags":["Golang"],"title":"1.Go 语言中如何访问私有成员？","uri":"/posts/1.go%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98/"},{"categories":["Golang"],"content":" 摘要 本文主要探讨了 Go 语言中如何访问私有成员？ 1 答案 在 Go 语言中，以小写字母开头的标识符是私有成员，私有成员（字段、方法、函数等）遵循语言的可见性规则，仅在定义它的包内可见，包外无法访问这些私有成员。如果想要访问私有成员，主要包括以下三种方式： 在同一个包内，可以直接访问小写字母开头的私有成员。 在其他包中，无法直接访问私有成员，但可以通过公开的接口来间接访问私有成员。 使用反射来绕过 Go 语言的封装机制访问和修改私有字段。（不建议使用） 2 扩展知识 2.1 访问私有成员的规则 可见性规则： 私有成员：以小写字母开头的标识符是私有的，仅在定义它的包内可见。包外无法访问这些私有成员。 公开成员：以大写字母开头的标识符是公开的，可以在任何包中访问。 示例代码 1）私有成员的访问（包内） package example // 结构体定义，字段 age 是私有的 type Person struct { name string age int } // 包内函数，能够访问私有字段 func NewPerson(name string, age int) Person { return Person{name: name, age: age} } func GetPersonAge(p Person) int { return p.age } 2）通过公开方法访问私有成员（包外） package main import ( \"fmt\" \"example\" // 假设 example 是定义 Person 的包 ) func main() { p := example.NewPerson(\"John\", 30) // 不能直接访问 p.age，因为 age 是私有的 // fmt.Println(p.age) // 编译错误 // 可以通过包内公开的函数访问私有成员 age := example.GetPersonAge(p) fmt.Println(\"Age:\", age) // 输出: Age: 30 } 3）通过反射访问私有成员 在 Go 语言中，可以使用反射（reflect 包）来访问和修改私有字段。虽然直接访问私有字段违背了封装原则，但反射提供了这种能力。 package main import ( \"fmt\" \"reflect\" ) type Person struct { name string age int } func main() { p := Person{name: \"John\", age: 30} // 获取指向 p 的指针的反射值，Elem 方法用于获取指针指向的值。 v := reflect.ValueOf(\u0026p).Elem() // 获取私有字段 name nameField := v.FieldByName(\"name\") fmt.Println(\"name (private):\", nameField.String()) } 或 package main import ( \"fmt\" \"reflect\" \"unsafe\" ) type Person struct { name string age int } func main() { p := Person{name: \"John\", age: 30} // 获取指向 p 的指针的反射值，Elem 方法用于获取指针指向的值。 value := reflect.ValueOf(\u0026p).Elem() // 通过 FieldByName 方法获取私有字段的值 field := value.FieldByName(\"name\") // 使用 unsafe.Pointer 和反射来操作私有字段 realField := reflect.NewAt(field.Type(), unsafe.Pointer(field.UnsafeAddr())).Elem() // 输出私有字段的值 fmt.Println(\"name (private):\", realField.String()) } 注意点： 安全性：虽然可以通过反射访问和修改私有字段，但这种做法可能导致程序设计上的问题，破坏了封装性。因此，应谨慎使用，并尽量避免在生产代码中使用这种技术，除非确实有必要。 性能：反射操作通常比直接访问字段要慢，因此在性能敏感的代码中应避免频繁使用反射。 ","date":"2025-02-12","objectID":"/posts/1.go%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98/:0:0","tags":["Golang"],"title":"1.Go 语言中如何访问私有成员？","uri":"/posts/1.go%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入探讨了普通索引和唯一索引在不同业务场景下的选择，重点从性能角度对比了它们在查询和更新语句中的影响。","date":"2025-02-11","objectID":"/posts/9.%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9/","tags":["MySQL 实战 45 讲","MySQL"],"title":"09 | 普通索引和唯一索引，应该怎么选择？","uri":"/posts/9.%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入探讨了普通索引和唯一索引在不同业务场景下的选择，重点从性能角度对比了它们在查询和更新语句中的影响。在查询过程中，普通索引需要额外的查找和判断操作，但由于 InnoDB 的数据是按数据页为单位读写，性能差距微乎其微。而在更新过程中，普通索引可以利用 change buffer 来减少磁盘读取，从而提升性能。 在不同的业务场景下，应该选择普通索引，还是唯一索引？假设你在维护一个市民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了不会写入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的 SQL 语句： select name from CUser where id_card = 'xxxxxxxyyyyyyzzzzz'; 所以，你一定会考虑在 id_card 字段上建索引。由于身份证号字段比较大，不建议你把身份证号当做主键，那么现在有两个选择，要么给 id_card 字段创建唯一索引，要么创建一个普通索引。如果业务代码已经保证了不会写入重复的身份证号，那么这两个选择逻辑上都是正确的。那么，从性能的角度考虑，选择唯一索引还是普通索引呢？选择的依据是什么呢？ 接下来，就从这两种索引对查询语句和更新语句的性能影响来进行分析。 1 查询过程 假设，执行查询的语句是 select id from T where k=5。这个查询语句在索引树上查找的过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。 对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。 那么，这个不同带来的性能差距会有多少呢？答案是，微乎其微。 InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。 因为引擎是按页读写的，所以说，当找到 k=5 的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。 当然，如果 k=5 这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。 但是之前计算过，对于整型字段，一个数据页可以放近千个 key，因此出现这种情况的概率会很低。所以，计算平均性能差异时，仍可以认为这个操作成本对于现在的 CPU 来说可以忽略不计。 2 更新过程 为了说明普通索引和唯一索引对更新语句性能的影响这个问题，需要你介绍一下 change buffer。 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。 需要说明的是，虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。 将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。 显然，如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率。那么，什么条件下可以使用 change buffer 呢？ 对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k=4 的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。 因此，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。 change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。 现在我们再一起来看看如果要在这张表中插入一个新记录 (4,400) 的话，InnoDB 的处理流程是怎样的。 第一种情况是，这个记录要更新的目标页在内存中。这时，InnoDB 的处理流程如下： 对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束； 对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。 这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。 第二种情况是，这个记录要更新的目标页不在内存中。这时，InnoDB 的处理流程如下： 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束； 对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。 将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。 3 change buffer 的使用场景 通过上面的分析，你已经清楚了使用 change buffer 对更新过程的加速作用，也清楚了 change buffer 只限于用在普通索引的场景下，而不适用于唯一索引。那么，现在有一个问题就是：普通索引的所有场景，使用 change buffer 都可以起到加速作用吗？ 因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。 因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。 反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。 4 索引选择和实践 普通索引和唯一索引应该怎么选择。其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，建议你尽量选择普通索引。如果所有的更新后面，都马上伴随着对这个记录的查询，那你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。 在实际使用中，你会发现，普通索引和 change buffer 的配合使用，对于数据量大的表的更新优化还是很明显的。 特别地，在使用机械硬盘时，change buffer 这个机制的收效是非常显著的。所以，当有一个类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，应该特别关注这些表里的索引，尽量使用普通索引，然后把 change buffer 尽量开大，以确保这个“历史数据”表的数据写入速度。 5 change buffer 和 redo log 理解了 change buffer 的原理，可能会联想到前面文章中介绍过的 redo log 和 WAL。WAL 提升性能的核心机制，也的确是尽量减少随机读写，这两个概念确实容易混淆。所以，这里把它们放到了同一个流程里来说明，便于区分这两个概念。现在，要在表上执行这个插入语句： mysql\u003e insert into t(id,k) values(id1,k1),(id2,k2); 这里，假设当前 k 索引树的状态，查找到位置后，k1 所在的数据页在内存 (InnoDB buffer pool) 中，k2 所在的数据页不在内存中。如下图所示是带 change buffer 的更新状态图。 分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、数据表空间（t.ibd）、系统表空间（ibdata1）。这条更新语句做了如下的操作（按照图中的数字顺序）： Page 1 在内存中，直接更新内存； Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息 将上述两个动作记入 redo log 中（图中 3 和 4）。 做完上面这些，事务就可以完成了。所以","date":"2025-02-11","objectID":"/posts/9.%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"09 | 普通索引和唯一索引，应该怎么选择？","uri":"/posts/9.%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入探讨了事务隔离级别对于事务可见性的影响，并重点介绍了可重复读隔离级别下的事务视图和行锁的概念。","date":"2025-02-11","objectID":"/posts/8.%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84/","tags":["MySQL 实战 45 讲","MySQL"],"title":"08 | 事务到底是隔离的还是不隔离的？","uri":"/posts/8.%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入探讨了事务隔离级别对于事务可见性的影响，并重点介绍了可重复读隔离级别下的事务视图和行锁的概念。文章详细解释了在 MySQL 中 MVCC 实现时使用的一致性读视图的概念，以及 InnoDB 如何利用多版本数据实现“秒级创建快照”的能力。 如果是可重复读隔离级别，事务 T 启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数据，事务 T 看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。 但是一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？ 举一个例子，下面是一个只有两行的表的初始化语句。 mysql\u003e CREATE TABLE `t` ( `id` int(11) NOT NULL, `k` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB; insert into t(id, k) values(1,1),(2,2); 这里，需要注意的是事务的启动时机。begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。 第一种启动方式，一致性视图是在执行第一个快照读语句时创建的； 第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。 例子中如果没有特别说明，都是默认 autocommit=1。在这个例子中，事务 C 没有显式地使用 begin/commit，表示这个 update 语句本身就是一个事务，语句完成的时候会自动提交。事务 B 在更新了行之后查询 ; 事务 A 在一个只读事务中查询，并且时间顺序上是在事务 B 的查询之后。此时事务 B 查到的 k 的值是 3，而事务 A 查到的 k 的值是 1。 在 MySQL 里，有两个“视图”的概念： 一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。 另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。它没有物理结构，作用是事务执行期间用来定义“能看到什么数据”。 1 “快照”在 MVCC 里是怎么工作的？ 在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。这时，你会说这看上去不太现实啊。如果一个库有 100G，那么启动一个事务，MySQL 就要拷贝 100G 的数据出来，这个过程得多慢啊。可是，平时的事务执行起来很快啊。实际上，并不需要拷贝出这 100G 的数据。先来看看这个快照是怎么实现的。 InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。 而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。 也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。如下图所示，就是一个记录被多个事务连续更新后的状态。 图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25。 语句更新会生成 undo log（回滚日志），那么，undo log 在哪呢？实际上，图 中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。 明白了多版本和 row trx_id 的概念后，再来想一下，InnoDB 是怎么定义那个“100G”的快照的。按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。 因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。 当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。 在实现上，InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。 这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。这个视图数组把所有的 row trx_id 分成了几种不同的情况。 这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能： 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的； 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的； 如果落在黄色部分，那就包括两种情况 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见； 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。 举例说明：黄色区间是包含了已经提交的事务的，已经提交的事务的 id 可以比最低水位大，但小于最高水位。比如，有 5，6，7，8，9 这 5 个事务，9 是当前事务，5，6，8 是正在执行中的事务，7 是已经提交的事务 id。那么当前视图数组是[5 6 8 9]，最低水位是 5，最高水位是 10。事务 7 落在落在黄色区间，不在数组中，但已提交，所以也可见。 比如对于上图中的数据来说，如果有一个事务，它的低水位是 18，那么当它访问这一行数据时，就会从 V4 通过 U3 计算出 V3，所以在它看来，这一行的值是 11。 有了这个声明后，系统里面随后发生的更新，是不是就跟这个事务看到的内容无关了呢？因为之后的更新，生成的版本一定属于上面的 2 或者 3(a) 的情况，而对它来说，这些新的数据版本是不存在的，所以这个事务的快照，就是“静态”的了。 所以你现在知道了，InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。接下来，继续看一下第一幅图中的三个事务，分析下事务 A 的语句返回的结果，为什么是 k=1。这里，我们做如下假设： 事务 A 开始前，系统里面只有一个活跃事务 ID 是 99； 事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务； 三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。 这样，事务 A 的视图数组就是[99,100], 事务 B 的视图数组是[99,100,101], 事务 C 的视图数组是[99,100,101,102]。 为了简化分析，先把其他干扰语句去掉，只画出跟事务 A 查询逻辑有关的操作： 从图中可以看到，第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。 第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102 又成为了历史版本。 在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。但这个版本对事务 A 必须是不可见的，否则就变成脏读了。 现在事务 A 要来读数据了，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起的。所以，事务 A 查询语句的读数据流程是这样的： 找到 (1,3) 的时候，判断出 row trx_id=101，比高水位大，处于红色区域，不可见； 接着，找到上一个历史版本，一看 row trx_id=102，比高水位大，处于红色区域，不可见； 再往前找，终于找到了（1,1)，它的 row trx_id=90，比低水位小，处于绿色区域，可见。 这样执行下来，虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以称之为一致性读。这个判断规则是从代码逻辑直接转译过来的，但是正如你所见，用于人肉分析可见性很麻烦。 所以需要翻译一下。一个数据版本","date":"2025-02-11","objectID":"/posts/8.%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"08 | 事务到底是隔离的还是不隔离的？","uri":"/posts/8.%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文主要讨论了 MySQL 的行锁对数据库性能的影响以及如何通过合理的事务设计来减少锁冲突，提升并发度。","date":"2025-02-11","objectID":"/posts/7.%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91%E8%A1%8C%E9%94%81%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/","tags":["MySQL 实战 45 讲","MySQL"],"title":"07 | 行锁功过：怎么减少行锁对性能的影响？","uri":"/posts/7.%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91%E8%A1%8C%E9%94%81%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文主要讨论了 MySQL 的行锁对数据库性能的影响以及如何通过合理的事务设计来减少锁冲突，提升并发度。文章首先介绍了行锁的概念和两阶段锁协议，强调了行锁在事务结束时才会释放的特点。通过一个电影票在线交易业务的例子，说明了如何合理安排事务中的操作顺序以减少锁等待，提升并发度。 MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。 顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。 当然，数据库中还有一些没那么一目了然的概念和设计，这些概念如果理解和使用不当，容易导致程序出现非预期行为，比如两阶段锁。 1 从两阶段锁说起 先举个例子。在下面的操作序列中，事务 B 的 update 语句执行时会是什么现象呢？假设字段 id 是表 t 的主键。 这个问题的结论取决于事务 A 在执行完两条 update 语句后，持有哪些锁，以及在什么时候释放。可以验证一下：实际上事务 B 的 update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行。现在可以明确的是事务 A 持有的两个记录的行锁，都是在 commit 的时候才释放的。 也就是说，在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。 知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。举个例子。 假设你负责实现一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票。我们简化一点，这个业务需要涉及到以下操作： 从顾客 A 账户余额中扣除电影票价； 给影院 B 的账户余额增加这张电影票价； 记录一条交易日志。 也就是说，要完成这个交易，需要 update 两条记录，并 insert 一条记录。当然，为了保证交易的原子性，要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？ 试想如果同时有另外一个顾客 C 要在影院 B 买票，那么这两个事务冲突的部分就是语句 2 了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。 根据两阶段锁协议，不论怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果把语句 2 安排在最后，比如按照 3、1、2 这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。 好了，现在由于正确的设计，影院余额这一行的行锁在一个事务中不会停留很长时间。但是，这并没有完全解决你的困扰。 如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，你的 MySQL 就挂了。你登上服务器一看，CPU 消耗接近 100%，但整个数据库每秒就执行不到 100 个事务。这是什么原因呢？这就要说到死锁和死锁检测了。 2 死锁和死锁检测 当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。这里用数据库中的行锁举个例子。 这时候，事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1 的行锁。事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略： 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。 在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。 但是，又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。 所以，正常情况下还是要采用第二种策略，即：主动死锁检测，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。 可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。那如果是上面说到的所有事务都要更新同一行的场景呢？ 每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。 根据上面的分析，来讨论一下，怎么解决由这种热点行更新导致的性能问题呢？问题的症结在于，死锁检测要耗费大量的 CPU 资源。 一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。 另一个思路是控制并发度。根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有 10 个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。 因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。但是如果团队里暂时没有数据库方面的专家，不能实现这样的方案，能不能从设计上优化这个问题呢？ 你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。 这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成 0 的时候，代码要有特殊处理。 3 小结 如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放。 但是，调整语句顺序并不能完全避免死锁。所以引入了死锁和死锁检测的概念，以及提供了三个方案，来减少死锁对数据库的影响。减少死锁的主要方向，就是控制访问相同资源的并发事务量。 4 问题 问：如果你要删除一个表里面的前 10000 行数据，有以下三种方法可以做到： 第一种，直接执行 delete from T limit 10000; 第二种，在一个连接中循环执行 20 次 delete from T limit 500; 第三种，在 20 个连接中同时执行 delete from T limit 500。 你会选择哪一种方法呢？为什么呢？ 答：第二种方式是相对较好的。 第一种方式（即：直接执行 delete from T limit 10000）里面，单个语句占用时间长，锁的时间也比较长；而且大事务还会导致主从延迟。 第三种方式（即：在 20 个连接中同时执行 delete from T limit 500），会人为造成锁冲突。 ","date":"2025-02-11","objectID":"/posts/7.%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91%E8%A1%8C%E9%94%81%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"07 | 行锁功过：怎么减少行锁对性能的影响？","uri":"/posts/7.%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91%E8%A1%8C%E9%94%81%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"MySQL 的锁设计旨在处理并发访问问题，主要分为全局锁、表级锁和行锁。","date":"2025-02-11","objectID":"/posts/6.%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81%E7%BB%99%E8%A1%A8%E5%8A%A0%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E9%98%BB%E7%A2%8D/","tags":["MySQL 实战 45 讲","MySQL"],"title":"06 | 全局锁和表锁：给表加个字段怎么有这么多阻碍？","uri":"/posts/6.%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81%E7%BB%99%E8%A1%A8%E5%8A%A0%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E9%98%BB%E7%A2%8D/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 MySQL 的锁设计旨在处理并发访问问题，主要分为全局锁、表级锁和行锁。全局锁通过 Flush tables with read lock (FTWRL) 命令实现对整个数据库实例的加锁，常用于全库逻辑备份，而表级锁一般是在数据库引擎不支持行锁的时候才会被用到。 数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。 1 全局锁 顾名思义，全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。 全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。以前有一种做法，是通过 FTWRL 确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。但是让整库都只读，听上去就很危险： 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆； 如果在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。 看来加全局锁不太好。但是细想一下，备份为什么要加锁呢？先来看一下不加锁会有什么问题。 假设你现在要维护一个购买系统，关注的是用户账户余额表和用户课程表。 现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉他的余额，然后往已购课程里面加上一门课。 如果时间顺序上是先备份账户余额表 (u_account)，然后用户购买，然后备份用户课程表 (u_course)，会怎么样呢？可以看一下这个图： 可以看到，这个备份结果里，用户 A 的数据状态是“账户余额没扣，但是用户课程表里面已经多了一门课”。如果后面用这个备份来恢复数据的话，用户 A 就发现，自己赚了。 作为用户可别觉得这样可真好啊，可以试想一下：如果备份表的顺序反过来，先备份用户课程表再备份账户余额表，又可能会出现什么结果？ 也就是说，不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。其实是有一个方法能够拿到一致性视图的，就是在可重复读隔离级别下开启一个事务。 官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。 有了这个功能，为什么还需要 FTWRL 呢？一致性读是好，但前提是引擎要支持这个隔离级别。比如，对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，就需要使用 FTWRL 命令了。 所以，single-transaction 方法只适用于所有的表使用事务引擎的库。如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法。这往往是 DBA 要求业务开发人员使用 InnoDB 替代 MyISAM 的原因之一。 既然要全库只读，为什么不使用 set global readonly=true 的方式呢？确实 readonly 方式也可以让全库进入只读状态，但还是建议用 FTWRL 方式，主要有两个原因： 一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，不建议使用。 二是，在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。 业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，要对里面任何一个表做加字段操作，都是会被锁住的。 2 表级锁 MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。 表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。 举个例子，如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。 在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。 另一类表级的锁是 MDL（metadata lock)。MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。 因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。 读锁之间不互斥，因此可以有多个线程同时对一张表增删改查。 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。 虽然 MDL 锁是系统默认会加的，但却是不能忽略的一个机制。比如下面这个例子：给一个小表加个字段，导致整个库挂了。给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。来看一下下面的操作序列，假设表 t 是一个小表。 备注：这里的实验环境是 MySQL 5.6。 可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行。 之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。 如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。 如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。 事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。那么，如何安全地给小表加字段？ 首先要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，可以查到当前执行中的事务。如果要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。 但考虑一下这个场景。如果要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，该怎么做呢？ 这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。 MariaDB 已经合并了 AliSQL 的这个功能，所以这两个开源分支目前都支持 DDL NOWAIT/WAIT n 这个语法。 ALTER TABLE tbl_name NOWAIT add column ... ALTER TABLE tbl_name WAIT N add column ... 3 小结 全局锁主要用在逻辑备份过程中。对于全部是 InnoDB 引擎的库，建议你选择使用–single-transaction 参数，对应用会更友好。 表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现你的应用程序里有 lock tables 这样的语句，你需要追查一下，比较可能的情况是： 要么是你的系统现在还在用 MyISAM 这类不支持事务的引擎，那要安排升级换引擎； 要么是你的引擎升级了，但是代码还没升级。把 lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。 MDL 会直到事务提交才释放，在","date":"2025-02-11","objectID":"/posts/6.%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81%E7%BB%99%E8%A1%A8%E5%8A%A0%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E9%98%BB%E7%A2%8D/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"06 | 全局锁和表锁：给表加个字段怎么有这么多阻碍？","uri":"/posts/6.%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81%E7%BB%99%E8%A1%A8%E5%8A%A0%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E9%98%BB%E7%A2%8D/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入探讨了 MySQL 索引相关的概念，包括覆盖索引、最左前缀原则和索引下推。","date":"2025-02-10","objectID":"/posts/5.%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95-%E4%B8%8B/","tags":["MySQL 实战 45 讲","MySQL"],"title":"05 | 深入浅出索引（下）","uri":"/posts/5.%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95-%E4%B8%8B/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入探讨了 MySQL 索引相关的概念，包括覆盖索引、最左前缀原则和索引下推。覆盖索引能减少树的搜索次数，提升查询性能；最左前缀原则强调索引的复用能力，建议为高频请求创建联合索引；索引下推优化可减少回表次数，提高查询效率。 在下面这个表 T 中，如果执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？下面是这个表的初始化语句。 mysql\u003e create table T ( ID int primary key, k int NOT NULL DEFAULT 0, s varchar(16) NOT NULL DEFAULT '', index k(k)) engine=InnoDB; insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg'); 现在，我们一起来看看这条 SQL 查询语句的执行流程： 在 k 索引树上找到 k=3 的记录，取得 ID = 300； 再到 ID 索引树查到 ID=300 对应的 R3； 在 k 索引树取下一个值 k=5，取得 ID=500； 再回到 ID 索引树查到 ID=500 对应的 R4； 在 k 索引树取下一个值 k=6，不满足条件，循环结束。 在这个过程中，回到主键索引树搜索的过程，称为回表。可以看到，这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。 在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？ 1 覆盖索引 如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，称为覆盖索引。 由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。 需要注意的是，在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，R3~R5（对应的索引 k 上的记录项），但是对于 MySQL 的 Server 层来说，它就是找引擎拿到了两条记录，因此 MySQL 认为扫描行数是 2。 基于上面覆盖索引的说明，来讨论一个问题：在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？假设这个市民表的定义是这样的： CREATE TABLE `tuser` ( `id` int(11) NOT NULL, `id_card` varchar(32) DEFAULT NULL, `name` varchar(32) DEFAULT NULL, `age` int(11) DEFAULT NULL, `ismale` tinyint(1) DEFAULT NULL, PRIMARY KEY (`id`), KEY `id_card` (`id_card`), KEY `name_age` (`name`,`age`) ) ENGINE=InnoDB 我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？ 如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。 当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这正是业务 DBA，或者称为业务数据架构师的工作。 2 最左前缀原则 如果为每一种查询都设计一个索引，索引是不是太多了。如果现在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？ 这里先说结论吧。B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。为了直观地说明这个概念，用（name，age）这个联合索引来分析。 可以看到，索引项是按照索引定义里面出现的字段顺序排序的。当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。 如果要查的是所有名字第一个字是“张”的人，SQL 语句的条件是\"where name like‘张 %’\"。这时，也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。 可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。 基于上面对最左前缀索引的说明，来讨论一个问题：在建立联合索引的时候，如何安排索引内的字段顺序。 这里的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。 这段开头的问题里，要为高频请求创建 (身份证号，姓名）这个联合索引，并用这个索引支持“根据身份证号查询地址”的需求。那么，如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候不得不维护另外一个索引，也就是说需要同时维护 (a,b)、(b) 这两个索引。 这时候，要考虑的原则就是空间了。比如上面这个市民表的情况，name 字段是比 age 字段大的，那就建议你创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。 3 索引下推 最左前缀可以用于在索引中定位记录。那些不符合最左前缀的部分，会怎么样呢？还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的： mysql\u003e select * from tuser where name like '张%' and age=10 and ismale=1; 这个语句在搜索索引树的时候，只能用“张”，找到第一个满足条件的记录 ID3。当然，这还不错，总比全表扫描要好。然后呢？当然是判断其他条件是否满足。 在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。 而 MySQL 5.6 引入的索引下推优化（index condition pushdown)，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。 下面两幅图是这两个过程的执行流程图。 在上面这两个图里面，每一个虚线箭头表示回表一次。 第一幅中，在 (name,age) 索引里面去掉了 age 的值，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，需要回表 4 次。 第二幅图跟第一幅图的区别是，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。 4 小结 在满足语句需求的情况下，尽量少地访问资源是数据库设计的重要原则之一。在使用数据库的时候，尤其是在设计表结构时，也要以减少资源消耗作为目标。 5 问题 问：实际上主键索引也是可以使用多个字段的。DBA 小吕在入职新公司的时候，就发现自己接手维护的库里面，有这么一个表，表结构定义类似这样的： CREATE TABLE `geek` ( `a` int(11) NOT NULL, `b` int(11) NOT NULL, `c` int(11) NOT NULL, `d` int(11) NOT NULL, PRIMARY KEY (`a`,`b`), KEY `c` (`c`), KEY `ca` (`c`,`a`), KEY `cb` (`c`,`b`) ) ENGINE=InnoDB; 公司的同事告诉他说，由于历史原因，这个表需要 a、b 做联合主键，这个小吕理解了。但是小吕又纳闷了，既然主键包含了 a、b 这两个字段，那意味着单独在字段 c 上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？同事告诉他，是因为他们的业务里面有这样的两种语句： select * from geek where c=N order by a limit 1; select * from geek where c=N order by b limit 1; 这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？ 答：结论是 ca 可以去掉，cb 需要保留。 ","date":"2025-02-10","objectID":"/posts/5.%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95-%E4%B8%8B/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"05 | 深入浅出索引（下）","uri":"/posts/5.%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95-%E4%B8%8B/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文介绍了 MySQL 选择 B+ 树结构来存储数据的原因，并分析了数据库索引的重要性以及三种常见的索引模型：哈希表、有序数组和搜索树。","date":"2025-02-10","objectID":"/posts/4.%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95-%E4%B8%8A/","tags":["MySQL 实战 45 讲","MySQL"],"title":"04 | 深入浅出索引（上）","uri":"/posts/4.%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95-%E4%B8%8A/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文介绍了 MySQL 选择 B+ 树结构来存储数据的原因，并分析了数据库索引的重要性以及三种常见的索引模型：哈希表、有序数组和搜索树。文章重点介绍了 InnoDB 采用的 B+ 树索引模型，以及 B+ 树在维护索引有序性和索引维护过程中的作用。 一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本 500 页的书，如果想快速找到其中的某一个知识点，在不借助目录的情况下，那估计可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。 1 索引的常见模型 索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，先介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。下面主要从使用的角度，简单分析一下这三种模型的区别。 哈希表是一种以键 - 值（key-value）存储数据的结构，只要输入待查找的键即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。 不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。假设，现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示： 图中，User2 和 User4 根据身份证号算出来的值都是 N，但没关系，后面还跟了一个链表。假设，这时候要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。 需要注意的是，图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。可以设想下，如果现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。所以，哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。 而有序数组在等值查询和范围查询场景中的性能就都非常优秀。还是上面这个根据身份证号查名字的例子，如果使用有序数组来实现的话，示意图如下所示： 这里假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果要查 ID_card_n2 对应的名字，用二分法就可以快速得到，这个时间复杂度是 O(log(N))。 同时很显然，这个索引结构支持范围查询。要查身份证号在[ID_card_X, ID_card_Y]区间的 User，可以先用二分法找到 ID_card_X（如果不存在 ID_card_X，就找到大于 ID_card_X 的第一个 User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环。 如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，往中间插入一个记录就必须得挪动后面所有的记录，成本太高。所以，有序数组索引只适用于静态存储引擎，比如要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。 二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我们用二叉搜索树来实现的话，示意图如下所示： 二叉搜索树的特点是：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。这样如果要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -\u003e UserC -\u003e UserF -\u003e User2 这个路径得到。这个时间复杂度是 O(log(N))。 当然为了维持 O(log(N)) 的查询复杂度，就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。 树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。 可以想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。 为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。 以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。 不管是哈希还是有序数组，或者 N 叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM 树等数据结构也被用于引擎设计中。 数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。 在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。由于 InnoDB 存储引擎在 MySQL 数据库中使用最为广泛，下面就以 InnoDB 为例，分析一下其中的索引模型。 2 InnoDB 的索引模型 在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。每一个索引在 InnoDB 里面对应一棵 B+ 树。 假设，有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。这个表的建表语句是： mysql\u003e create table T( id int primary key, k int not null, name varchar(16), index (k))engine=InnoDB; 表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。 从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。 主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。 根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？ 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树； 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。 也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，在应用中应该尽量使用主键查询。 3 索引维护 B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。 而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。 除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。 当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。 基于上面的索引维护过程说明，我们来讨论一个案例： 你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。 自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的：NOT NULL PRIMARY KEY AUTO_INCREMENT。插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。 也就是说，自增主键的插入数据模式，正符合了前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。 而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。除了考虑性能外，还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号","date":"2025-02-10","objectID":"/posts/4.%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95-%E4%B8%8A/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"04 | 深入浅出索引（上）","uri":"/posts/4.%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95-%E4%B8%8A/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"本文深入介绍了事务隔离的重要性以及 MySQL 中事务隔离的实现方式。","date":"2025-02-10","objectID":"/posts/3.%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/","tags":["MySQL 实战 45 讲","MySQL"],"title":"03 | 事务隔离：为什么你改了我还看不见？","uri":"/posts/3.%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入介绍了事务隔离的重要性以及 MySQL 中事务隔离的实现方式。通过生动的转账例子引出了事务的概念，强调了事务的一致性和原子性。随后详细介绍了隔离级别的概念，包括读未提交、读提交、可重复读和串行化，并通过具体例子解释了不同隔离级别下的行为差异。 提到事务，大家肯定不陌生，和数据库打交道的时候，总是会用到事务。最经典的例子就是转账，你要给朋友小王转 100 块钱，而此时你的银行卡只有 100 块钱。 转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这 100 块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念了。 简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。 1 隔离性与隔离级别 提到事务，大家肯定会想到 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），文本主要说的是其中的 I，也就是“隔离性”。 当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。 在谈隔离级别之前，首先要知道，隔离得越严实，效率就会越低。因此很多时候，都要在二者之间寻找一个平衡点。SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable）。 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 其中“读提交”和“可重复读”比较难理解，用一个例子说明这几种隔离级别。假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为。 mysql\u003e create table T(c int) engine=InnoDB; insert into T(c) values(1); 来看看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是图里面 V1、V2、V3 的返回值分别是什么。 若隔离级别是“读未提交”，则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。 若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以，V3 的值也是 2。 若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。 若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看，V1、V2 值是 1，V3 的值是 2。 在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。 可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle 数据库的默认隔离级别其实就是“读提交”，因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，一定要记得将 MySQL 的隔离级别设置为“读提交”。 配置的方式是，将启动参数 transaction-isolation 的值设置成 READ-COMMITTED。可以用 show variables 来查看当前的值。 mysql\u003e show variables like 'transaction_isolation'; +-----------------------+----------------+ | Variable_name | Value | +-----------------------+----------------+ | transaction_isolation | READ-COMMITTED | +-----------------------+----------------+ 总结来说，存在即合理，每种隔离级别都有自己的使用场景，要根据自己的业务情况来定。你可能会问那什么时候需要“可重复读”的场景呢？来看一个数据校对逻辑的案例。 假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响校对结果。 这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。 2 事务隔离的实现 理解了事务的隔离级别，再来看看事务隔离具体是怎么实现的。这里展开说明“可重复读”。在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。 当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。 同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。 但是回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。 基于上面的说明，一起来讨论一下为什么建议尽量不要使用长事务。长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。 在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。可能会存在数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。 3 事务的启动方式 如前面所述，长事务有这些潜在风险，建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL 的事务启动方式有以下几种： 显式启动事务语句，begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。 set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到主动执行 commit 或 rollback 语句，或者断开连接。 有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。因此，建议你总是使用 set autocommit=1, 通过显式语句的方式来启动事务。 可能有的人会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次“begin”，减少了语句的交互次数。如果你有这个顾虑，建议你使用 commit work and chain 语法。 在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。 可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续","date":"2025-02-10","objectID":"/posts/3.%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"03 | 事务隔离：为什么你改了我还看不见？","uri":"/posts/3.%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"一条 SQL 更新语句是如何执行的？","date":"2025-02-09","objectID":"/posts/2.%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B8%80%E6%9D%A1sql%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/","tags":["MySQL 实战 45 讲","MySQL"],"title":"02 | 日志系统：一条 SQL 更新语句是如何执行的？","uri":"/posts/2.%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B8%80%E6%9D%A1sql%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文深入介绍了 MySQL 更新语句的执行流程和日志系统设计，包括重做日志和归档日志的特点，以及两阶段提交的重要性。可以从中了解 MySQL 的日志系统设计和执行过程，以及保证数据安全和一致性的关键参数设置建议。 一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。那么，一条更新语句的执行流程又是怎样的呢？ 之前你可能经常听 DBA 同事说，MySQL 可以恢复到半个月内任意一秒的状态，惊叹的同时，是不是心中也会不免会好奇，这是怎样做到的呢？我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键 ID 和一个整型字段 c： mysql\u003e create table T(ID int primary key, c int); 如果要将 ID=2 这一行的值加 1，SQL 语句就会这么写： mysql\u003e update T set c=c+1 where ID = 2; 首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。如下图所示： 你执行语句前要先连接数据库，这是连接器的工作。 在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是一般不建议使用查询缓存的原因。 接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。 与查询流程不一样的是，更新流程还涉及两个重要的日志模块：redo log（重做日志）和 binlog（归档日志）。如果接触 MySQL，那这两个词肯定是绕不过的。 1 重要的日志模块：redo log 在 MySQL 里有一个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。 具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。 如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。 与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。 write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。 write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。 有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。 要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。 2 重要的日志模块：binlog MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面说到的 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。你可能会问，为什么会有两份日志呢？ 因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。 这两种日志有以下三点不同。 redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。 redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1”。 redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 有了对这两个日志的概念性理解，再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。 下面是这个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。 最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是\"两阶段提交\"。 3 两阶段提交 为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，得从文章开头的那个问题说起：怎样让数据库恢复到半个月内任意一秒的状态？ binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。 当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做： 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库； 然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。 这样临时库就跟误删之前的线上库一样了，然后就可以把表数据从临时库取出来，按需要恢复到线上库去。说完了数据恢复过程，再回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。 由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。 仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？ 先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。 先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。 可以看到，如果不使用“两阶段提交","date":"2025-02-09","objectID":"/posts/2.%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B8%80%E6%9D%A1sql%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"02 | 日志系统：一条 SQL 更新语句是如何执行的？","uri":"/posts/2.%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B8%80%E6%9D%A1sql%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":"一条 SQL 查询语句是如何执行的？","date":"2025-02-08","objectID":"/posts/1.%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B8%80%E6%9D%A1sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/","tags":["MySQL 实战 45 讲","MySQL"],"title":"01 | 基础架构：一条 SQL 查询语句是如何执行的？","uri":"/posts/1.%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B8%80%E6%9D%A1sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"},{"categories":["MySQL 实战 45 讲","MySQL"],"content":" 摘要 本文将把 MySQL 拆解一下，看看里面都有哪些“零件”，希望借由这个拆解过程，让你对 MySQL 有更深入的理解。 平时使用数据库，看到的通常都是一个整体。比如，你有个最简单的表，表里只有一个 ID 字段，在执行下面这个查询语句时： mysql\u003e select * from T where ID = 10； 我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在 MySQL 内部的执行过程。下面的是 MySQL 的基本架构示意图，从中可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。 大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。 Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。 而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。 也就是说，在执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不过，也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同。从图中不难看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。 1 连接器 第一步，需要会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的： mysql -h$ip -P$port -u$user -p 输完命令之后，就需要在交互对话里面输入密码。虽然密码也可以直接跟在 -p 后面写在命令行中，但这样可能会导致密码泄露。如果连的是生产服务器，强烈建议不要这么做。连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是输入的用户名和密码。 如果用户名或密码不对，就会收到一个\"Access denied for user\"的错误，然后客户端程序结束执行。 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。 这就意味着，一个用户成功建立连接后，即使用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。 连接完成后，如果没有后续的动作，这个连接就处于空闲状态，可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。 客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒：Lost connection to MySQL server during query。这时候如果要继续，就需要重连，然后再执行请求了。 数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。建立连接的过程通常是比较复杂的，所以建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。 但是全部使用长连接后，可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。怎么解决这个问题呢？可以考虑以下两种方案。 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。 2 查询缓存 连接建立完成后，就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。 MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。 如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。 但是大多数情况下建议不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能很费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。 好在 MySQL 也提供了这种“按需使用”的方式。可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样： mysql\u003e select SQL_CACHE * from T where ID = 10； 需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。 3 分析器 如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。 分析器先会做“词法分析”。输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从输入的\"select\"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。 做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断输入的这个 SQL 语句是否满足 MySQL 语法。 如果语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。 mysql\u003e elect * from t where ID = 1; ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where ID=1' at line 1 一般语法错误会提示第一个出现错误的位置，所以要关注的是紧接“use near”的内容。 4 优化器 经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。 优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如执行下面这样的语句，这个语句是执行两个表的 join： mysql\u003e select * from t1 join t2 using(ID) where t1.c = 10 and t2.d = 20; 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。 这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。 5 执行器 MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。 开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。 mysql\u003e select * from T where ID = 10; ERROR 1142 (42000): SELECT command deni","date":"2025-02-08","objectID":"/posts/1.%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B8%80%E6%9D%A1sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/:0:0","tags":["MySQL 实战 45 讲","MySQL"],"title":"01 | 基础架构：一条 SQL 查询语句是如何执行的？","uri":"/posts/1.%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B8%80%E6%9D%A1sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"},{"categories":null,"content":"本页面记录了自「一个 PHP 菜鸟的心路历程」博客创建以来，所有的打赏记录。感谢大家的支持！","date":"2024-11-17","objectID":"/reward/","tags":null,"title":"赞赏记录","uri":"/reward/"},{"categories":null,"content":" 给博主买杯卡布奇诺～ 赞赏 支付宝 微信 本页面记录了自「一个 PHP 菜鸟的心路历程」博客创建以来，所有的打赏记录。感谢大家的支持！❤️ 总计 ¥666.00 单笔最大 w2lz 的 ¥666.00 w2lz ¥666.00 w2lz 通过 支付宝 打赏了 ¥666.00 备注：希望一切顺顺利利！ 2024-11-17 - 次阅读 ","date":"2024-11-17","objectID":"/reward/:0:0","tags":null,"title":"赞赏记录","uri":"/reward/"},{"categories":null,"content":"互联网的广大朋友们，欢迎光临我的小博客！欢迎留言！","date":"2024-11-17","objectID":"/guestbook/","tags":null,"title":"留言","uri":"/guestbook/"},{"categories":null,"content":"- 次阅读 Welcome 互联网的广大朋友们，欢迎光临我的小博客！欢迎留言！ 温馨提示，音乐自动播放，请带好耳机～ From playlist, Powered By mmt-netease 给博主买杯卡布奇诺～ 赞赏 支付宝 微信 - 次阅读 ","date":"2024-11-17","objectID":"/guestbook/:0:0","tags":null,"title":"留言","uri":"/guestbook/"},{"categories":null,"content":"「一个 PHP 菜鸟的心路历程」的友情链接","date":"2024-11-17","objectID":"/friends/","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":null,"content":"本页共 - 次阅读 基本信息 网络 ID：w2lz 头像：https://blog.yingnan.wang/images/avatar.jpg URL：https://blog.yingnan.wang 描述：一个 PHP 菜鸟的心路历程 - 「Talk is cheap. Show me the code.」（或者你对我的看法😉） 友链要求 友情提醒：那些不尊重他人劳动成果，转载不加出处的，或恶意行为的网站，还请你不要来进行交换了。 原创博客文章至少 10 篇以上，内容健康，无违法违规内容。 网站创建时间至少 3 个月以上，且长期保持更新。（频率至少一年 1 篇） 目前仅限个人非商业博客/网站。（商务合作邮件联系） 满足上述基本要求，互换友链请按以下格式在评论区留言： ```yaml - nickname: \u003cyour nickname\u003e avatar: \u003cyour avatar\u003e url: \u003cyour site link\u003e description: \u003cdescription of your site\u003e ``` 失效链接 公示一个月后删除，如更换域名请及时联系！ ","date":"2024-11-17","objectID":"/friends/:0:0","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":null,"content":" 不卑不亢，不矜不伐，戒骄戒躁 不嗔不怒，不争不弃，独善其身 —— 自我期许 关于作者 人知道的越多，就会发现无知的越多。有更广袤的世界可以探索，真是莫大的快乐！ 一个北漂的内蒙汉子，主要从事Golang、PHP和Java相关的开发工作。 👨‍💻 一名后端开发工程师 🫶 一个 PHP 菜鸟的心路历程 作者 📚 专业：计算机科学与技术  关注 Follow：w2lz  微信公众号：一个 PHP 菜鸟的心路历程 关于博客 博客内容主要以后端开发方向为主，分享一些有趣程序、技巧、开发教程、心情和学习记录等。 你可以通过我的微信公众号、GitHub 或 RSS 来订阅本博客。 /** * Licensed under CC BY-NC-SA 4.0 * @since 2018-05-28 20:01:01 */ package main import \"fmt\" type Blog struct { Name string `json:\"name\"` Author string `json:\"author\"` Url string `json:\"url\"` } func main() { blog := Blog{ Name: \"一个 PHP 菜鸟的心路历程\", Author: \"王二愣子\", Url: \"https://blog.yingnan.wang\", } fmt.Println(blog.Name) } 博客历史 博客 使用 Hugo 搭建，使用 FixIt 主题，取名为“一个 PHP 菜鸟的心路历程”。 2024-11-17 23:00:00 商务合作 广告投放、其他平台同步授权等事宜请邮件与我联系。 📮 邮箱：wangyingnan@88.com（备注来意） - 次阅读 ","date":"2024-11-17","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["GitHub"],"content":"w2lz/w2lz.github.io: 博客构建档（HTML \u0026 Markdown）","date":"2024-11-17","objectID":"/projects/w2lz/w2lz.github.io/","tags":[],"title":"博客构建档（HTML \u0026 Markdown）","uri":"/projects/w2lz/w2lz.github.io/"},{"categories":["GitHub"],"content":"一个 PHP 菜鸟的心路历程 共计 48 篇文章 2025 共计 46 篇文章 03-10 45 | 自增 id 用完怎么办？ 03-10 44 | 答疑文章（三）：说一说这些好问题 03-10 43 | 要不要使用分区表？ 03-10 42 | grant 之后要跟着 flush privileges 吗？ 03-10 41 | 怎么最快地复制一张表？ 03-10 40 | insert 语句的锁为什么这么多？ 03-10 39 | 自增主键为什么不是连续的？ 03-10 38 | 都说 InnoDB 好，那还要不要使用 Memory 引擎？ 03-10 37 | 什么时候会使用内部临时表？ 02-23 36 | 为什么临时表可以重名？ 02-23 35 | join 语句怎么优化？ 02-23 34 | 到底可不可以使用 join？ 02-23 33 | 我查这么多数据，会不会把数据库内存打爆？ 02-23 32 | 为什么还有 kill 不掉的语句？ 02-23 31 | 误删数据后除了跑路，还能怎么办？ 02-23 30 | 答疑文章（二）：用动态的观点看加锁 02-23 29 | 如何判断一个数据库是不是出问题了？ 02-23 28 | 读写分离有哪些坑？ 02-23 27 | 主库出问题了，从库怎么办？ 02-23 26 | 备库为什么会延迟好几个小时？ 02-16 25 | MySQL 是怎么保证高可用的？ 02-16 24 | MySQL 是怎么保证主备一致的？ 02-16 23 | MySQL 是怎么保证数据不丢的？ 02-16 22 | MySQL 有哪些“饮鸩止渴”提高性能的方法？ 02-16 21 | 为什么我只改一行的语句，锁这么多？ 02-16 20 | 幻读是什么，幻读有什么问题？ 02-16 19 | 为什么我只查一行的语句，也执行这么慢？ 02-16 18 | 为什么这些 SQL 语句逻辑相同，性能却差异巨大？ 02-16 17 | 如何正确地显示随机消息？ 02-16 16 | “order by”是怎么工作的？ 02-12 15 | 答疑文章（一）：日志和索引相关问题 02-12 14 | count(*) 这么慢，我该怎么办？ 02-12 13 | 为什么表数据删掉一半，表文件大小不变？ 02-12 12 | 为什么我的 MySQL 会“抖”一下？ 02-12 11 | 怎么给字符串字段加索引？ 02-12 10 | MySQL 为什么有时候会选错索引？ 02-12 1.Go 语言中如何访问私有成员？ 02-11 09 | 普通索引和唯一索引，应该怎么选择？ 02-11 08 | 事务到底是隔离的还是不隔离的？ 02-11 07 | 行锁功过：怎么减少行锁对性能的影响？ 02-11 06 | 全局锁和表锁：给表加个字段怎么有这么多阻碍？ 02-10 05 | 深入浅出索引（下） 02-10 04 | 深入浅出索引（上） 02-10 03 | 事务隔离：为什么你改了我还看不见？ 02-09 02 | 日志系统：一条 SQL 更新语句是如何执行的？ 02-08 01 | 基础架构：一条 SQL 查询语句是如何执行的？ 2024 共计 2 篇文章 11-17 博客构建档（HTML \u0026 Markdown） 11-17 一个 PHP 菜鸟的心路历程 ","date":"2024-11-17","objectID":"/projects/w2lz/w2lz.github.io/:0:0","tags":[],"title":"博客构建档（HTML \u0026 Markdown）","uri":"/projects/w2lz/w2lz.github.io/"},{"categories":["GitHub"],"content":"w2lz/hugo blog: 一个 PHP 菜鸟的心路历程","date":"2024-11-17","objectID":"/projects/w2lz/hugo-blog/","tags":[],"title":"一个 PHP 菜鸟的心路历程","uri":"/projects/w2lz/hugo-blog/"},{"categories":["GitHub"],"content":"一个 PHP 菜鸟的心路历程 站名“一个 PHP 菜鸟的心路历程”，主要是为了纪念刚入行的日子。 博客基于 Hugo 和 FixIt 搭建，建站的初衷不是为了炫耀所知，而是记录无知。 博客内容主要以 Web 后端开发方向为主，分享一些有趣程序、技巧、开发教程、心情和学习记录等。 你可以通过我的微信公众号、GitHub 或 RSS 来订阅本博客。 Content 归档 分类 合集 标签 Source 博客相关源码： Hugo FixIt 相关 更多 Roadmap Project setup 本博客已部署到 Vercel 和 GitHub Pages，工作流如下图所示： ▸ .github/ # GitHub configuration ▸ .scripts/ # custom scripts ▸ .shell/ # shell commands for hugo project, entrance: hugo_main.sh ▸ archetypes/ # page archetypes (like scaffolds of archetypes) ▸ assets/ # css, js, third-party libraries etc. ▸ config/ # configuration files ▸ content/ # markdown files for hugo project ▸ private/ # private submodule for encrypted content ▸ data/ # blog data (allow: yaml, json, toml), e.g. friends.yml ▸ public/ # build directory ▸ static/ # static files, e.g. favicon.ico ▸ themes/ # theme submodules System requirements Go Hugo: \u003e= 0.134.1 (extended version) Clone 首先点上 Star 😜，然后下载源码： git clone --recursive git@github.com:w2lz/hugo-blog.git \u0026\u0026 cd hugo-blog 下载源码后，可以通过下面的方式启动这个博客。 Hugo # Development environment hugo server --disableFastRender --navigateToChanged --bind 0.0.0.0 -O # Production environment hugo server --disableFastRender --navigateToChanged --environment production --bind 0.0.0.0 -O License 此存储库中的文本、图像和视频等内容采用 CC BY-NC-SA 4.0 许可 此存储库中的代码采用 MIT 许可 content/private 目录不在任何许可范围内 Author w2lz ","date":"2024-11-17","objectID":"/projects/w2lz/hugo-blog/:0:0","tags":[],"title":"一个 PHP 菜鸟的心路历程","uri":"/projects/w2lz/hugo-blog/"},{"categories":null,"content":"一个 PHP 菜鸟的心路历程博客私密文章 ","date":"0001-01-01","objectID":"/readme/:0:0","tags":null,"title":"","uri":"/readme/"}]